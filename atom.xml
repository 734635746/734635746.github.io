<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>何处似樽前</title>
  
  <subtitle>博观而约取，厚积而薄发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liuyoubin.top/"/>
  <updated>2020-08-20T14:06:22.366Z</updated>
  <id>http://liuyoubin.top/</id>
  
  <author>
    <name>liuyoubin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MyBatis中XML文件如何同Dao接口建立联系</title>
    <link href="http://liuyoubin.top/2020/08/20/backEnd/framework/MyBatis%E4%B8%ADXML%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E5%90%8CDao%E6%8E%A5%E5%8F%A3%E5%BB%BA%E7%AB%8B%E8%81%94%E7%B3%BB/"/>
    <id>http://liuyoubin.top/2020/08/20/backEnd/framework/MyBatis%E4%B8%ADXML%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E5%90%8CDao%E6%8E%A5%E5%8F%A3%E5%BB%BA%E7%AB%8B%E8%81%94%E7%B3%BB/</id>
    <published>2020-08-20T08:42:27.000Z</published>
    <updated>2020-08-20T14:06:22.366Z</updated>
    
    <content type="html"><![CDATA[<div class="note info">            <p>分析Dao接口是如何调用到Xml文件配置的Sql语句 </p>          </div><a id="more"></a><h1 id="解析XML文件"><a href="#解析XML文件" class="headerlink" title="解析XML文件"></a>解析XML文件</h1><p>​        我们知道Mybatis在初始化SqlSessionFactoryBuilder的时候会读取全局配置文件的信息，封装成一个Configuration对象中。</p><p>​        在这个过程中Mybatis同时会根据mapper-location路径，解析xml映射文件，这里主要要注意两个过程：</p><ol><li><p>创建SqlSource</p><p>​        Mybatis会把每个Sql标签封装成SqlSource对象，这里又根据静态sql和动态sql封装成不同的SqlSource,</p><p>静态SqlSource是一段String类型的sql语句，动态SqlSource则是一个个SqlNode组成</p></li><li><p>创建MappedStatement</p><p>​        Xml文件中每一个SQL标签对应一个MappedStatement对象，主要关注两个属性</p><ul><li>id 全限定类名+方法名 (唯一标识一个MappedStatement对象)</li><li>sqlSource</li></ul></li></ol><p>​        <strong>Mybatis创建完所有MappedStatement后，会缓存到Configuration的MappedStatements中</strong></p><h1 id="Dao接口代理和注入"><a href="#Dao接口代理和注入" class="headerlink" title="Dao接口代理和注入"></a>Dao接口代理和注入</h1><p>​        我们知道我们的接口是没有实现类的，当最终我们可以注入接口，肯定是有人帮我们创建了实现对象。这里就是Spring容器通过jdk动态代理帮我们生成了代理对象。</p><p>​        在项目中我们通常会用@MapperScan注解来扫描接口，那么这个注解主要做了什么呢?</p><p>​        这个注解主要是将指定路径下的类注册到Spring容器中并生成对应BeanDefinition，并将BeanDefinition中的beanClass设置成MapperFactoryBean。也就是我们所说的工厂bean，当我们注入Dao接口的时候，注入的对象就是这个工厂bean中getObject()方法返回的对象。</p><p>​        这个代理对象就是MapperProxy对象，当我们Dao接口的方法时，实际上调用的就是代理对象的invoke方法。</p><h1 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h1><p>​        上面说到调用Dao接口的方法实际上就是调用了代理对象的invoke方法。在Mybatis中负责执行sql的是SqlSession，默认使用的是实现类DefaultSqlSession</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSession</span> <span class="keyword">implements</span> <span class="title">SqlSession</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">            <span class="keyword">return</span> executor.query(ms, </span><br><span class="line">                wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        看到上面的代码就知道，SqlSession通过全限定类型+方法名作为id到configuration中获取对应的MappedStatement对象，交给executor执行器去执行sql并返回。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;
            &lt;p&gt;分析Dao接口是如何调用到Xml文件配置的Sql语句 &lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="框架" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="MyBatis" scheme="http://liuyoubin.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Java线程与线程池</title>
    <link href="http://liuyoubin.top/2020/08/19/backEnd/java/Java%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://liuyoubin.top/2020/08/19/backEnd/java/Java%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-08-19T08:46:27.000Z</published>
    <updated>2020-08-20T08:39:26.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><p>​        如今主流的线程模型主要分成 <strong>用户级线程(ULT)</strong>和<strong>内核级线程(KLT)</strong></p><ul><li><strong>用户级线程(ULT)</strong>：由用户程序实现，不依赖操作系统核心，应用提供创建、同步、调度和管理线程的函数来控制用户线程。<strong>不需要用户态/内核态的切换，速度快</strong>。内核对ULT无感知，线程阻塞则进程(包括他所有线程)阻塞。</li><li><strong>内核级线程(KLT)</strong>：系统内核管理线程，内核保存线程状态和上下文信息，线程阻塞不会引起进行阻塞。在多处理器上，多线程在多处理器上并发运行。线程的创建、调度和管理由内核完成，效率比ULT要慢，比进程快。</li></ul><p><img src="https://s1.ax1x.com/2020/08/19/d3uKE9.png" alt="image"></p><a id="more"></a><h2 id="Java线程模型"><a href="#Java线程模型" class="headerlink" title="Java线程模型"></a>Java线程模型</h2><p>​        Java线程模型是<strong>内核级线程(KLT)</strong>，依赖于内核，通过JVM调用系统库创建内核线程，<strong>内核线程和Java-Thread是1：1的映射关系</strong></p><p><img src="https://s1.ax1x.com/2020/08/19/d3nO9P.png" alt="image"></p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池的意义"><a href="#线程池的意义" class="headerlink" title="线程池的意义"></a>线程池的意义</h2><p>​        线程是稀缺资源，他的创建和销毁是一个相对偏重且耗资源的操作。而且Java的线程模型的KLT，依赖于内核线程。线程的创建和切换需要进行<strong>用户态/内核态的切换</strong>。为了避免资源的过度消耗，需要去重用线程执行多个任务，线程池就是这样一种池化技术，负责对线程进行统一创建、调度和监控。</p><ul><li>线程池的优势<ul><li>重用线程，减少线程的创建，销毁的开销，提供性能</li><li>提供响应速度，当任务到达时可以不去等待线程的创建，立即执行任务</li><li>提高线程的可管理性，可统一分配、调度监控</li></ul></li></ul><h2 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h2><p>Java为我们提供了一套线程池接口以及实现</p><p><img src="https://s2.ax1x.com/2020/02/13/1O1vC9.png" alt="image"></p><h3 id="三大方法"><a href="#三大方法" class="headerlink" title="三大方法"></a>三大方法</h3><p>线程池工具类Executors还提供了几个定制线程池的创建方法</p><ul><li><p>*<em>ExecutorService   Executors.newFixedThreadPool() *</em> 创建固定大小的线程池</p></li><li><p>*<em>ExecutorService   Executors.newCachedThreadPool() *</em> 创建缓存线程池，大小根据需求自动更改</p></li><li><p>*<em>ExecutorService   Executors.newSingleThreadExecutor() *</em>创建单个线程池，只有一个线程</p></li></ul><h3 id="七大参数"><a href="#七大参数" class="headerlink" title="七大参数"></a>七大参数</h3><p>线程池的创建主要是ThreadPoolExecutor这个构造方法，通过七个参数来设置线程池</p><ul><li><p>corePoolSize 核心线程数</p><p>核心线程一旦创建，在线程池运行过程中就不会销毁（注意线程池一开始是没有任何线程的，只有任务到来才开始创建核心线程）</p></li><li><p>maximumPoolSize 最大线程数</p><p>最大线程数= 核心线程数+临时线程数</p><p>临时线程的创建时机是：当任务到来时，核心线程数已经达到最大数量，且所有核心线程已经有任务在执行才会创建</p></li><li><p>keepAliveTime 超时时间</p><p>当临时线程的空闲时间超过这个设置的超时时间，临时线程就会被回收</p></li><li><p>unit 超时时间的时间单位</p></li><li><p>workQueue 任务阻塞队列</p><p>任务的临时等待队列，等待线程来接收任务</p></li><li><p>threadFactory 线程工厂</p></li><li><p>handler 拒绝策略</p><p>用于设置当任务阻塞队列满了之后，新任务到来时线程池采用的应对策略</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, //核心线程池大小</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,//最大线程池大小</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,//超时时间，时间过了没人使用就会释放</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,//超时单位</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,//阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,//线程工厂，一般不用改动</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler//拒绝策略)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看完这七大参数再看一下上面三大线程池构造方式实际上调用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出本质上都是实例化了ThreadPoolExecutor，只是方法参数不同</p><p>而阿里巴巴开发手册有一点要求就是：</p><blockquote><p>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样 的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 </p><p>说明：Executors 返回的线程池对象的弊端如下： </p><p>1）FixedThreadPool 和 SingleThreadPool: 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 </p><p>2）CachedThreadPool 和 ScheduledThreadPool: 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p></blockquote><h3 id="四大拒绝策略"><a href="#四大拒绝策略" class="headerlink" title="四大拒绝策略"></a>四大拒绝策略</h3><p><img src="https://s2.ax1x.com/2020/02/25/3tFG6O.png" alt="image"></p><ol><li><p>什么时候会触发拒绝策略呢？</p><p>​    当线程池达到最大承载，还有任务提交到线程池的时候。最大承载: <strong>阻塞队列大小+最大线程数</strong>    </p><p>​    就像下面这段代码，自定义了一个线程池。此线程池的最大承载=<strong>阻塞队列大小+最大线程数</strong>=3+5=8，现在我提交了9个任务，线程池就会触发拒绝策略AbortPolicy，抛出异常。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>,<span class="comment">//核心线程池大小</span></span><br><span class="line">            <span class="number">5</span>,<span class="comment">//最大线程池大小</span></span><br><span class="line">            <span class="number">3</span>,<span class="comment">//超时时间，时间过了没人使用就会释放</span></span><br><span class="line">            TimeUnit.SECONDS,<span class="comment">//超时单位</span></span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),<span class="comment">//阻塞队列</span></span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());<span class="comment">//阻塞队列满了，还有任务添加就抛异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">        threadPool.execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" ok"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>四大拒绝策略的定义</li></ol><table><thead><tr><th align="center">拒绝策略</th><th align="center">执行行为</th></tr></thead><tbody><tr><td align="center">AbortPolicy</td><td align="center">抛出异常</td></tr><tr><td align="center">CallerRunsPolicy</td><td align="center">线程池拒绝处理，由提交的线程自行处理</td></tr><tr><td align="center">DiscardPolicy</td><td align="center">丢掉任务，不会抛出异常</td></tr><tr><td align="center">DiscardOldestPolicy</td><td align="center">尝试和最早的任务竞争线程，失败则丢掉任务，不会抛出异常</td></tr></tbody></table><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://s1.ax1x.com/2020/08/20/dGC3jA.png" alt="iamge"></p><h2 id="Java线程池状态"><a href="#Java线程池状态" class="headerlink" title="Java线程池状态"></a>Java线程池状态</h2><p><strong>Java线程池有以下五种状态</strong></p><table><thead><tr><th align="center">线程池状态</th><th align="center">线程池行为</th></tr></thead><tbody><tr><td align="center">Running</td><td align="center">能接收新任务，处理已添加任务</td></tr><tr><td align="center">Shutdown</td><td align="center">不能接收新任务，但可以处理已添加任务</td></tr><tr><td align="center">Stop</td><td align="center">不能接收新任务，不处理已添加任务，并且中断正在执行的任务</td></tr><tr><td align="center">Tidying</td><td align="center">所有任务已经中止，ctl记录的线程数量为0</td></tr><tr><td align="center">Terminated</td><td align="center">线程池彻底终止</td></tr></tbody></table><p><img src="https://s1.ax1x.com/2020/08/20/dGiW6J.png" alt="image"></p><p>Java线程池通过一个整型变量<strong>ctl</strong>来记录<strong>线程池状态+线程数量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Packing and unpacking ctl</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><p>ctl高三位记录线程池状态，低29为记录线程数量。这样的好处是保证在线程池运行过程中的一致性、原子性。</p><p><img src="https://s1.ax1x.com/2020/08/20/dGAHhV.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程模型&quot;&gt;&lt;a href=&quot;#线程模型&quot; class=&quot;headerlink&quot; title=&quot;线程模型&quot;&gt;&lt;/a&gt;线程模型&lt;/h1&gt;&lt;p&gt;​        如今主流的线程模型主要分成 &lt;strong&gt;用户级线程(ULT)&lt;/strong&gt;和&lt;strong&gt;内核级线程(KLT)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用户级线程(ULT)&lt;/strong&gt;：由用户程序实现，不依赖操作系统核心，应用提供创建、同步、调度和管理线程的函数来控制用户线程。&lt;strong&gt;不需要用户态/内核态的切换，速度快&lt;/strong&gt;。内核对ULT无感知，线程阻塞则进程(包括他所有线程)阻塞。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内核级线程(KLT)&lt;/strong&gt;：系统内核管理线程，内核保存线程状态和上下文信息，线程阻塞不会引起进行阻塞。在多处理器上，多线程在多处理器上并发运行。线程的创建、调度和管理由内核完成，效率比ULT要慢，比进程快。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/19/d3uKE9.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="Java" scheme="http://liuyoubin.top/tags/Java/"/>
    
      <category term="多线程" scheme="http://liuyoubin.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Git命令大全</title>
    <link href="http://liuyoubin.top/2020/08/18/tools/Git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://liuyoubin.top/2020/08/18/tools/Git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</id>
    <published>2020-08-17T16:25:30.000Z</published>
    <updated>2020-08-17T16:29:15.647Z</updated>
    
    <content type="html"><![CDATA[<div class="note info">            <p>Git命令大全-方便开发时查阅 </p>          </div><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">git init                                                  <span class="comment"># 初始化本地git仓库（创建新仓库）</span></span><br><span class="line">git config --global user.name <span class="string">"xxx"</span>                       <span class="comment"># 配置用户名</span></span><br><span class="line">git config --global user.email <span class="string">"xxx@xxx.com"</span>              <span class="comment"># 配置邮件</span></span><br><span class="line">git config --global color.ui <span class="literal">true</span>                         <span class="comment"># git status等命令自动着色</span></span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.branch auto</span><br><span class="line">git config --global color.interactive auto</span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy                    <span class="comment"># remove  proxy configuration on git</span></span><br><span class="line">git <span class="built_in">clone</span> git+ssh://git@192.168.53.168/VT.git             <span class="comment"># clone远程仓库</span></span><br><span class="line">git status                                                <span class="comment"># 查看当前版本状态（是否修改）</span></span><br><span class="line">git add xyz                                               <span class="comment"># 添加xyz文件至index</span></span><br><span class="line">git add .                                                 <span class="comment"># 增加当前子目录下所有更改过的文件至index</span></span><br><span class="line">git commit -m <span class="string">'xxx'</span>                                       <span class="comment"># 提交</span></span><br><span class="line">git commit --amend -m <span class="string">'xxx'</span>                               <span class="comment"># 合并上一次提交（用于反复修改）</span></span><br><span class="line">git commit -am <span class="string">'xxx'</span>                                      <span class="comment"># 将add和commit合为一步</span></span><br><span class="line">git rm xxx                                                <span class="comment"># 删除index中的文件</span></span><br><span class="line">git rm -r *                                               <span class="comment"># 递归删除</span></span><br><span class="line">git <span class="built_in">log</span>                                                   <span class="comment"># 显示提交日志</span></span><br><span class="line">git <span class="built_in">log</span> -1                                                <span class="comment"># 显示1行日志 -n为n行</span></span><br><span class="line">git <span class="built_in">log</span> -5</span><br><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span>                                            <span class="comment"># 显示提交日志及相关变动文件</span></span><br><span class="line">git <span class="built_in">log</span> -p -m</span><br><span class="line">git show dfb02e6e4f2f7b573337763e5c0013802e392818         <span class="comment"># 显示某个提交的详细内容</span></span><br><span class="line">git show dfb02                                            <span class="comment"># 可只用commitid的前几位</span></span><br><span class="line">git show HEAD                                             <span class="comment"># 显示HEAD提交日志</span></span><br><span class="line">git show HEAD^                                            <span class="comment"># 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本</span></span><br><span class="line">git tag                                                   <span class="comment"># 显示已存在的tag</span></span><br><span class="line">git tag -a v2.0 -m <span class="string">'xxx'</span>                                  <span class="comment"># 增加v2.0的tag</span></span><br><span class="line">git show v2.0                                             <span class="comment"># 显示v2.0的日志及详细内容</span></span><br><span class="line">git <span class="built_in">log</span> v2.0                                              <span class="comment"># 显示v2.0的日志</span></span><br><span class="line">git diff                                                  <span class="comment"># 显示所有未添加至index的变更</span></span><br><span class="line">git diff --cached                                         <span class="comment"># 显示所有已添加index但还未commit的变更</span></span><br><span class="line">git diff HEAD^                                            <span class="comment"># 比较与上一个版本的差异</span></span><br><span class="line">git diff HEAD -- ./lib                                    <span class="comment"># 比较与HEAD版本lib目录的差异</span></span><br><span class="line">git diff origin/master..master                            <span class="comment"># 比较远程分支master上有本地分支master上没有的</span></span><br><span class="line">git diff origin/master..master --<span class="built_in">stat</span>                     <span class="comment"># 只显示差异的文件，不显示具体内容</span></span><br><span class="line">git remote add origin git+ssh://git@192.168.53.168/VT.git <span class="comment"># 增加远程定义（用于push/pull/fetch）</span></span><br><span class="line">git branch                                                <span class="comment"># 显示本地分支</span></span><br><span class="line">git branch --contains 50089                               <span class="comment"># 显示包含提交50089的分支</span></span><br><span class="line">git branch -a                                             <span class="comment"># 显示所有分支</span></span><br><span class="line">git branch -r                                             <span class="comment"># 显示所有原创分支</span></span><br><span class="line">git branch --merged                                       <span class="comment"># 显示所有已合并到当前分支的分支</span></span><br><span class="line">git branch --no-merged                                    <span class="comment"># 显示所有未合并到当前分支的分支</span></span><br><span class="line">git branch -m master master_copy                          <span class="comment"># 本地分支改名</span></span><br><span class="line">git checkout -b master_copy                               <span class="comment"># 从当前分支创建新分支master_copy并检出</span></span><br><span class="line">git checkout -b master master_copy                        <span class="comment"># 上面的完整版</span></span><br><span class="line">git checkout features/performance                         <span class="comment"># 检出已存在的features/performance分支</span></span><br><span class="line">git checkout --track hotfixes/BJVEP933                    <span class="comment"># 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</span></span><br><span class="line">git checkout v2.0                                         <span class="comment"># 检出版本v2.0</span></span><br><span class="line">git checkout -b devel origin/develop                      <span class="comment"># 从远程分支develop创建新本地分支devel并检出</span></span><br><span class="line">git checkout -- README                                    <span class="comment"># 检出head版本的README文件（可用于修改错误回退）</span></span><br><span class="line">git merge origin/master                                   <span class="comment"># 合并远程master分支至当前分支</span></span><br><span class="line">git cherry-pick ff44785404a8e                             <span class="comment"># 合并提交ff44785404a8e的修改</span></span><br><span class="line">git push origin master                                    <span class="comment"># 将当前分支push到远程master分支</span></span><br><span class="line">git push origin :hotfixes/BJVEP933                        <span class="comment"># 删除远程仓库的hotfixes/BJVEP933分支</span></span><br><span class="line">git push --tags                                           <span class="comment"># 把所有tag推送到远程仓库</span></span><br><span class="line">git fetch                                                 <span class="comment"># 获取所有远程分支（不更新本地分支，另需merge）</span></span><br><span class="line">git fetch --prune                                         <span class="comment"># 获取所有原创分支并清除服务器上已删掉的分支</span></span><br><span class="line">git pull origin master                                    <span class="comment"># 获取远程分支master并merge到当前分支</span></span><br><span class="line">git mv README README2                                     <span class="comment"># 重命名文件README为README2</span></span><br><span class="line">git reset --hard HEAD                                     <span class="comment"># 将当前版本重置为HEAD（通常用于merge失败回退）</span></span><br><span class="line">git rebase</span><br><span class="line">git branch -d hotfixes/BJVEP933                           <span class="comment"># 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）</span></span><br><span class="line">git branch -D hotfixes/BJVEP933                           <span class="comment"># 强制删除分支hotfixes/BJVEP933</span></span><br><span class="line">git ls-files                                              <span class="comment"># 列出git index包含的文件</span></span><br><span class="line">git show-branch                                           <span class="comment"># 图示当前分支历史</span></span><br><span class="line">git show-branch --all                                     <span class="comment"># 图示所有分支历史</span></span><br><span class="line">git whatchanged                                           <span class="comment"># 显示提交历史对应的文件修改</span></span><br><span class="line">git revert dfb02e6e4f2f7b573337763e5c0013802e392818       <span class="comment"># 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818</span></span><br><span class="line">git ls-tree HEAD                                          <span class="comment"># 内部命令：显示某个git对象</span></span><br><span class="line">git rev-parse v2.0                                        <span class="comment"># 内部命令：显示某个ref对于的SHA1 HASH</span></span><br><span class="line">git reflog                                                <span class="comment"># 显示所有提交，包括孤立节点</span></span><br><span class="line">git show HEAD@&#123;5&#125;</span><br><span class="line">git show master@&#123;yesterday&#125;                               <span class="comment"># 显示master分支昨天的状态</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">'%h %s'</span> --graph                   <span class="comment"># 图示提交日志</span></span><br><span class="line">git show HEAD~3</span><br><span class="line">git show -s --pretty=raw 2be7fcb476</span><br><span class="line">git stash                                                 <span class="comment"># 暂存当前修改，将所有至为HEAD状态</span></span><br><span class="line">git stash list                                            <span class="comment"># 查看所有暂存</span></span><br><span class="line">git stash show -p stash@&#123;0&#125;                               <span class="comment"># 参考第一次暂存</span></span><br><span class="line">git stash apply stash@&#123;0&#125;                                 <span class="comment"># 应用第一次暂存</span></span><br><span class="line">git grep <span class="string">"delete from"</span>                                    <span class="comment"># 文件中搜索文本“delete from”</span></span><br><span class="line">git grep -e <span class="string">'#define'</span> --and -e SORT_DIRENT</span><br><span class="line">git gc</span><br><span class="line">git fsck</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;
            &lt;p&gt;Git命令大全-方便开发时查阅 &lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="工具" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="http://liuyoubin.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码分析</title>
    <link href="http://liuyoubin.top/2020/06/30/backEnd/java/ThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://liuyoubin.top/2020/06/30/backEnd/java/ThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2020-06-30T10:49:54.000Z</published>
    <updated>2020-06-30T14:57:47.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>​        ThreadLocal是Java解决中解决线程安全的一种方式，ThreadLocal为每个线程提供了一个本地变量副本，这个副本是线程隔离的。</p><p>​        每个线程都维护着一个ThreadLocalMap实例对象。我们知道Map结构就是Key-value结构，在这里ThreadLocal就是Key，而Value就是我们要进行维护的本地数据。</p><a id="more"></a><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>如果有一些数据的作用域是线程，每个线程的自己的数据副本可以考虑使用ThreadLocal</li><li>解决线程问题，相比于synchronized让线程阻塞来解决线程安全问题，ThreadLocal通过牺牲空间来解决线程安全问题</li></ul><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>上面说过每一个线程维护着一个ThreadLocalMap,所以我们可以在Thread中找到这样一个实例变量threadLocals</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 与此线程有关的ThreadLocal值。该映射由ThreadLocal类维护 */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延迟构造"><a href="#延迟构造" class="headerlink" title="延迟构造"></a>延迟构造</h3><p>​        ThreadLocalMap是延迟构造的，只有当通过ThreadLocal设置第一个数据才构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造一个最初包含（firstKey，firstValue）的新Map。 ThreadLocalMaps是延迟构造的，因此只有在至少有一个条目要放置时才创建一个。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">            <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">            table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​        从上面的代码可以看出ThreadMap是一个通过Entry型的table来管理数据，默认长度为16，结构和HashMap很相似</p><h2 id="TreadLocal"><a href="#TreadLocal" class="headerlink" title="TreadLocal"></a>TreadLocal</h2><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       <span class="comment">//获取线程的ThreadLocalMap对象</span></span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">           map.set(<span class="keyword">this</span>, value);<span class="comment">//如果map存在则调用map的set方法进行设值</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           createMap(t, value);<span class="comment">//如果不存在则以当前的value为第一个元素创建map</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);<span class="comment">//这里就是ThreadLocalMap延迟构造的体现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取线程的ThreadLocalMap对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;<span class="comment">//获取到key映射的value</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果map为空获取key不在map中则调用此方法</span></span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">这里可以调用了initialValue()方法进行value的初始化，而在这里的initialValue仅仅返回null</span></span><br><span class="line"><span class="comment">所以我们在开发中可以通过重写这个方法来对ThreadLocal进行一个value的初始化操作</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T value = initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">             m.remove(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//m.remove(this)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    e.clear();</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h1&gt;&lt;p&gt;​        ThreadLocal是Java解决中解决线程安全的一种方式，ThreadLocal为每个线程提供了一个本地变量副本，这个副本是线程隔离的。&lt;/p&gt;
&lt;p&gt;​        每个线程都维护着一个ThreadLocalMap实例对象。我们知道Map结构就是Key-value结构，在这里ThreadLocal就是Key，而Value就是我们要进行维护的本地数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="Java" scheme="http://liuyoubin.top/tags/Java/"/>
    
      <category term="多线程" scheme="http://liuyoubin.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ReentranLock与AQS</title>
    <link href="http://liuyoubin.top/2020/04/30/backEnd/java/ReentranLock%E4%B8%8EAQS/"/>
    <id>http://liuyoubin.top/2020/04/30/backEnd/java/ReentranLock%E4%B8%8EAQS/</id>
    <published>2020-04-30T10:49:54.000Z</published>
    <updated>2020-05-02T09:38:04.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>​        抽象队列式同步器<code>AbstractQueuedSynchronizer</code>下面简称AQS，是java并发包的下面很多类的实现基础，比如常见的ReentranLock、CyclicBarrier、Semaphore都是基于AQS实现了。</p><p>​        AQS的实现原理就是<strong>通过一个共享变量state来实现对线程入队阻塞和出队唤醒操作</strong>。</p><p>​        这次具体通过对ReentranLock的源码分析来学习AQS</p><a id="more"></a><h1 id="ReentranLock"><a href="#ReentranLock" class="headerlink" title="ReentranLock"></a>ReentranLock</h1><p>​        ReentranLock是jdk1.5加入的一个类，用于协调线程对共享资源的访问本质上是一种锁机制。</p><p>​        ReentranLock和Synchronized一样是一把可重入锁，但是与Synchronized不同的是ReentranLoak支持公平锁和可中断的阻塞。</p><h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><p>​        ReentraLock分为公平锁和非公平锁，可以通过其构造函数指定。所谓公平和非公平主要区别在于获得锁的机会是否取决于线程的排队顺序。</p><p>​        当锁已经被一个线程占用，其他线程申请锁将会被阻塞挂起，加入队列。理论上来说先调用lock指令的线程将排在队列前面。</p><p>​        当锁被释放，公平锁会唤醒队列前面的线程去获得锁，非公平锁则是唤醒所以阻塞线程去尝试获取锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定公平锁、非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        通过源码可以知道<code>FairSync</code>和<code>NonfairSync</code>都继承了抽象的静态内部类<code>Sync</code>，而<code>Sync</code>则继承了<code>AbstractQueuedSynchronizer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>​        ReentranLock的Lock方法调用了Sync的lock方法，而Sync的lock没有具体实现，实际上是调用了<code>FairSync</code>或者是<code>NonfairSync</code>的lock方法，下面以公平锁来进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//ReentranLock的Lock方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        可以发现lock方法调用了acquire这个方法，这个方法是AQS中的一个重要方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AQS的acquire方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tryAcquire首先尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">//在尝试获取锁失败后调用addWaiter方法给当前线程创建一个节点，并将其加入等待队列</span></span><br><span class="line">        <span class="comment">//acquireQueued的作用是让又可能获取锁的线程循环获取，其他线程进入阻塞状态</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h3><p>​            tryAcquire方法在AQS中并没有具体实现，这里由FairSync进行了实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AQS中的同步共享变量，用于抽象锁资源</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//state的值为0，说明当前锁还没有被线程占用</span></span><br><span class="line">                <span class="comment">//如果当前阻塞队列没有先来的线程在等待</span></span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    <span class="comment">//cas成功，则将当前线程设置成变量的占有线程</span></span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="comment">//如果已经获取到了锁，根据可重入特性将state进行+1就可以，表示多次加锁</span></span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//以上情况都不符合，则获取锁失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​            从上面可以看出<code>tryAcquire</code>的就是通过<code>state</code>判断当前锁的占用情况，如果<code>state</code>为0则判断是否有先到来的线程（在非公平锁中则没有这一步），cas设置state成功则表示获得锁；如果占用线程是本线程则根据可重入特性对state进行加1操作。</p><h3 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h3><p>​        <code>addWaiter</code>给尝试获取锁失败的当前线程创建一个节点，并将其加入等待队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//给当前线程创建一个节点</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">//先用快速入队法进行尝试入队，失败了才用更加耗时的完备算法</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//完备的入队算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        通过addWaiter将当前线程加入到等待队列，但此时线程还没有阻塞</p><h3 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h3><p>​        由于阻塞状态会降低cpu执行效率，所以AQS会避免有可能获取锁的线程进入阻塞状态。<code>acquireQueued</code>方法里面有一个for循环不断判断当前节点是否处于队列首部，如果是则循环获取锁；否则通过<code>shouldParkAfterFailedAcquire</code>方法判断是否可以进入阻塞状态如果当前节点的前一个节点已经进入阻塞状态则可以当前节点设置为阻塞状态，则调用<code>parkAndCheckInterrupt</code>将节点设置为阻塞状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">//循环判断，直到获取锁</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">//node的前驱节点是head证明node就是下一个要获取锁的节点</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//继续尝试获取锁</span></span><br><span class="line">                    setHead(node);<span class="comment">//如果成功则node设置成head</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//此时不需要进入阻塞则，直接返回false</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断当前节点是否要进入阻塞状态，如果shouldParkAfterFailedAcquire为true，调用parkAndCheckInterrupt进入阻塞</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)<span class="comment">//前一个节点正在等待锁定释放，则单前节点可以阻塞</span></span><br><span class="line">           </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;<span class="comment">//前一个节点处于释放锁定状态，所以跳过                           </span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将上一个节点的状态设置为signal,返回false,</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        通过源码可以发现线程调用<code>LockSupport.park(this)</code>将当前线程设置为阻塞状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//设置阻塞对象</span></span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    <span class="comment">//设置线程不接受调度</span></span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h2><p>​        与lock方法类似，<code>unlock</code>方法调用的是<code>AQS</code>的<code>release</code>进行锁定释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reentranlock的unlock方法 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AQS的release方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Sycn重写了AQS的tryRelease方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//state为0，则代表锁释放</span></span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒阻塞线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AQS&quot;&gt;&lt;a href=&quot;#AQS&quot; class=&quot;headerlink&quot; title=&quot;AQS&quot;&gt;&lt;/a&gt;AQS&lt;/h1&gt;&lt;p&gt;​        抽象队列式同步器&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;下面简称AQS，是java并发包的下面很多类的实现基础，比如常见的ReentranLock、CyclicBarrier、Semaphore都是基于AQS实现了。&lt;/p&gt;
&lt;p&gt;​        AQS的实现原理就是&lt;strong&gt;通过一个共享变量state来实现对线程入队阻塞和出队唤醒操作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;​        这次具体通过对ReentranLock的源码分析来学习AQS&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="并发" scheme="http://liuyoubin.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Java" scheme="http://liuyoubin.top/tags/Java/"/>
    
      <category term="多线程" scheme="http://liuyoubin.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>秒杀系统</title>
    <link href="http://liuyoubin.top/2020/04/26/backEnd/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"/>
    <id>http://liuyoubin.top/2020/04/26/backEnd/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-04-26T10:50:36.000Z</published>
    <updated>2020-04-26T15:46:35.568Z</updated>
    
    <content type="html"><![CDATA[<div class="note info">            <p>秒杀系统的逐步构建  </p>          </div><a id="more"></a><h1 id="秒杀系统"><a href="#秒杀系统" class="headerlink" title="秒杀系统"></a>秒杀系统</h1><p><strong>秒杀系统主要来说就是以下几个步骤：</strong></p><ul><li>用户选定商品下单</li><li>校验库存</li><li>扣库存</li><li>生成订单</li><li>后续步骤….</li></ul><p><strong>对于流量小的系统来说，不需要担心并发引起的问题，但对于高并发的商城系统设计一个完善、高可用的秒杀系统就是必不可少的</strong></p><h1 id="搭建项目环境"><a href="#搭建项目环境" class="headerlink" title="搭建项目环境"></a>搭建项目环境</h1><blockquote><p>本次系统采用SpringBoot来进行搭建</p></blockquote><h2 id="数据库表结构"><a href="#数据库表结构" class="headerlink" title="数据库表结构"></a>数据库表结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**商品库存表**&#x2F;</span><br><span class="line">CREATE TABLE &#96;stock&#96; (</span><br><span class="line">  &#96;id&#96; int(11) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; varchar(50) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;商品名称&#39;,</span><br><span class="line">  &#96;count&#96; int(11) NOT NULL COMMENT &#39;库存&#39;,</span><br><span class="line">  &#96;sale&#96; int(11) NOT NULL COMMENT &#39;已售&#39;,</span><br><span class="line">  &#96;version&#96; int(11) NOT NULL COMMENT &#39;乐观锁，版本号&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">&#x2F;**订单表**&#x2F;</span><br><span class="line">CREATE TABLE &#96;stock_order&#96; (</span><br><span class="line">  &#96;id&#96; int(11) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;sid&#96; int(11) NOT NULL COMMENT &#39;库存ID&#39;,</span><br><span class="line">  &#96;name&#96; varchar(30) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;商品名称&#39;,</span><br><span class="line">  &#96;create_time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><h2 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/createWrongOrder/&#123;sid&#125;"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createWrongOrder</span><span class="params">(@PathVariable <span class="keyword">int</span> sid)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"购买物品编号sid=[&#123;&#125;]"</span>, sid);</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            id = orderService.createWrongOrder(sid);</span><br><span class="line">            log.info(<span class="string">"创建订单id: [&#123;&#125;]"</span>, id);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"Exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">createWrongOrder</span><span class="params">(<span class="keyword">int</span> sid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//校验库存</span></span><br><span class="line">        Stock stock = checkStock(sid);</span><br><span class="line">        <span class="comment">//扣库存</span></span><br><span class="line">        saleStock(stock);</span><br><span class="line">        <span class="comment">//创建订单</span></span><br><span class="line">        <span class="keyword">int</span> id = createOrder(stock);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Stock <span class="title">checkStock</span><span class="params">(<span class="keyword">int</span> sid)</span> </span>&#123;</span><br><span class="line">        Stock stock = stockService.getStockById(sid);</span><br><span class="line">        <span class="keyword">if</span> (stock.getSale() == stock.getCount()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"库存不足"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">saleStock</span><span class="params">(Stock stock)</span> </span>&#123;</span><br><span class="line">        stock.setSale(stock.getSale() + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> stockService.updateStockById(stock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">createOrder</span><span class="params">(Stock stock)</span> </span>&#123;</span><br><span class="line">        StockOrder order = <span class="keyword">new</span> StockOrder();</span><br><span class="line">        order.setSid(stock.getId());</span><br><span class="line">        order.setName(stock.getName());</span><br><span class="line">        <span class="keyword">int</span> id = orderMapper.insertSelective(order);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockServiceImpl</span> <span class="keyword">implements</span> <span class="title">StockService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StockMapper stockMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stock <span class="title">getStockById</span><span class="params">(<span class="keyword">int</span> sid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stockMapper.getStockById(sid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateStockById</span><span class="params">(Stock stock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stockMapper.updateStockById(stock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lyb.miaosha.mapper.OrderMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertSelective"</span> <span class="attr">parameterType</span>=<span class="string">"com.lyb.miaosha.po.StockOrder"</span>&gt;</span></span><br><span class="line">        insert into stock_order (sid,name) values (#&#123;sid&#125;,#&#123;name&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lyb.miaosha.mapper.StockMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStockById"</span> <span class="attr">resultType</span>=<span class="string">"com.lyb.miaosha.po.Stock"</span>&gt;</span></span><br><span class="line">        select * from stock where id=#&#123;sid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateStockById"</span> <span class="attr">parameterType</span>=<span class="string">"com.lyb.miaosha.po.Stock"</span>&gt;</span></span><br><span class="line">        update stock set sale=#&#123;sale&#125; where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="乐观锁防止超卖"><a href="#乐观锁防止超卖" class="headerlink" title="乐观锁防止超卖"></a>乐观锁防止超卖</h1><p>​        秒杀系统一个非常重要的原则就是，商品不能超卖，你只有100件商品就不能卖出去200件商品，否则就将会有人无法如期收到商品。</p><p>​        首先先对之前搭建的系统进行一次压力测试。</p><h2 id="压力测试1"><a href="#压力测试1" class="headerlink" title="压力测试1"></a>压力测试1</h2><ol><li><strong>首先在库存表插入一条商品数据设置成库存100</strong></li></ol><p><img src="https://s1.ax1x.com/2020/04/26/JgwMpn.png" alt="image"></p><ol start="2"><li><strong>用 JMeter进行压力测试，在1s内发送1000次请求</strong></li></ol><p><img src="https://s1.ax1x.com/2020/04/26/Jgwtk4.png" alt="image"></p><ol start="3"><li>查看数据库的情况</li></ol><p>可以发现只库存表只卖出去了16件商品，可是订单表确生成1000张订单</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>​        为了避免超卖问题，我们可以使用乐观锁，给每个商品数据加一个version版本号（乐观锁）。每次查库存的时候同时查出当前版本号，在更新库存的时候将旧的版本号和之前的版本号不同则抢购失败，如果一致则抢购成功。</p><h2 id="代码修改"><a href="#代码修改" class="headerlink" title="代码修改"></a>代码修改</h2><h3 id="Service层-1"><a href="#Service层-1" class="headerlink" title="Service层"></a>Service层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">createWrongOrder</span><span class="params">(<span class="keyword">int</span> sid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//校验库存</span></span><br><span class="line">        Stock stock = checkStock(sid);</span><br><span class="line">        <span class="comment">//配合乐观锁进行库存减扣</span></span><br><span class="line">        saleStockOptimistic(stock);</span><br><span class="line">        <span class="comment">//创建订单</span></span><br><span class="line">        <span class="keyword">int</span> id = createOrder(stock);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过乐观锁修改库存</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saleStockOptimistic</span><span class="params">(Stock stock)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = stockService.updateStockByOptimistic(stock);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"并发更新库存失败，version不匹配"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">............</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockServiceImpl</span> <span class="keyword">implements</span> <span class="title">StockService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StockMapper stockMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateStockByOptimistic</span><span class="params">(Stock stock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stockMapper.updateStockByOptimistic(stock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dao层-1"><a href="#Dao层-1" class="headerlink" title="Dao层"></a>Dao层</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lyb.miaosha.mapper.StockMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateStockByOptimistic"</span> <span class="attr">parameterType</span>=<span class="string">"com.lyb.miaosha.po.Stock"</span>&gt;</span></span><br><span class="line">        update stock</span><br><span class="line">        set sale=#&#123;sale&#125; + 1,</span><br><span class="line">            version=#&#123;version&#125; + 1</span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">          and version = #&#123;version&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    ..............</span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="压力测试2"><a href="#压力测试2" class="headerlink" title="压力测试2"></a>压力测试2</h2><ol><li><strong>重置数据库的数据</strong></li><li><strong>用 JMeter进行压力测试，在1s内发送1000次请求</strong></li><li><strong>查看数据库</strong></li></ol><p><img src="https://s1.ax1x.com/2020/04/26/JgyntU.png" alt="image"></p><p><img src="https://s1.ax1x.com/2020/04/26/Jg6Vvd.png" alt="image"></p><p><strong>可以发现没有超卖情况</strong></p><h1 id="令牌桶限流"><a href="#令牌桶限流" class="headerlink" title="令牌桶限流"></a>令牌桶限流</h1><p>​        <strong>在面对高并发的请求时，特别是下单接口如果不进行限流操作，有导致大量请求打到数据库进而影响后台系统的稳定性。</strong></p><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p><strong>令牌桶算法的原理：</strong></p><p>​        大小固定的令牌桶会以恒定的速率产生令牌，直到桶填满令牌，后面产生的令牌将直接溢出，桶中的令牌数永远不会超过桶的大小。</p><p><img src="https://s1.ax1x.com/2020/04/26/Jg54iR.png" alt="iamge"></p><h2 id="代码修改-1"><a href="#代码修改-1" class="headerlink" title="代码修改"></a>代码修改</h2><blockquote><p>这里使用Guava的RateLimiter实现令牌桶限流，首先先导入依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Controller层-1"><a href="#Controller层-1" class="headerlink" title="Controller层"></a>Controller层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每秒允许放行10个请求</span></span><br><span class="line">    <span class="keyword">private</span> RateLimiter rateLimiter = RateLimiter.create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/createWrongOrder/&#123;sid&#125;"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createWrongOrder</span><span class="params">(@PathVariable <span class="keyword">int</span> sid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//阻塞获取令牌</span></span><br><span class="line">        <span class="comment">//rateLimiter.acquire();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//非阻塞获取令牌</span></span><br><span class="line">        <span class="keyword">if</span> (!rateLimiter.tryAcquire(<span class="number">1000</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">            log.warn(<span class="string">"你被限流了"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"你被限流了"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"购买物品编号sid=[&#123;&#125;]"</span>, sid);</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            id = orderService.createWrongOrder(sid);</span><br><span class="line">            log.info(<span class="string">"创建订单id: [&#123;&#125;]"</span>, id);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"Exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        代码中<code>RateLimiter rateLimiter = RateLimiter.create(10)</code>对令牌桶进行了初始化，并限制每秒中限制10个请求的发送</p><p><strong>两种获取令牌的方法</strong></p><ul><li><p>acquire</p><p>阻塞地获取令牌：请求进来，如果桶中没有令牌，请求会阻塞到获取到令牌为止</p></li><li><p>tryAcquire</p><p>非阻塞地获取令牌：请求进来，如果桶中没有令牌，则会判断在设置的时间（1000ms）之后能否获取令牌，如果不能则被限流。</p></li></ul><h2 id="压力测试1-1"><a href="#压力测试1-1" class="headerlink" title="压力测试1"></a>压力测试1</h2><p><strong>发送200个请求，并将限流结果单独断言出来</strong></p><p><img src="F:%5Cpicture%5Cblog_picture%5C%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%5CJ2HnFe.png" alt="image"></p><p><img src="https://s1.ax1x.com/2020/04/26/J2qkVK.png" alt="image"></p><p><strong>ps:绿色的响应代表请求被限流</strong></p><p>​        从测试结果可以看出有大量的请求被限流了，在没有被限流的请求中也有一部分因为乐观锁扣库存失败。</p><h2 id="压力测试2-1"><a href="#压力测试2-1" class="headerlink" title="压力测试2"></a>压力测试2</h2><p><strong>如果将非阻塞获取请求改成阻塞地获取请求，再进行一次测试</strong></p><p>​        结果会发现，刚进来的10个请求直接通过（获得令牌）结果就是出现乐观锁扣库存失败。而之后的每个请求都很均匀地通过，没有出现乐观锁更新失败的结果。</p><p>​        从这里就可以看出令牌桶算法的特点：</p><ul><li>可以限制数据的平均发送速率</li><li>也可以应当突发数据的情况（只要桶中存在足够的令牌）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;
            &lt;p&gt;秒杀系统的逐步构建  &lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="并发" scheme="http://liuyoubin.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自动配置原理</title>
    <link href="http://liuyoubin.top/2020/04/08/backEnd/framework/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
    <id>http://liuyoubin.top/2020/04/08/backEnd/framework/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</id>
    <published>2020-04-08T03:43:28.000Z</published>
    <updated>2020-04-08T07:36:58.479Z</updated>
    
    <content type="html"><![CDATA[<div class="note info">            <p>通过源码了解SpringBoot的自动配置原理 </p>          </div><a id="more"></a><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><p>​        SpringBoot是一个优秀的快速搭建框架的手脚架，使用了特定的方式来进行配置，免去了开发者传统的繁杂配置搭建，从而使开发人员不再需要定义样板化的配置。</p><h1 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h1><p>​        首先我们知道SpringBoot应用的主启动类上有一个<strong>@SpringBootApplication</strong>注解，我们点击这个注解进去看看。</p><p><img src="https://s1.ax1x.com/2020/04/08/GWGQNF.png" alt="image"></p><p>​        发现@SpringBootApplication中有一个<strong>@EnableAutoConfiguration</strong>注解，通过名字可以知道是用来进行自动配置，继续跟进这个注解。</p><p><img src="https://s1.ax1x.com/2020/04/08/GWGWE8.png" alt="image"></p><p>​        发现<strong>@EnableAutoConfiguration</strong>也是一个复合注解，主要的作用是导入<strong>AutoConfigurationImportSelector</strong>类，这个类主要是给Spring导入一些组件。跟进这个类会发现这个类有一个<strong>selectImports(AnnotationMetadata annotationMetadata)</strong>方法。一步步跟进之后会发现最后会调用<strong>SpringFactoriesLoader.loadFactoryNames()</strong>扫描所有jar包类路径下”META-INF/spring.factories”。</p><p><img src="https://s1.ax1x.com/2020/04/08/GWth4O.png" alt="image"></p><p>​        </p><p>​        而spring-boot-autoconfigure-x.x.x.x.jar里就有一个这样的spring.factories文件。这样SpringBoot就可以找到所有自动配置类的位置，将自动配置类加载进Spring容器。</p><p><img src="https://s1.ax1x.com/2020/04/08/GWNbz4.png" alt="image"></p><p>​        </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​        <strong>也就是说：SpringBoot通过@SpringBootApplication中的@EnableAutoConfiguration注解定位到AutoConfigurationImportSelector类，在SpringBoot主启动类启动时SpringApplication.run()就会执行selectImports()方法找到所有的自动配置类将组件加载到Spring容器中。每一个自动配置类根据配置生效的条件@ConditionalXXX有选择的进行加载配置。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;
            &lt;p&gt;通过源码了解SpringBoot的自动配置原理 &lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="框架" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="SpringBoot" scheme="http://liuyoubin.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>MyCat入门</title>
    <link href="http://liuyoubin.top/2020/03/14/backEnd/dataBase/MyCat%E5%85%A5%E9%97%A8/"/>
    <id>http://liuyoubin.top/2020/03/14/backEnd/dataBase/MyCat%E5%85%A5%E9%97%A8/</id>
    <published>2020-03-14T08:35:28.000Z</published>
    <updated>2020-03-24T09:48:59.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>​        MyCat 是一个开源的分布式数据库系统，但是由于真正的数据库需要存储引擎，而 Mycat 并没有存 储引擎，所以并不是完全意义的分布式数据库系统<br> ​        MyCat是一个数据库中间件，也可以理解为是数据库代理。在架构体系中是位于数据库和应用层之间的一个组件，并且对于应用层是透明的，即数据库 感受不到mycat的存在，认为是直接连接的mysql数据库（实际上是连接的mycat,mycat实现了mysql的原生协议）</p></blockquote><p><strong>MyCat的核心功能：读写分离、分库分表</strong></p><a id="more"></a><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>​        MyCat的原理就是<strong>“拦截”</strong>，它拦截了用户发送的SQL语句，首先对SQL语句做一些特定的分析：如<strong>分片分析、路由分析、读写分离分析、缓存分析</strong>，然后将数据库发往后端的真实数据库，并将返回结果做适当的处理，最终返回给用户。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li><p>到官网 <a href="http://www.mycat.io/" target="_blank" rel="noopener">http://www.mycat.io/</a> 下载合适的安装包</p></li><li><p>解压安装包，并把解压后文件拷贝到/usr/local下</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz</span><br><span class="line">mv mycat /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>三个重要的配置文件</p><ol><li><p>schema.xml 定义了逻辑库、逻辑表、分片节点等内容</p><p><img src="https://s1.ax1x.com/2020/03/14/8l2xC6.png" alt="imgae"></p></li><li><p>rule.xml 定义了分片规则</p></li><li><p>server.xml 定义用户以及系统相关变量，如端口</p><p><img src="https://s1.ax1x.com/2020/03/14/8lcQbR.png" alt="image"></p></li></ol></li></ol><h1 id="启动与登陆"><a href="#启动与登陆" class="headerlink" title="启动与登陆"></a>启动与登陆</h1><ol><li><p>在启动前确保远程数据库可以正常访问</p></li><li><p>启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mycat/bin</span><br><span class="line"></span><br><span class="line"><span class="comment">#控制台启动</span></span><br><span class="line">./mycat console</span><br><span class="line"></span><br><span class="line"><span class="comment">#后台启动</span></span><br><span class="line">./mycat start</span><br></pre></td></tr></table></figure></li><li><p>登陆</p><ol><li><p>登陆后台管理窗口（用于运维）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -umycat -p123456 -P9066 -h ip地址</span><br></pre></td></tr></table></figure></li><li><p>登陆数据窗口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -umycat -p123456 -P8066 -h ip地址</span><br></pre></td></tr></table></figure></li></ol></li></ol><h1 id="搭建读写分离"><a href="#搭建读写分离" class="headerlink" title="搭建读写分离"></a>搭建读写分离</h1><p>​        <strong>我们通过Mycat的读写分离配置MySQL的主从复制，实现MySQL的高可用性。</strong></p><h2 id="读写分离架构"><a href="#读写分离架构" class="headerlink" title="读写分离架构"></a>读写分离架构</h2><p><img src="https://s1.ax1x.com/2020/03/14/8l5sg0.png" alt="image"></p><h2 id="MySQL主从复制原理图"><a href="#MySQL主从复制原理图" class="headerlink" title="MySQL主从复制原理图"></a>MySQL主从复制原理图</h2><p><img src="https://s1.ax1x.com/2020/03/15/81pHf0.png" alt="image"></p><h2 id="单主单从模式"><a href="#单主单从模式" class="headerlink" title="单主单从模式"></a>单主单从模式</h2><h3 id="搭建主从复制"><a href="#搭建主从复制" class="headerlink" title="搭建主从复制"></a>搭建主从复制</h3><ol><li>修改配置文件</li></ol><ul><li>修改主服务器配置文件（/etc/my.cnf）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#主服务器唯一ID</span><br><span class="line">server-id&#x3D;1</span><br><span class="line">#启用二进制文件</span><br><span class="line">log-bin&#x3D;mysql-bin</span><br><span class="line">#设置不用复制的数据库(可设置多个)</span><br><span class="line">binlog-ignore-db&#x3D;mysql</span><br><span class="line">#设置需要复制的数据库(可设置多个)</span><br><span class="line">binlog-do-db&#x3D;</span><br><span class="line">#设置logbin格式</span><br><span class="line">binlog_format&#x3D;STATEMENT</span><br></pre></td></tr></table></figure><ul><li>修改从服务器配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#从服务器唯一ID</span><br><span class="line">server-id&#x3D;2</span><br><span class="line">#启用中继日志</span><br><span class="line">relay-log&#x3D;mysql-relay</span><br></pre></td></tr></table></figure><ol start="2"><li><p>重启两台机器的mysql服务</p></li><li><p>在主机上授权slave权限给远程主机 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#39;slave&#39;@&#39;%&#39; IDENTIFIED BY &#39;密码&#39;</span><br></pre></td></tr></table></figure></li><li><p>查询主机的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/03/15/88DXKH.png" alt="image"></p></li><li><p>在从机上配置需要复制的主机信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">#停止复制功能、重置主从语句，如果已经启动复制功能的话</span></span><br><span class="line">  stop slave;</span><br><span class="line">  reset master;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#在从机执行以下命令</span></span><br><span class="line">  CHANGE MASTER TO MASTER_HOST=<span class="string">'主机的ip地址'</span>,</span><br><span class="line">  MASTER_USER=<span class="string">'salve'</span>,</span><br><span class="line">  MASTER_PASSWORD=<span class="string">'密码'</span>,</span><br><span class="line">  MASTER_LOG_FILE=<span class="string">'mysql-bin.具体数字'</span>,</span><br><span class="line">  MASTER_LOG_POS=<span class="string">'接入点'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#启动从服务器的复制功能</span></span><br><span class="line">  start slave;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#查看从服务器的状态</span></span><br><span class="line">  show slave status\G;</span><br><span class="line">  <span class="comment">#出现以下两个参数都是yes，代表主从配置成功</span></span><br><span class="line">Slave_IO_Running:Yes</span><br><span class="line">  Slave_SQL_Running:Yes</span><br></pre></td></tr></table></figure></li></ol><h3 id="搭建读写分离-1"><a href="#搭建读写分离-1" class="headerlink" title="搭建读写分离"></a>搭建读写分离</h3><ol><li><p>修改MyCat的配置文件server.xml</p><p><img src="https://s1.ax1x.com/2020/03/14/8lcQbR.png" alt="image"></p></li><li><p>修改MyCat的配置文件schema.xml</p><p><img src="https://s1.ax1x.com/2020/03/14/8l2xC6.png" alt="imgae"></p></li><li><p>设置读写分离的类型，在<dataHost>的balance属性进行设置</p><table><thead><tr><th align="center">balance值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">不开启读写分离机制，所有读操作都发送到当前可用的writeHost上</td></tr><tr><td align="center">1</td><td align="center">全部的readHost和stand by writeHost参与select语句的负载均衡。也就是说在双主双从模式下(M1-&gt;S1,M2-&gt;S2并且M1、M2互为主备)，正常情况下M2、S1、S2都参加select语句的负载。</td></tr><tr><td align="center">2</td><td align="center">所有的读请求都随机在writeHost和readHost上分发</td></tr><tr><td align="center">3</td><td align="center">所有的读请求随机在readHost上执行，writteHost不承担读压力</td></tr></tbody></table><p>PS：在多主多从模式下也只能有一个写主机负载写操作</p><p><strong>推荐在双主双从模式下设置成1，在单主单从模式下设置成3</strong></p></li><li><p>开启MyCat</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/usr/local/mycat/bin</span></span><br><span class="line"></span><br><span class="line"><span class="string">./mycat</span> console</span><br></pre></td></tr></table></figure></li><li><p>验证读写分离</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">1</span>. 在主机插入<span class="selector-tag">insert</span> <span class="selector-tag">into</span> <span class="selector-tag">user</span> <span class="selector-tag">values</span>(<span class="number">1</span>,<span class="variable">@@hostname</span>);  <span class="comment">//主从机器的数据不一样了</span></span><br><span class="line"><span class="selector-tag">2</span>. 在<span class="selector-tag">mycat</span>进行查询 <span class="selector-tag">select</span> * <span class="selector-tag">from</span> <span class="selector-tag">user</span>; <span class="comment">//可以判断读写分离是否成功</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="双主双从模式"><a href="#双主双从模式" class="headerlink" title="双主双从模式"></a>双主双从模式</h2><p>​        相较于单主但从的读写分离模式，双主双从模式的可用性更高。一个主机m1负责处理所有的写请求，它的从机s1和另一台主机m2和从机s2负责所有的读请求。当m1宕机后，m2负责写请求，m1、m2互为备机。</p><p><img src="https://s1.ax1x.com/2020/03/18/8DP23q.png" alt="image"></p><h3 id="搭建主从复制-1"><a href="#搭建主从复制-1" class="headerlink" title="搭建主从复制"></a>搭建主从复制</h3><ol><li><p>双主机配置</p><ol><li>Master1配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#主服务器唯一ID</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="comment">#启用二进制文件</span></span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br><span class="line"><span class="comment">#设置不用复制的数据库(可设置多个)</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line"><span class="comment">#设置需要复制的数据库(可设置多个)</span></span><br><span class="line">binlog-do-db=</span><br><span class="line"><span class="comment">#设置logbin格式</span></span><br><span class="line">binlog_format=STATEMENT</span><br><span class="line"><span class="comment">#在作为从数据库的时候，有写入操作也要更新二进制文件</span></span><br><span class="line"><span class="built_in">log</span>-slave-updates</span><br><span class="line"><span class="comment">#表示自增长字段每次递增的量，默认值是1取值范围是1~65535</span></span><br><span class="line">auto-increment-increment=2</span><br><span class="line"><span class="comment">#表示自增长字段从哪个数开始,取值范围是1~65535</span></span><br><span class="line">auto-increment-offset=1</span><br></pre></td></tr></table></figure><ol start="2"><li><p>Master2配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#主服务器唯一ID</span></span><br><span class="line">server-id=3</span><br><span class="line"><span class="comment">#启用二进制文件</span></span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br><span class="line"><span class="comment">#设置不用复制的数据库(可设置多个)</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line"><span class="comment">#设置需要复制的数据库(可设置多个)</span></span><br><span class="line">binlog-do-db=</span><br><span class="line"><span class="comment">#设置logbin格式</span></span><br><span class="line">binlog_format=STATEMENT</span><br><span class="line"><span class="comment">#在作为从数据库的时候，有写入操作也要更新二进制文件</span></span><br><span class="line"><span class="built_in">log</span>-slave-updates</span><br><span class="line"><span class="comment">#表示自增长字段每次递增的量，默认值是1取值范围是1~65535</span></span><br><span class="line">auto-increment-increment=2</span><br><span class="line"><span class="comment">#表示自增长字段从哪个数开始,取值范围是1~65535</span></span><br><span class="line">auto-increment-offset=2</span><br></pre></td></tr></table></figure></li></ol></li></ol><ol start="2"><li><p>双从机配置</p><ol><li><p>slave1配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从服务器唯一ID</span></span><br><span class="line">server-id=2</span><br><span class="line"><span class="comment">#启用中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure></li><li><p>slave2配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从服务器唯一ID</span></span><br><span class="line">server-id=4</span><br><span class="line"><span class="comment">#启用中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure></li></ol></li></ol><ol start="3"><li><p>双主机授权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#39;slave&#39;@&#39;%&#39; IDENTIFIED BY &#39;密码&#39;</span><br></pre></td></tr></table></figure></li><li><p>查询双主机的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure></li><li><p>在双从机上配置需要复制的主机信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#停止复制功能、重置主从语句，如果已经启动复制功能的话</span><br><span class="line">stop slave;</span><br><span class="line">reset master;</span><br><span class="line"></span><br><span class="line">#在从机执行以下命令</span><br><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;主机的ip地址&#39;,</span><br><span class="line">MASTER_USER&#x3D;&#39;salve&#39;,</span><br><span class="line">MASTER_PASSWORD&#x3D;&#39;密码&#39;,</span><br><span class="line">MASTER_LOG_FILE&#x3D;&#39;mysql-bin.具体数字&#39;,</span><br><span class="line">MASTER_LOG_POS&#x3D;&#39;接入点&#39;;</span><br><span class="line"></span><br><span class="line">#启动从服务器的复制功能</span><br><span class="line">start slave;</span><br><span class="line"></span><br><span class="line">#查看从服务器的状态</span><br><span class="line">show slave status\G;</span><br><span class="line">#出现以下两个参数都是yes，代表主从配置成功</span><br><span class="line">Slave_IO_Running:Yes</span><br><span class="line">Slave_SQL_Running:Yes</span><br></pre></td></tr></table></figure></li><li><p>两个主机相互复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#在两台主机下执行以下命令</span><br><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;另一台主机的ip地址&#39;,</span><br><span class="line">MASTER_USER&#x3D;&#39;salve&#39;,</span><br><span class="line">MASTER_PASSWORD&#x3D;&#39;密码&#39;,</span><br><span class="line">MASTER_LOG_FILE&#x3D;&#39;mysql-bin.具体数字&#39;,</span><br><span class="line">MASTER_LOG_POS&#x3D;&#39;接入点&#39;;</span><br><span class="line"></span><br><span class="line">#启动从服务器的复制功能</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>​                                                                                                                        </p></li></ol><h3 id="搭建读写分离-2"><a href="#搭建读写分离-2" class="headerlink" title="搭建读写分离"></a>搭建读写分离</h3><ol><li><p>修改MyCat的配置文件schema.xml</p><p><img src="https://s1.ax1x.com/2020/03/19/8yzQMV.png" alt="image"></p></li></ol><ul><li>配置项说明<ul><li>balance=1 两台读主机和写主机的备机负责读操作</li><li>writeType=0  所有写操作发布到第一个writeHost，第一个挂了还能切换到第二个</li><li>switchType=1<ul><li>1   默认值，自动切换</li><li>-1  不自动切换</li><li>2  基于MySql的主从同步状态决定是否切换</li></ul></li></ul></li></ul><ol start="2"><li><p>启动MyCat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mycat/bin</span><br><span class="line"></span><br><span class="line"><span class="comment">#控制台启动</span></span><br><span class="line">./mycat console</span><br></pre></td></tr></table></figure></li><li><p>验证读写分离 </p></li></ol><h1 id="垂直划分"><a href="#垂直划分" class="headerlink" title="垂直划分"></a>垂直划分</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​        一个数据库有很多张表，每张表分别处理不同的业务。垂直划分就是根据业务的耦合性将关联度低的表存在不同的数据库上。</p><p>​        垂直划分可以分为<strong>垂直分表</strong>和 <strong>垂直分库</strong>。垂直分库是指按照业务将表进行分类，分布到不同的数据库上面。垂直分表是基于数据库中的”列”进行，某个表字段较多，可以新建一张扩展表，将不经常用或字段长度较大的字段拆分出去到扩展表中。</p><p><img src="https://s1.ax1x.com/2020/03/21/8h0MZT.png" alt="image"></p><p><strong>垂直划分的优点</strong></p><ul><li>解决业务系统层面的耦合，业务清晰</li><li>与微服务的治理类似，也能对不同业务的数据进行分级管理、维护、监控、扩展等</li><li>高并发场景下，垂直切分一定程度的提升IO、数据库连接数、单机硬件资源的瓶颈</li></ul><p><strong>垂直划分的缺点</strong></p><ul><li>部分表无法join，只能通过接口聚合方式解决，提升了开发的复杂度</li><li>分布式事务处理复杂</li><li>依然存在单表数据量过大的问题（需要水平化分）</li></ul><h2 id="搭建垂直分库"><a href="#搭建垂直分库" class="headerlink" title="搭建垂直分库"></a>搭建垂直分库</h2><p>​        <strong>需求：</strong>现在有客户表、订单表、订单详情表、数据字典表。考虑到表的数据量过大，现在准备进行垂直分库操作。按照业务的划分，决定将客户表单独划分到一个数据库，其他三张表存到一个数据库。</p><p>​        <strong>PS：</strong>垂直分库的数据库可以放在同一个主机实例上，也可以放在不同的主机实例上，具体通过配置文件进行配置。</p><ol><li>修改schema.xml 配置文件</li></ol><p><img src="https://s1.ax1x.com/2020/03/20/8gzggA.png" alt="image"></p><ol start="2"><li><p>启动MyCat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mycat/bin</span><br><span class="line">./mycat console</span><br></pre></td></tr></table></figure><p>​        垂直分库完成后，程序连接MyCat只能看到TESTDB这个逻辑库，逻辑库中有客户表、订单表、订单详情表、数据字典表四张表。这四张表分别在两个数据库中，但是程序可以无感知地操作TESTDB一个数据库来操作四张表。</p><p>​                                                                                                                                        </p></li></ol><h1 id="水平划分"><a href="#水平划分" class="headerlink" title="水平划分"></a>水平划分</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>​        MySql单表存储数据数量是有瓶颈的，单表达到1000万条数据就达到了瓶颈，会影响查询效率，这时可以进行水平划分进行优化。</p><p>​        水平划分又分为<strong>水平分库</strong>和<strong>水平分表</strong>。水平分表（库内分表）只解决单表数据过大的问题，对于数据库压力的缓解帮助不是很大，最好还是采用水平分库，将表分布到不同数据库中。</p><p><img src="https://s1.ax1x.com/2020/03/21/8hw1gI.png" alt="image"></p><p><strong>水平划分的优点</strong></p><ul><li>解决单库数据量过大、高并发的性能瓶颈，提升系统稳定性和负载能力</li><li>应用端改造较小，不需要拆分业务模块</li></ul><p><strong>水平划分的缺点</strong></p><ul><li>对于分片事务难以保证一致性</li><li>跨库join连接查询性能差</li></ul><h2 id="搭建水平分库"><a href="#搭建水平分库" class="headerlink" title="搭建水平分库"></a>搭建水平分库</h2><p><strong>需求</strong>：现在数据库有一张订单表数据量已经达到了600万数据，现在准备进行水平分库优化。经过考虑后准备根据客户id进行划分，使得同一个客户的订单在同一张表上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;表结构如下</span><br><span class="line">CREATE TABLE orders(</span><br><span class="line">id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    order_type INT,</span><br><span class="line">    customer_id INT,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li><p>修改schema.xml文件</p><p><code>将orders表通过mod_rule规则划分到dn1、dn2两个分片上</code></p><p><img src="https://s1.ax1x.com/2020/03/22/84e8US.png" alt="image"></p></li><li><p>修改rule.xml文件修改分片规则</p><p><img src="https://s1.ax1x.com/2020/03/22/84XCSe.png" alt="image"></p></li></ol><ul><li><p>分片算法mod-log</p><p>对指定字段进行节点取模运算，根据结果进行分片</p></li></ul><p><img src="https://s1.ax1x.com/2020/03/22/84jd4f.png" alt="image"></p><ol start="3"><li>启动MyCat</li></ol><h2 id="MyCat分片的“Join”"><a href="#MyCat分片的“Join”" class="headerlink" title="MyCat分片的“Join”"></a>MyCat分片的“Join”</h2><p>​        Orders订单表现在已经被分到dn1、dn2两个分片上，那么和它关联的订单详情表order_detail如何进行关联呢?。答案是同时要对订单详情表进行分片操作,可以采用基于E-R表的分片策略进行解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;订单详情表</span><br><span class="line">CREATE TABLE orders_detail(</span><br><span class="line">id INT AUTO_INCREMENT,</span><br><span class="line">    detail VARCHAR(2000),</span><br><span class="line">    order_id INT,</span><br><span class="line">    PRIMARY KEY(id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>​        除了订单详情表还有一张字典表dict_order_type，不管是订单表还是订单详情表都需要数据字典表的数据，可以说这是一张全局表，那全局表应该怎么解决。考虑到字典表有几个特征：</p><ul><li><p>变动不频繁</p></li><li><p>数据量不大</p><p>鉴于此，MyCat定义了“全局表”来进行解决。</p></li></ul><p><img src="https://s1.ax1x.com/2020/03/22/8592VJ.png" alt="image"></p><h3 id="ER表"><a href="#ER表" class="headerlink" title="ER表"></a>ER表</h3><p>​        <strong>MyCat提出了基于E-R关系的数据分片策略，子表的记录与关联的父表记录存储在同一个数据分片上，彻底解决JOIN的的效率和性能问题。</strong></p><p><img src="https://s1.ax1x.com/2020/03/22/857VUS.png" alt="image"></p><p>​                                                                                                                                    </p><h3 id="全局表"><a href="#全局表" class="headerlink" title="全局表"></a>全局表</h3><p>​        <strong>全局表具有以下特征</strong></p><ul><li>全局表的插入、更新会在所有节点上执行，保证分片数据的一致性</li><li>全局表的查询操作只能在一个节点获取</li><li>全局表可以和任何一个表进行Join操作</li></ul><p><img src="https://s1.ax1x.com/2020/03/22/8IEYgs.png" alt="image"></p><h2 id="常用的分片操作"><a href="#常用的分片操作" class="headerlink" title="常用的分片操作"></a>常用的分片操作</h2><h3 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h3><p>​        对分片的指定字段求模运算，对结果进行分片，是一种常用的分片规则。具体参考上面搭建水平分库的过程。</p><h3 id="分片枚举"><a href="#分片枚举" class="headerlink" title="分片枚举"></a>分片枚举</h3><p>​        通过在配置文件中配置可能的枚举id，自己配置分片，本规则适用于特定场景。比如有些业务需要按照省份或区县进行保存，此类业务使用于本条规则。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#修改schema.xml文件</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"order_info"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"store_by_intfile"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#修改rule.xml文件</span><br><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"store_by_intfile"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">columns</span>&gt;</span>areacode<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>hash-int<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"hash-int"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByFileMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>partition-hash-int.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"type"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultNode"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>columns : 分片字段</li><li>alogrithm：分片函数</li><li>mapFile：标识配置文件名称</li><li>type：0为int型，非0为String型（这里的类型指的是分片字段的类型）</li><li>defaultNode：默认节点，小于0表示不设置默认节点，大于等于0表示设置默认节点。设置默认节点如果碰到不能识别的枚举值，就路由到默认节点。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#修改partition-hash-int.txt文件</span><br><span class="line">110=0 //areacode为110路由到0分片</span><br><span class="line">120=1 //areacode为120路由到1分片</span><br></pre></td></tr></table></figure><h3 id="范围约定"><a href="#范围约定" class="headerlink" title="范围约定"></a>范围约定</h3><p>​        此分片适用于提前规划好分片字段属于哪个分片。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#修改schema.xml文件</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"pay_info"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"auto_sharding_long"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#修改rule.xml文件</span><br><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"auto_sharding_long"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">columns</span>&gt;</span>order_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>rang-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"rang-long"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">"io.mycat.route.function.AutoPartitionByLong"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>autopartition-long.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultNode"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>columns : 分片字段</li><li>alogrithm：分片函数</li><li>mapFile：标识配置文件名称</li><li>defaultNode：默认节点，小于0表示不设置默认节点，大于等于0表示设置默认节点。设置默认节点如果碰到不能识别的枚举值，就路由到默认节点。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#修改autopartition-long.txt文件</span><br><span class="line">0-200=0 //order_id在0~200路由到0分片</span><br><span class="line">201-400=1 //order_id在201~400路由到1分片</span><br></pre></td></tr></table></figure><h3 id="日期划分"><a href="#日期划分" class="headerlink" title="日期划分"></a>日期划分</h3><p>​        此规则为按天分片，设定时间格式、范围。</p><p>例如：按照登陆日期分片存放数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#修改schema.xml文件</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"login_info"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"sharding_by_date"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#修改rule.xml文件</span><br><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding_by_date"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">columns</span>&gt;</span>login_date<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>shardingByDate<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"shardingByDate"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByDate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateFormat"</span>&gt;</span>yyyy-MM-dd<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sBeginDate"</span>&gt;</span>2020-01-01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sEndDate"</span>&gt;</span>2020-01-04<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sPartionDate"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>columns : 分片字段</li><li>alogrithm：分片函数</li><li>dateFormat：日期格式</li><li>sBeginDate：开始日期</li><li>sEndDate：结束日期，数据达到这个日期的分片后开始循环分片插入</li><li>sPartionDate：分区天数，即默认从开始日期算起，分隔2天一个分区</li></ul><h1 id="全局序列"><a href="#全局序列" class="headerlink" title="全局序列"></a>全局序列</h1><p>​        <strong>在实现分库分表的情况下，数据库自增主键已无法保证自增主键的唯一性，为此MyCat提供了全局序列(sequence),并且包含本地配置和数据库配置等多种实现。</strong></p><h2 id="本地文件"><a href="#本地文件" class="headerlink" title="本地文件"></a>本地文件</h2><p>​        此方法MyCat将sequence配置到文件中，当使用到sequence中的配置后，Mycat会更新classpath中的sequence_conf.properties文件中sequence当前值。<strong>(不推荐)</strong></p><p>优点：本地加载，读取速度快</p><p>缺点：抗风险能力差，MyCat主机宕机后，无法读取本地文件</p><h2 id="时间戳方式"><a href="#时间戳方式" class="headerlink" title="时间戳方式"></a>时间戳方式</h2><p>​        全局序列 ID=64位二进制（42毫秒+5位机器码+5位业务编码+12位重复累加）换算成18位十进制long类型，每毫秒可以并发12位二进制累加。<strong>(不推荐)</strong></p><p>优点：配置简单</p><p>缺点：18位ID过长</p><h2 id="数据库方式"><a href="#数据库方式" class="headerlink" title="数据库方式"></a>数据库方式</h2><p>​        利用数据库一张表（存放 sequence 名称(name)，sequence 当前值(current_value)，步长(increment int 类型每次读取多少个 sequence，假设为 K)等信息）来进行计数累加，MyCat会预加载一部分号段到Mycat内存中，如果内存中的序列号用完或者MyCat宕机重启再向数据库要一次。<strong>（推荐）</strong></p><p><strong>原理步骤：</strong></p><p>​        当初次使用该 sequence 时，根据传入的 sequence 名称，从数据库这张表中读取 current_value，和 increment 到 MyCat 中，并将数据库中的 current_value 设置为原 current_value 值+increment 值； .</p><p>​        MyCat 将读取到 current_value+increment 作为本次要使用的 sequence 值，下次使用时，自动加 1，当 使用 increment 次后，执行步骤 1)相同的操作. MyCat 负责维护这张表，用到哪些 sequence，只需要在这张表中插入一条记录即可。若某次读取的 sequence 没有用完，系统就停掉了，则这次读取的 sequence 剩余值不会再使用。</p><ol><li><p>修改server.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//全局序列类型 0-本地文件 1-数据库方式 2-时间戳方式</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sequnceHandlerType"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改Mycat 配置文件 sequence_db_conf.properties</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GLOBAL=dn1</span><br><span class="line">COMPANY=dn1</span><br><span class="line">CUSTOMER=dn1</span><br><span class="line">ORDERS=dn1 //ORDERS这张表的序列在dn1上</span><br></pre></td></tr></table></figure></li><li><p>建立序列脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#在dn1上创建全局序列表</span><br><span class="line">CREATE TABLE mycat_source(</span><br><span class="line">    name VARCHAR(50) NOT NULL,</span><br><span class="line">current_value INT NOT NULL,</span><br><span class="line">increment INT NOT NULL DEFALUT 100,</span><br><span class="line">PRIMARY KEY(name)</span><br><span class="line">)ENGINE&#x3D;INNODB;</span><br><span class="line"></span><br><span class="line">#获取当前sequence值的存储过程</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE FUNCTION mycat_seq_currval(seq_name VARCHAR(50)) RETURNS varchar(64)     CHARSET utf8</span><br><span class="line">DETERMINISTIC</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE retval VARCHAR(64);</span><br><span class="line">SET retval&#x3D;&quot;-999999999,null&quot;;</span><br><span class="line">SELECT concat(CAST(current_value AS CHAR),&quot;,&quot;,CAST(increment AS CHAR)) INTO retval FROM MYCAT_SEQUENCE WHERE name &#x3D; seq_name;</span><br><span class="line">RETURN retval;</span><br><span class="line">END $</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#设置sequence值的存储过程</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE FUNCTION mycat_seq_setval(seq_name VARCHAR(50),value INTEGER) RETURNS     varchar(64) CHARSET utf8</span><br><span class="line">DETERMINISTIC</span><br><span class="line">BEGIN</span><br><span class="line">UPDATE MYCAT_SEQUENCE</span><br><span class="line">SET current_value &#x3D; value</span><br><span class="line">WHERE name &#x3D; seq_name;</span><br><span class="line">RETURN mycat_seq_currval(seq_name);</span><br><span class="line">END $</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#获取下一个sequence值的存储过程</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE FUNCTION mycat_seq_nextval(seq_name VARCHAR(50)) RETURNS varchar(64)     CHARSET utf8</span><br><span class="line">DETERMINISTIC</span><br><span class="line">BEGIN</span><br><span class="line">UPDATE MYCAT_SEQUENCE</span><br><span class="line">SET current_value &#x3D; current_value + increment WHERE name &#x3D; seq_name;</span><br><span class="line">RETURN mycat_seq_currval(seq_name);</span><br><span class="line">END $</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><ol start="4"><li>插入orders表的sequence信息</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO mycat_source VALUES(&#39;ORDERS&#39;,10000,100);</span><br></pre></td></tr></table></figure></li></ol><h2 id="自主生成"><a href="#自主生成" class="headerlink" title="自主生成"></a>自主生成</h2><p>   ​        直接在项目里根据业务逻辑生成全局序列</p><h1 id="MyCat安全设置"><a href="#MyCat安全设置" class="headerlink" title="MyCat安全设置"></a>MyCat安全设置</h1><h2 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a>权限配置</h2><ol><li><p><strong>user标签权限控制</strong></p><p>​        目签MyCat对于中间件的连接控制只做了中间件逻辑库级别的读写权限控制，通过server.xml的user标签进行配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"mycat"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>user<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"readOnly"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">标签属性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">name</td><td align="center">应用连接MyCat逻辑库的用户名</td></tr><tr><td align="center">password</td><td align="center">用户对应的密码</td></tr><tr><td align="center">TESTDB</td><td align="center">应用当前连接逻辑库，schemas可以配置多个</td></tr><tr><td align="center">readOnly</td><td align="center">应用连接中间件逻辑库所具有的权限，默认为false代表读写，true代表只读</td></tr></tbody></table><ol start="2"><li><p><strong>privileges标签权限控制</strong></p><p>​        在user标签下的privileges标签可以对逻辑库(schema)、表(table)进行精细化的DML权限控制。</p><p>​        privileges标签下的check属性，如ture为开启权限检查，默认为false。</p><p>​        MyCat一个用户的schemas属性可以配置多个逻辑库(schema),所以privileges的下级节点schema节点可以配置多个，对多库多表进行DML细粒度控制。</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"mycat"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 表级 DML 权限设置 --&gt;</span>           </span><br><span class="line">                <span class="tag">&lt;<span class="name">privileges</span> <span class="attr">check</span>=<span class="string">"ture"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"TESTDB"</span> <span class="attr">dml</span>=<span class="string">"0110"</span> &gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"tb01"</span> <span class="attr">dml</span>=<span class="string">"0000"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"tb02"</span> <span class="attr">dml</span>=<span class="string">"1111"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">privileges</span>&gt;</span>                            </span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        <strong>dml的四位数字代表DML四个权限 。从左到右为insert、update、select、delete，1代表开启，0代表禁止</strong></p></li></ol><h2 id="SQL拦截"><a href="#SQL拦截" class="headerlink" title="SQL拦截"></a>SQL拦截</h2><p>​                <strong>MyCat使用server.xml的firewall标签来定义防火墙。firewall下的whitehost标签来定义IP白名单，blacklist定义SQL黑名单。</strong></p><ol><li><p>白名单</p><p>​    可以通过设置白名单实现某主机某用户可以访问MyCat，其他主机用户禁止访问。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//在sever.xml添加firewall标签</span><br><span class="line"><span class="tag">&lt;<span class="name">firewall</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">whitehost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">host</span> <span class="attr">host</span>=<span class="string">"192.168.140.120"</span> <span class="attr">user</span>=<span class="string">"mycat"</span>&gt;</span><span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">whitehost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">firewall</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>黑名单</p><p>​    可以通过黑名单，实现MyCat对具体SQL操作的拦截，如增删改查等操作的拦截。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//在sever.xml添加firewall标签</span><br><span class="line"><span class="tag">&lt;<span class="name">firewall</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">whitehost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">host</span> <span class="attr">host</span>=<span class="string">"192.168.140.120"</span> <span class="attr">user</span>=<span class="string">"mycat"</span>&gt;</span><span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">whitehost</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--禁止mycat用户的删除操作--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">blacklist</span> <span class="attr">check</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"deleteAllow"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">blacklist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">firewall</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        </p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;​        MyCat 是一个开源的分布式数据库系统，但是由于真正的数据库需要存储引擎，而 Mycat 并没有存 储引擎，所以并不是完全意义的分布式数据库系统&lt;br&gt; ​        MyCat是一个数据库中间件，也可以理解为是数据库代理。在架构体系中是位于数据库和应用层之间的一个组件，并且对于应用层是透明的，即数据库 感受不到mycat的存在，认为是直接连接的mysql数据库（实际上是连接的mycat,mycat实现了mysql的原生协议）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;MyCat的核心功能：读写分离、分库分表&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="数据库" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MyCat" scheme="http://liuyoubin.top/tags/MyCat/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议</title>
    <link href="http://liuyoubin.top/2020/03/02/netWork/TCP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://liuyoubin.top/2020/03/02/netWork/TCP%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-03-02T13:42:14.000Z</published>
    <updated>2020-03-03T15:47:23.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tcp协议特点"><a href="#Tcp协议特点" class="headerlink" title="Tcp协议特点"></a>Tcp协议特点</h1><ul><li>面向连接的传输层协议</li><li>点对点</li><li>提供可靠交付的服务、无差错、不重复、不丢失</li><li>提供全双工通信</li><li>面向字节流（tcp把应用程序交下来的数据看成仅仅是一连串的无结构字节流）</li></ul><a id="more"></a><h1 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h1><p><img src="https://s2.ax1x.com/2020/03/02/3fAlB6.png" alt="image"></p><ul><li><p>序号：在一个tcp连接中传输的字节流中每一个字节都按顺序编号，本字段表示本报文段所发送的<strong>第一个字节的序号</strong></p></li><li><p>六个控制位</p><ul><li><strong>URG</strong> - 紧急位，URG=1时表明此报文段的数据有紧急数据，应尽快传送，不用再缓存队列排队，配合紧急指针使用</li><li><strong>ACK</strong> - 确认位，ACK=1时确认号有效，在连接建立后都必须把ACK置为1</li><li><strong>PSH</strong> - 推送位，PSH=1时接收方应尽快交付应用程序，不用等接收缓存填满再向上交付</li><li><strong>RST</strong> - 复位，RST=1表明连接中出现严重差错，必须释放连接，重新建立连接</li><li><strong>SYN</strong> - 同步位，SYN=1表明是一个连接请求/连接接受报文</li><li><strong>FIN</strong> - 终止位，FIN=1表明要求释放连接</li></ul></li><li><p>窗口： 指定是本方的接收窗口大小，表明允许对方发送的数据量</p></li><li><p>检验和：检验首部+数据</p></li><li><p>紧急指针：配合URG=1，指出本报文段中紧急数据的字节数</p></li><li><p>选项：最大报文段长度MSS，窗口扩大、时间戳、选择确认</p></li></ul><h1 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="https://s2.ax1x.com/2020/03/02/3fn8Et.png" alt="image"></p><ul><li><p>ROUND1</p><p>客户端发送连接请求报文段，没有携带应用层数据</p><p>SYN=1 seq=x(随机)</p></li><li><p>ROUND2</p><p>服务端为该TCP连接分配缓存和变量，并向客户端返回确认报文的，允许连接，没有携带应用层数据</p><p>SYN=1，ACK=1，seq=y(随机)，ack=x+1</p></li><li><p>ROUND3</p><p>客户端为该TCP连接分配缓存和变量，并向服务器返回确认的确认，<strong>可以携带数据</strong></p></li></ul><p><strong>为什么是三次握手</strong></p><ol><li>为了防止已经失效的请求到达服务端而产生错误</li><li>为了实现可靠传输，tcp双方都必须维护一个序列号，而三次握手的过程就是互相告知双方的序列号起始值，并确认对方已经收到了序列号起始值</li></ol><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="https://s2.ax1x.com/2020/03/03/3fJaFJ.png" alt="image"></p><ul><li><p>ROUND1</p><p>客户端发送连接释放报文段，停止发送数据，主动关闭tcp连接</p><p>FIN=1，seq=u</p></li><li><p>ROUND2</p><p>服务器端发送确认报文端—-半关闭状态</p><p>ACK=1，ack=u+1，seq=v</p></li><li><p>ROUND3</p><p>服务端发送完数据，发送连接释放报文段，主动关闭tcp连接</p><p>FIN=1，seq=w，ACK=1，ack=u+1</p></li><li><p>ROUND4</p><p>客户端回复确认报文段，再等待计时器设置为<strong>2MSL（最长报文段寿命）</strong>，彻底关闭连接</p></li></ul><p><strong>为什么需要等待2MSL</strong></p><p>​        防止客户端的确认报文段没有到达服务器端</p><h1 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h1><blockquote><p>保证接收方从缓存区中读取的字节流和发送方发出的字节流是完全一致的</p></blockquote><p><strong>TCP采用了校验、序列号机制、和确认重传机制来保证可靠传输服务</strong></p><p><strong>确认重传机制包括累计确认、超时重传、快速重传等几方面</strong></p><h2 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h2><blockquote><p>累计确认就是TCP协议的确认方法，TCP使用可变长度报文段来发送数据，重传时，报文段数据可能会比原报文段数据包含更多的数据，因此对数据报和报文段无法进行简单的确认。TCP使用流序号对流中的一个位置进行确认，即序号和确认号一一对应，接收方使用序号将报文段重新排序，且 <strong>以正确接收到的流的最长连续前缀进行确认</strong> 。</p></blockquote><p><img src="https://s2.ax1x.com/2020/03/03/3fUWHf.png" alt="image"></p><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><blockquote><p>超时时间计算是开启定时器的设定时间，从而保证网络资源利用率，避免因定时器的时间（RTO）不确定而影响 <strong>网络传输</strong> 效率。</p><p>重传时间是动态改变的，tcp采用自适应算法（加权平均往返时间）</p></blockquote><p><img src="https://s2.ax1x.com/2020/03/03/3fUoCQ.png" alt="image"></p><p>​        如上图所示，第二个数据包丢失没有到达服务器，服务器无法对其进行ack确认，在定时器时间到达后客户端还没收到ack确认，就会确定重传。</p><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>​        超时重传虽然能解决可靠性问题，但是超时重传往往会带来许多问题，比如说：</p><ul><li>当一个报文段丢失时，会等待一定的超时周期然后才重传分组，增加了端到端的时延。</li><li>当一个报文段丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。</li></ul><p>所以tcp还有一种<strong>快速重传机制</strong></p><p>​        当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余ACK（duplicate ACK）。</p><p>​        这样，如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK（其实是收到4个同样的ACK，第一个是正常的，后三个才是冗余的），发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出，大大提高了效率。这便是快速重传机制。</p><h1 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h1><blockquote><p>为了让接收方能够来得及接收数据，不会因发送端发送速率过快而导致来不及接收。Tcp利用滑动窗口机制来实现流量控制</p></blockquote><p>​        在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送端口，即<strong>接收窗口rwnd</strong>（接收方通过确认报文的窗口字段来将rwnd通知给发送方），发送方的<strong>发送窗口</strong>取<strong>接收窗口rwnd</strong>和<strong>拥塞窗口cwnd</strong>的最小值。</p><p>​        当接收方的接收缓存已经满了，那么接收方会发送一个<strong>零窗口通知</strong>。发送方接收到<strong>零窗口通知</strong>，就会启动一个计时器，计时器持续时间到就会发送一个<strong>零窗口探测报文</strong>，接收方收到探测报文会给出现在的窗口值。</p><h1 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h1><blockquote><p>防止过多的数据注入到网络中，与流量控制相比拥塞控制具有全局性</p></blockquote><p><strong>为了解决拥塞问题，TCP提供了四种算法</strong></p><p>注意：下面的算法讨论有以下几个前提</p><ol><li>数据单向发送，接收方只发送确认报文</li><li>假定接收方的接收缓存总是充足的，即发送窗口=拥塞窗口cwnd</li></ol><h2 id="慢开始-拥塞避免"><a href="#慢开始-拥塞避免" class="headerlink" title="慢开始/拥塞避免"></a>慢开始/拥塞避免</h2><p><img src="https://s2.ax1x.com/2020/03/03/35ifw6.png" alt="image"></p><h2 id="快重传-快恢复"><a href="#快重传-快恢复" class="headerlink" title="快重传/快恢复"></a>快重传/快恢复</h2><p><img src="https://s2.ax1x.com/2020/03/03/35F29g.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Tcp协议特点&quot;&gt;&lt;a href=&quot;#Tcp协议特点&quot; class=&quot;headerlink&quot; title=&quot;Tcp协议特点&quot;&gt;&lt;/a&gt;Tcp协议特点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;面向连接的传输层协议&lt;/li&gt;
&lt;li&gt;点对点&lt;/li&gt;
&lt;li&gt;提供可靠交付的服务、无差错、不重复、不丢失&lt;/li&gt;
&lt;li&gt;提供全双工通信&lt;/li&gt;
&lt;li&gt;面向字节流（tcp把应用程序交下来的数据看成仅仅是一连串的无结构字节流）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机网络" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Tcp" scheme="http://liuyoubin.top/tags/Tcp/"/>
    
  </entry>
  
  <entry>
    <title>NIO与Netty</title>
    <link href="http://liuyoubin.top/2020/02/29/backEnd/framework/NIO%E4%B8%8ENetty/"/>
    <id>http://liuyoubin.top/2020/02/29/backEnd/framework/NIO%E4%B8%8ENetty/</id>
    <published>2020-02-29T11:52:59.000Z</published>
    <updated>2020-03-20T14:38:08.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><ol><li>理解</li></ol><p>​        IO模型就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序的通信性能。</p><ol start="2"><li><p>Java支持三种IO模型：BIO、NIO、AIO</p><ul><li>BIO - 同步并阻塞，服务器实现模式为一个线程一个连接，即客户端有连接请求时服务端就必须启动一个线程进行处理，如果连接不做任何事就会造成不必要的线程开销</li><li>NIO - 同步非阻塞，服务器实现一个线程处理多个请求，即客户端发送的连接请求会注册的多路服务器上，多路轮询到连接有IO请求就进行处理</li><li>AIO - 异步非阻塞，AIO引入异步通信通道的概念，采用了Proactor模式。简化了程序的编写，有效的请求才启动线程，它的特点是先有操作系统完成后才通知服务端程序去处理，一般用于连接数较多且连接时间较长的应用。</li></ul><a id="more"></a><p><img src="https://s2.ax1x.com/2020/02/29/3yjrOx.png" alt="image"></p></li><li><p>BIO客户端编写例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//线程池</span></span><br><span class="line">        ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">"服务器启动"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//监听等待客户端连接</span></span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">"连接到一个客户端"</span>);</span><br><span class="line"></span><br><span class="line">            threadPool.execute(()-&gt;&#123;</span><br><span class="line">                handler(socket);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法和客户端通信</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//获取连接的输入流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((len=inputStream.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(buffer, <span class="number">0</span>, len));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"关闭socket连接"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h2 id="NIO三大核心部分"><a href="#NIO三大核心部分" class="headerlink" title="NIO三大核心部分"></a>NIO三大核心部分</h2><ul><li><strong>Channel - 通道</strong></li><li><strong>Buffer - 缓冲区</strong></li><li><strong>Selector - 选择器</strong></li></ul><p><img src="https://s2.ax1x.com/2020/02/29/36CJgg.png" alt="image"></p><p><strong>说明：</strong></p><ol><li>每个Channel都会对应一个Buffer</li><li>每个Selector对应一个线程</li><li>每一个Channel注册到Selector上，程序切换到哪个Channel上由事件（Event）决定</li><li>Buufer则是一个内存块，底层是一个数组</li><li>数据的读写通过Buffer,既可以读也可以写通过filp方法切换</li><li>Channel是双向的</li></ol><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><blockquote><p>非阻塞模式下，一个选择器可检测多个SelectableChannel，获取为读写等操作准备好的通道，不用我们循环去判断</p></blockquote><blockquote><p>通过Selector，一个线程可以处理多个Channel，可极大减少线程数。用cpu核心数的线程，充分利用cpu资源，又减少线程切换</p></blockquote><h4 id="Selector的使用"><a href="#Selector的使用" class="headerlink" title="Selector的使用"></a>Selector的使用</h4><ol><li><p><strong>Selector创建/注册通道</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开一个选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"><span class="comment">//将通道设置为非阻塞模式</span></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//将通道注册到选择器中</span></span><br><span class="line">SelectionKey key= channel.register(selector,SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><p>register方法参数说明:指定监听的就绪事件</p><ul><li>SelectionKey.OP_CONNECT 有新的网络连接可以accept ，值为16</li></ul></li></ol><ul><li><p>SelectionKey.OP_ACCEPT      代表连接已建立，值为8</p></li><li><p>SelectionKey.OP_READ          代表读操作，值为1</p><ul><li>SelectionKey.OP_WRITE         代表写操作，值为4</li></ul></li></ul><ol start="2"><li><p><strong>Selector选择就绪的Channel</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = selector.select();</span><br></pre></td></tr></table></figure><p>方法选择：返回就绪的Channel数量</p><ul><li><p>int select() 阻塞到有就绪的Channel</p></li><li><p>int select(long timeout) 阻塞最长多久</p></li><li><p>int selectNow 不阻塞</p></li></ul></li><li><p><strong>获得就绪的SelectionKey集合（当有就绪的Channel时）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure></li><li><p><strong>迭达处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line">   </span><br><span class="line">      Set&lt;SelectionKey&gt; keySet = selector.selectedKeys();</span><br><span class="line">   </span><br><span class="line">      Iterator&lt;SelectionKey&gt; keyIterator = keySet.iterator();</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">while</span> (keyIterator.hasNext())&#123;</span><br><span class="line">   </span><br><span class="line">          SelectionKey key = keyIterator.next();</span><br><span class="line">          <span class="comment">//将处理的key移除</span></span><br><span class="line">          keyIterator.remove();</span><br><span class="line">          <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">              <span class="comment">//相应的处理</span></span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isConnectable())&#123;</span><br><span class="line">              <span class="comment">//相应的处理</span></span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">              <span class="comment">//相应的处理</span></span><br><span class="line">          &#125;<span class="keyword">else</span>  <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">              <span class="comment">//相应的处理</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p><strong>Channel的四种实现</strong></p><ul><li>FileChannel //只能用于阻塞情况</li><li>DatagramChannel //数据报通道，用于udp协议</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p><strong>Channel的API</strong></p><ul><li>open() 创建通道</li><li>read(Buufer) 从通道中读取数据到Buffer中</li><li>write(Buufer) 将Buffer中的数据写通道中</li></ul><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><blockquote><p>缓冲区：数据的临时存放区</p></blockquote><p><strong>Buffer的基本使用步骤</strong></p><ol><li>XXXBuffer.allocate(int)创建Buffer</li><li>调用put方法往Buufer中写数据</li><li>调用buffer.flip()将buffer转为读模式</li><li>读取buffer中的数据</li><li>Call buffer.clear() or buffer.compact()</li></ol><p><strong>Buffer的三个重要属性 capacity position limit</strong></p><ul><li>Capacity - 容量，即可以容纳的最大数据量，创建Buufer时指定且不能改变</li><li>Limit - 表示缓冲区的当前终点，不能对缓冲区超过极限的位置进行读写</li><li>Position - 下一个要被读写的位置 </li></ul><p><img src="https://s2.ax1x.com/2020/02/29/36QIiD.png" alt="image"></p><h2 id="NIO通信案例"><a href="#NIO通信案例" class="headerlink" title="NIO通信案例"></a>NIO通信案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ServerSocketChannel</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//得到一个Selector对象</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//绑定端口</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//把ServerSocketChannel注册到Selector</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;<span class="comment">//等待客户端连接</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(selector.select(<span class="number">1000</span>)==<span class="number">0</span>)&#123;<span class="comment">//等待一秒</span></span><br><span class="line">                System.out.println(<span class="string">"服务器等待1秒,无连接"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取相关的selectorKey</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeySet = selector.selectedKeys();</span><br><span class="line">            <span class="comment">//使用迭达器遍历</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeySet.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line"></span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="comment">//移除key</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="comment">//根据就绪事件做不同的处理</span></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable())&#123;<span class="comment">//有客户端连接</span></span><br><span class="line">                    <span class="comment">//获取客户端连接</span></span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    <span class="comment">//设置为非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//将连接通道注册到Selector中,就绪事件为OP_READ,同时分配一个Buffer</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ,ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (key.isReadable())&#123;<span class="comment">//可读</span></span><br><span class="line">                    <span class="comment">//通过key获取通道</span></span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">//获取该channel的Buffer</span></span><br><span class="line">                    ByteBuffer byteBuffer = (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="comment">//将Buffer中的数据读到Channel中</span></span><br><span class="line">                    socketChannel.read(byteBuffer);</span><br><span class="line">                    System.out.println(<span class="string">"客户端："</span>+<span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个网络通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//提供服务端的ip和端口</span></span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="keyword">if</span>(!socketChannel.connect(inetSocketAddress))&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">                System.out.println(<span class="string">"连接不成功，客户端不会阻塞"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        String str = <span class="string">"hello,world"</span>;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.wrap(str.getBytes());</span><br><span class="line"></span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><blockquote><p>零拷贝是网络编程的关键，很多性能优化都离不开</p><p>Java常用的零拷贝有mmap(内存映射)和sendFile</p></blockquote><p>先看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      File file = <span class="keyword">new</span> File(<span class="string">"a.html"</span>);</span><br><span class="line">      RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</span><br><span class="line"><span class="keyword">int</span> len = file.length();</span><br><span class="line">      <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">      raf.read(arr);</span><br><span class="line"></span><br><span class="line">      Socket socket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>).accept();</span><br><span class="line">      socket.getOutputStream().write(arr);</span><br></pre></td></tr></table></figure><p>当执行这段代码的时候OS底层发生了什么呢? </p><h2 id="传统IO"><a href="#传统IO" class="headerlink" title="传统IO"></a>传统IO</h2><p><img src="https://s2.ax1x.com/2020/03/01/3gvWkV.png" alt="image"></p><ul><li>read方法导致用户态到内核态的切换，同时通过DMA（直接内存读取）方式将数据从硬盘读到内核缓冲区</li><li>接下来将数据从内核态通过CPU拷贝到用户缓冲区，发生了第二次上下文切换</li><li>数据从用户缓冲区通过CPU拷贝到Socket缓冲区，发生了第三次上下文切换</li><li>数据从Socket缓冲区通过DMA方式传输到网络协议引擎</li></ul><p><strong>总共发生了3次上下文切换和4次拷贝</strong></p><h2 id="MMAP优化"><a href="#MMAP优化" class="headerlink" title="MMAP优化"></a>MMAP优化</h2><p><img src="https://s2.ax1x.com/2020/03/01/3gxBAx.png" alt="image"></p><p>如图所示</p><p>user buffer 和 kernel buffer 共享数据文件。如果你想把硬盘的文件传输到网络中，再也不用拷贝到用户空间，再从用户空间拷贝到 Socket 缓冲区。通过MMAP，你只需要从内核缓冲区拷贝到 Socket 缓冲区即可，这将减少一次内存拷贝（从 4 次变成了 3 次），但不减少上下文切换次数。</p><p><strong>总共发生了3次上下文切换和3次拷贝</strong></p><h2 id="SendFile优化"><a href="#SendFile优化" class="headerlink" title="SendFile优化"></a>SendFile优化</h2><p><img src="https://s2.ax1x.com/2020/03/01/32Smes.png" alt="image"></p><p>​        Linux 2.1 版本 提供了 sendFile 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 Socket Buffer，同时，由于和用户态完全无关，就减少了一次上下文切换。</p><p><strong>总共发生了2次上下文切换和3次拷贝</strong></p><h2 id="SendFile进阶优化"><a href="#SendFile进阶优化" class="headerlink" title="SendFile进阶优化"></a>SendFile进阶优化</h2><p><img src="https://s2.ax1x.com/2020/03/01/32SjhV.png" alt="image"></p><p>​        Linux 在 2.4 版本中，做了一些修改，避免了从内核缓冲区拷贝到 Socket buffer 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。</p><p><strong>总共发生了2次上下文切换和2次拷贝</strong></p><blockquote><p>说明：零拷贝不是指没有发生拷贝。而是指没有CPU拷贝。</p><p>​            零拷贝不仅减少了CPU拷贝也减少了上下文切换    </p><p>​            在Java中的transferTo 和 transferFrom 方法底层就是用用到了零拷贝技术</p></blockquote><h1 id="Netty概述"><a href="#Netty概述" class="headerlink" title="Netty概述"></a>Netty概述</h1><p>​    <strong>Netty是一个异步的，基于事件的网络应用框架</strong></p><p>​    <a href="https://netty.io/" target="_blank" rel="noopener">Netty官网</a></p><h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><h2 id="单Reacto单线程"><a href="#单Reacto单线程" class="headerlink" title="单Reacto单线程"></a>单Reacto单线程</h2><p><img src="https://s2.ax1x.com/2020/03/01/32D3dK.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IO模型&quot;&gt;&lt;a href=&quot;#IO模型&quot; class=&quot;headerlink&quot; title=&quot;IO模型&quot;&gt;&lt;/a&gt;IO模型&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;理解&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​        IO模型就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序的通信性能。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;p&gt;Java支持三种IO模型：BIO、NIO、AIO&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BIO - 同步并阻塞，服务器实现模式为一个线程一个连接，即客户端有连接请求时服务端就必须启动一个线程进行处理，如果连接不做任何事就会造成不必要的线程开销&lt;/li&gt;
&lt;li&gt;NIO - 同步非阻塞，服务器实现一个线程处理多个请求，即客户端发送的连接请求会注册的多路服务器上，多路轮询到连接有IO请求就进行处理&lt;/li&gt;
&lt;li&gt;AIO - 异步非阻塞，AIO引入异步通信通道的概念，采用了Proactor模式。简化了程序的编写，有效的请求才启动线程，它的特点是先有操作系统完成后才通知服务端程序去处理，一般用于连接数较多且连接时间较长的应用。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="框架" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java" scheme="http://liuyoubin.top/tags/Java/"/>
    
      <category term="Netty" scheme="http://liuyoubin.top/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>设计模式整理</title>
    <link href="http://liuyoubin.top/2020/02/19/backEnd/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%B4%E7%90%86/"/>
    <id>http://liuyoubin.top/2020/02/19/backEnd/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%B4%E7%90%86/</id>
    <published>2020-02-19T15:01:31.000Z</published>
    <updated>2020-03-26T14:05:02.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h1><ol><li><strong>单一职责原则</strong><ul><li>降低类的负责度，一个类只负责一项职责</li><li>提高类的可读性，可维护性</li><li>降低变更引起的风险</li><li>通常情况下，应该遵守单一职责原则。只有逻辑足够简单才可以在代码级违反单一职责原则。只有类中方法足够少，可以在方法级别保持单一职责原则</li></ul></li><li><strong>接口隔离原则</strong><ul><li>一个类不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</li></ul></li><li><strong>依赖倒转原则</strong><ul><li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好</li><li>变量的声明类型尽量是抽象类或者接口，利于程序的扩展和优化</li><li>抽象不应该依赖细节，细节应该依赖抽象</li><li>中心思想就是面向接口编程</li></ul></li><li><strong>里氏替换原则</strong><ul><li>所有引用基类的地方必须能透明地使用其子类对象</li><li>使用继承时，尽量不要重写父类的方法</li><li>继承实际上让两个类耦合性增强了，在适当情况下可以使用组合、聚合、依赖来解决问题</li></ul></li><li><strong>开闭原则</strong><ul><li>一个软件实体比如类，模块和函数应该对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节</li><li>当软件需求变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化</li></ul></li><li><strong>迪米特法则</strong><ul><li>一个对象应该对其他对象保持最少的了解</li><li>类与类关系越密切，耦合度越大</li><li>一个类对自己依赖的类了解的越少越好，不管依赖的类有多么复杂，都尽量将逻辑封装在类的内部，除对外提供public方法，不对外泄露任何信息</li></ul></li><li><strong>合成复用原则</strong><ul><li>尽量使用合成/聚合的方式，而不是继承</li></ul></li></ol><a id="more"></a><h1 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h1><p>​        <strong>设计模式不是代码，而是某类问题的通用解决方案。设计模式的本质是提高软件的可维护性、通用性和扩展性，并降低软件的复杂度。</strong></p><p>​        <code>设计模式分为三种类型，共23种</code></p><ol><li><strong>创建型模式</strong>：<code>单例模式</code>、抽象工厂模式、原型模式、建造者模式、<code>工厂模式</code></li><li><strong>结构型模式</strong>：设配器模式、桥接模式、<code>装饰模式</code>、组合模式、外观模式、享元模式、<code>代理模式</code></li><li><strong>行为型模式</strong>：模板方法模式、命令模式、访问者模式、迭达器模式、<code>观察者模式</code>、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式</li></ol><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>​        单例模式就是采取一定的方法保证在整个软件系统中，对某个类只能有一个对象实例，并且该类只提供一个取得其对象实例的方法。</p><h2 id="八种单例模式的写法"><a href="#八种单例模式的写法" class="headerlink" title="八种单例模式的写法"></a><strong>八种单例模式的写法</strong></h2><ol><li><p><strong>饿汉式(静态常量)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类加载的时候,立即创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：写法简单，类加载的时候完成实例化，没有线程安全问题</p><p>缺点：没有懒加载效果，容易造成内存浪费</p></li></ol><ol start="2"><li><p><strong>饿汉式(静态代码块)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行静态代码块的时候,创建对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>​        优缺点和<strong>饿汉式(静态常量)</strong>一样</p><ol start="3"><li><p><strong>懒汉式(线程不安全)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当使用该方法时才创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：能够实现懒加载</p><p>缺点：线程不安全，有可能产生多个实例，多线程环境下不能使用</p></li></ol><ol start="4"><li><p><strong>懒汉式(线程安全，同步方法)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当使用该方法时才创建对象,由于加了synchronized解决了线程安全问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：能够实现懒加载，线程安全</p><p>缺点：每个线程在获取实例的时候都要进行同步，效率低下</p></li></ol><ol start="5"><li><p><strong>懒汉式(线程安全，同步代码块)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当使用该方法时才创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这种方式本质上是对上一种方法的改进，但是这种方法并不能起到线程同步的作用。因为有可能有多个线程都判断到instance==null，从而产生多个实例。</p></li></ol><ol start="6"><li><p><strong>双重检查</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意这里需要加volatile关键字，否则会有线程安全问题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当使用该方法时才创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能够实现懒加载，又解决线程安全问题，同时效率较高。推荐使用这种方法。</p></li></ol><ol start="7"><li><p><strong>静态内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当使用该方法时,静态内部类SingletonInstance才会被加载，Singleton实例才会被创建。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用类加载机制来保证单例，同时保证线程安全以及懒加载。</p></li></ol><ol start="8"><li><p><strong>枚举</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  Singleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以实现懒加载，效率高。同时可以避免序列化、反序列化和反射破坏单例。</p></li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h2><p>​        在频繁进行创建销毁导致消耗资源过多，但系统中只需要存在一个的对象。比如工具类对象，工厂对象，数据源等，可以使用单例模式进行改造。</p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ol><li><p>简单工厂模式是工厂模式中最简单实用的一种。<strong>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例</strong></p></li><li><p>定义一个创建对象的类，由这个类来封装实例化对象的行为</p></li><li><p><strong>不属于23种设计模式之一</strong></p></li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalSimpleFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">getAnimalByType</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        Animal animal = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"猫"</span>))&#123;</span><br><span class="line">        animal =  <span class="keyword">new</span> Cat();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"狗"</span>))&#123;</span><br><span class="line">        animal =  <span class="keyword">new</span> Dog();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"鸟"</span>))&#123;</span><br><span class="line">        animal =  <span class="keyword">new</span> Bird();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> animal;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>定义一个创建对象的抽象方法，由子类决定要实例化的类。将对象的实例化推迟到子类</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Animal <span class="title">getAnimal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogFactory</span> <span class="keyword">extends</span> <span class="title">AnimalFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Animal <span class="title">getAnimal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatFactory</span> <span class="keyword">extends</span> <span class="title">AnimalFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Animal <span class="title">getAnimal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>​        定义一个接口用于创建相关的对象簇，而无需指定具体的类。从抽象层面看，抽象工厂模式就是对简单工厂模式的进一步抽象。将工厂抽象成抽象工厂和具体实现的工厂子类，将简单工厂变成工厂簇。</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Phone <span class="title">createPhone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Router <span class="title">createRouter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂的具体实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaWeiFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaWeiPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Router <span class="title">createRouter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaweiRouter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂的具体实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaomiFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaomoPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Router <span class="title">createRouter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaomiRouter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=====================================================</span><br><span class="line"><span class="comment">//抽象产品-手机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象产品-路由器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">router</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象产品的具体实现就不写了</span></span><br></pre></td></tr></table></figure><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p>​        我们直接new一个对象的时候需要比较长的时间，当我们需要大量创建对象的时候可以采用克隆模式。</p><p>​        克隆可以分为浅克隆和深克隆</p><h2 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原型模式（克隆模式）</span></span><br><span class="line"><span class="comment"> * 实现Cloneable接口</span></span><br><span class="line"><span class="comment"> * 重写Object方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>,<span class="title">Serializable</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String sname;</span><br><span class="line">  <span class="keyword">private</span> Date birthday;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String sname, Date birthday)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.sname = sname;</span><br><span class="line">    <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getSname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sname;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSname</span><span class="params">(String sname)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sname = sname;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> birthday;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 重写方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Object obj =  <span class="keyword">super</span>.clone();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">测试类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//浅克隆 </span></span><br><span class="line">    Date date = <span class="keyword">new</span> Date(<span class="number">1243564634124L</span>);</span><br><span class="line">    Sheep s1 = <span class="keyword">new</span> Sheep(<span class="string">"小白羊"</span>,date);</span><br><span class="line">    System.out.println(s1.getSname()+<span class="string">"---&gt;"</span>+s1.getBirthday());</span><br><span class="line">    <span class="comment">//进行克隆</span></span><br><span class="line">    Sheep s2 = (Sheep)s1.clone();</span><br><span class="line">    s2.setSname(<span class="string">"小黑羊"</span>);</span><br><span class="line">    System.out.println(s2.getSname()+<span class="string">"---&gt;"</span>+s2.getBirthday());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当修改s1对象指向的Date对象时，s2对象的Date对象也随之改变（因为两者指向 同一个对象 ，浅克隆）</span></span><br><span class="line">    date.setTime(<span class="number">2232345643213L</span>);</span><br><span class="line">    System.out.println(s1.getSname()+<span class="string">"---&gt;"</span>+s1.getBirthday());</span><br><span class="line">    System.out.println(s2.getSname()+<span class="string">"---&gt;"</span>+s2.getBirthday());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原型模式（克隆模式）</span></span><br><span class="line"><span class="comment"> * 实现Cloneable接口</span></span><br><span class="line"><span class="comment"> * 重写Object方法</span></span><br><span class="line"><span class="comment"> * 深克隆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep2</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String sname;</span><br><span class="line">  <span class="keyword">private</span> Date birthday;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sheep2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sheep2</span><span class="params">(String sname, Date birthday)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.sname = sname;</span><br><span class="line">    <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getSname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sname;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSname</span><span class="params">(String sname)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sname = sname;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> birthday;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 重写方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Object obj =  <span class="keyword">super</span>.clone();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加如下代码实现深克隆</span></span><br><span class="line">    Sheep2 s = (Sheep2)obj;</span><br><span class="line">    s.birthday = (Date) <span class="keyword">this</span>.birthday.clone();<span class="comment">//把属性也进行拷贝</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">测试类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过序列化和反序列化实现深克隆</span></span><br><span class="line"><span class="comment"> * 要实现序列化原来类必须记得实现Serializable接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text2</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Date date  = <span class="keyword">new</span> Date(<span class="number">123142556765L</span>); </span><br><span class="line">    Sheep s1 = <span class="keyword">new</span> Sheep(<span class="string">"小白羊"</span>,date);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//序列化</span></span><br><span class="line">    ByteArrayOutputStream bas = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bas);</span><br><span class="line">    oos.writeObject(s1);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = bas.toByteArray();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//反序列化</span></span><br><span class="line">    ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">    Sheep s2 = (Sheep)ois.readObject();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//由此实现了深克隆</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><p>​        将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。用户可以在不知道对象建造细节和过程的情况下直接创建复杂对象。</p><h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体的产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"><span class="comment">//默认产品实现</span></span><br><span class="line">    <span class="keyword">private</span> String A = <span class="string">"aaa"</span>;</span><br><span class="line">    <span class="keyword">private</span> String B = <span class="string">"bbb"</span>;</span><br><span class="line">    <span class="keyword">private</span> String C = <span class="string">"ccc"</span>;</span><br><span class="line">    <span class="keyword">private</span> String D = <span class="string">"ddd"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Builder <span class="title">setA</span><span class="params">(String msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Builder <span class="title">setB</span><span class="params">(String msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Builder <span class="title">setC</span><span class="params">(String msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Builder <span class="title">setD</span><span class="params">(String msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Product <span class="title">getProduct</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Builder <span class="title">setA</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        product.setA(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Builder <span class="title">setB</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        product.setA(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Builder <span class="title">setC</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        product.setA(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Builder <span class="title">setD</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        product.setA(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Product <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Builder worker = <span class="keyword">new</span> Worker();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端可以自由指定进行装配，而具体的实现细节由建造者实现</span></span><br><span class="line">        Product product = worker.setA(<span class="string">"AAA"</span>).getProduct();</span><br><span class="line"></span><br><span class="line">        System.out.println(product);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点<ul><li>产品的建造和表示分离，实现解耦。客户端不必知道产品内部的细节</li><li>将复杂产品的创建步骤分解在不同方法中，使得创建过程更加清晰</li><li>具体的建造者之间是互相独立的，有利于系统扩展，符合“开闭原则”</li></ul></li><li>缺点<ul><li>建造者的产品一般具有较多共同点，如果产品差异较大，则不适合使用建造者模式</li><li>如果产品内部变化复杂，则需要较多的不同建造者，这将导致系统变得庞大</li></ul></li></ul><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><p>​        观察者模式是解决一对多依赖的一种解决方案。比如说一个对象的变化会引起其他多个对象的变化，这时就可以考虑观察者模式</p><ul><li>优点：<ol><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li><li>目标与观察者之间建立了一套触发机制。</li></ol></li><li>缺点<ol><li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li><li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li></ol></li></ul><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://s2.ax1x.com/2020/02/29/3r5Dtf.png" alt="image"></p><h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature,<span class="keyword">float</span> pressure,<span class="keyword">float</span> humidity)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditions</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"气温："</span>+<span class="keyword">this</span>.temperature);</span><br><span class="line">        System.out.println(<span class="string">"气压："</span>+<span class="keyword">this</span>.pressure);</span><br><span class="line">        System.out.println(<span class="string">"湿度："</span>+<span class="keyword">this</span>.humidity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观察者集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注册观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移除观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历通知观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers.forEach(n-&gt; n.update(<span class="keyword">this</span>.temperature, <span class="keyword">this</span>.pressure, <span class="keyword">this</span>.humidity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新数据时通知观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateData</span><span class="params">(<span class="keyword">float</span> temperature,<span class="keyword">float</span> pressure,<span class="keyword">float</span> humidity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设配器模式"><a href="#设配器模式" class="headerlink" title="设配器模式"></a>设配器模式</h1><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设计模式七大原则&quot;&gt;&lt;a href=&quot;#设计模式七大原则&quot; class=&quot;headerlink&quot; title=&quot;设计模式七大原则&quot;&gt;&lt;/a&gt;设计模式七大原则&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;单一职责原则&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;降低类的负责度，一个类只负责一项职责&lt;/li&gt;
&lt;li&gt;提高类的可读性，可维护性&lt;/li&gt;
&lt;li&gt;降低变更引起的风险&lt;/li&gt;
&lt;li&gt;通常情况下，应该遵守单一职责原则。只有逻辑足够简单才可以在代码级违反单一职责原则。只有类中方法足够少，可以在方法级别保持单一职责原则&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接口隔离原则&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;一个类不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;依赖倒转原则&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好&lt;/li&gt;
&lt;li&gt;变量的声明类型尽量是抽象类或者接口，利于程序的扩展和优化&lt;/li&gt;
&lt;li&gt;抽象不应该依赖细节，细节应该依赖抽象&lt;/li&gt;
&lt;li&gt;中心思想就是面向接口编程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;里氏替换原则&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;所有引用基类的地方必须能透明地使用其子类对象&lt;/li&gt;
&lt;li&gt;使用继承时，尽量不要重写父类的方法&lt;/li&gt;
&lt;li&gt;继承实际上让两个类耦合性增强了，在适当情况下可以使用组合、聚合、依赖来解决问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开闭原则&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;一个软件实体比如类，模块和函数应该对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节&lt;/li&gt;
&lt;li&gt;当软件需求变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;迪米特法则&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;一个对象应该对其他对象保持最少的了解&lt;/li&gt;
&lt;li&gt;类与类关系越密切，耦合度越大&lt;/li&gt;
&lt;li&gt;一个类对自己依赖的类了解的越少越好，不管依赖的类有多么复杂，都尽量将逻辑封装在类的内部，除对外提供public方法，不对外泄露任何信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合成复用原则&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;尽量使用合成/聚合的方式，而不是继承&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://liuyoubin.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis笔记整理</title>
    <link href="http://liuyoubin.top/2020/02/18/backEnd/Redis%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    <id>http://liuyoubin.top/2020/02/18/backEnd/Redis%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</id>
    <published>2020-02-18T03:55:37.000Z</published>
    <updated>2020-04-02T16:34:44.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p>​        <code>Redis是一个基于内存、支持持久化、的高性能NoSql的key-value数据库。</code></p><p><strong>Redis的特点</strong></p><ul><li>支持数据持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次进行加载。</li><li>数据结构丰富，支持string、list、set、zset、hash…….</li><li>支持数据备份、集群等高可用功能</li><li>性能高 （读速度：110000次/s，写速度：8100次/s）</li><li>原子性，Redis所有操作都是原子性的</li><li>特性丰富，Redis还支持发布/订阅、通知…..</li></ul><a id="more"></a><blockquote><p>Redis是单线程，Redis是基于内存操作的，CPU不是Redsi的瓶颈，Redis的瓶颈是内存大小和网络带宽。</p></blockquote><h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h1><p>​        Redis有Windows版本，也有Linux版本，这里记录Linux版本的安装。（如果会Docker也可以采用Docker进行安装）</p><ol><li><p>安装gcc环镜</p><p>​    查看是否安装过gcc，如果没有则需安装gcc,因为Redis是C语言编写的</p></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看是否安装gcc</span></span><br><span class="line"><span class="attr">gcc</span> <span class="string">--version</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装gcc</span></span><br><span class="line"><span class="attr">yum</span> <span class="string">-y install gcc automake autoconf libtool make</span></span><br></pre></td></tr></table></figure><ol start="2"><li>安装Redis</li></ol><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#下载安装包</span></span><br><span class="line">wget http:<span class="comment">//download.redis.io/releases/redis-4.0.1.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#解压缩</span></span><br><span class="line">tar -zxvf redis<span class="number">-4.0</span><span class="number">.1</span>.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#切换到redis目录下</span></span><br><span class="line">cd redis<span class="number">-4.0</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#编译</span></span><br><span class="line">make MALLOC=libc</span><br><span class="line"></span><br><span class="line"><span class="meta">#安装编译后的文件到指定目录</span></span><br><span class="line">make PREFIX=/usr/local/redis install</span><br></pre></td></tr></table></figure><h1 id="Redis启动与关闭"><a href="#Redis启动与关闭" class="headerlink" title="Redis启动与关闭"></a>Redis启动与关闭</h1><h2 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h2><p>进入安装目录,执行命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/usr/local/redis/bin</span></span><br><span class="line"></span><br><span class="line"><span class="string">./redis-server</span> [redis配置文件位置]</span><br></pre></td></tr></table></figure><h2 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/usr/local/redis/bin</span></span><br><span class="line"></span><br><span class="line"><span class="string">./server-cli</span> [-h IP地址 -p 端口号 -a 密码]</span><br></pre></td></tr></table></figure><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><ol><li>非正常关闭（杀进程、断电）</li></ol><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询PID</span></span><br><span class="line">ps -ef | <span class="keyword">grep</span> redis</span><br><span class="line"></span><br><span class="line"><span class="keyword">kill</span> -<span class="number">9</span> PID</span><br></pre></td></tr></table></figure><ol start="2"><li>通过客户端正常关闭</li></ol><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./bin/redis-cli</span> <span class="keyword">shutdown</span></span><br></pre></td></tr></table></figure><h1 id="Redis配置文件"><a href="#Redis配置文件" class="headerlink" title="Redis配置文件"></a>Redis配置文件</h1><p>​        <code>Redis配置文件位于Redis安装包下(注意：不是安装后的目录下)，名字叫redis.conf</code></p><p>​        在实际中我们会手动配置redis，所以要把redis配置文件复制到redis安装目录下</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#切换到redis安装包下</span></span><br><span class="line"><span class="keyword">cd</span> <span class="string">/usr/src/redis-4.0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#复制配置文件到安装目录下</span></span><br><span class="line">cp redis.conf <span class="string">/usr/local/redis</span></span><br></pre></td></tr></table></figure><h2 id="Redis配置项详解"><a href="#Redis配置项详解" class="headerlink" title="Redis配置项详解"></a>Redis配置项详解</h2><ul><li><p>daemonize no</p><p>​        redis默认不是以守护进程方式启动，可以通过修改成yes启动守护进程</p></li></ul><ul><li><p>pidfile</p><p>​        当redis以守护进程启动时，默认将pid写入/var/run/redis.pid,可以通过pidfile指定</p></li></ul><ul><li>port</li></ul><p>​                指定redis监听端口</p><ul><li><p>bind 127.0.0.1</p><p>​        绑定主机地址，默认只能本机访问，可以通过注释解除访问限制</p></li></ul><ul><li><p>timeout</p><p>​        当客户端闲置多长时间后关闭连接，如果指定为0则关闭该功能</p></li></ul><ul><li><p>loglevel</p><p>​        指定日志级别，Redis支持debug、verbose(默认)、notice、warning四个级别</p></li></ul><ul><li><p>logfile stdout</p><p>​        日志记录方式，如果Reids以守护进程方式进行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</p></li></ul><ul><li><p>databases</p><p>​    设置数据库数量,默认为16</p></li></ul><ul><li><p>save <seconds> <change></p><p>​    指定在多次时间内有多少次更新操作，就将数据同步到数据文件中，可以多条件配合</p><p>​    save 900 1                900秒内有1个更改</p><p>​    save 300  10             300秒内有10个更改</p><p>​    save  60    10000      60秒内有10000个更改</p></li></ul><ul><li><p>rdbcompression </p><p>​    指定存储至本地数据库的时候是否采用LZF压缩，默认为true。如果设置成no可以节省cpu时间，但数据库文件会变大。</p></li></ul><ul><li><p>dbfilename</p><p>​    指定数据库文件名，默认为dump.rdb</p></li></ul><ul><li><p>dir ./</p><p>​    指定数据库文件存放位置</p></li></ul><ul><li><p>slaveof <masterip> <masterport></p><p>​    设置本机为slave服务时，指定master的ip和port，用于同步数据</p></li></ul><ul><li><p>masterauth <master-password></p><p>​    当master服务设置密码时，slave服务连接master的密码</p></li></ul><ul><li><p>requirepass</p><p>​    设置redis密码，如果设置了redis密码，客户端连接redis时需要通过 AUTH <password> 命令提供密码。redis3.0之后如果想要远程连接必须提供密码。</p></li></ul><ul><li><p>maxclients</p><p>​    设置同一时间最大的客户端连接数，默认无限制</p></li></ul><ul><li><p>maxclients <bytes></p><p>​    指定redis最大的内存限制。Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会尝试清除已到期或即将到期的Key,当此方法后任然达到最大内存限制，将无法再进行写操作，但仍然可以读。Redis最新的vm机制，会把key放在内存，value放在swap区。</p></li></ul><ul><li><p>appendonly on</p><p>​    指定是否每次在更新后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断点时导致一段时间的数据丢失。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会有一段时间内只存在于内存中。默认为no</p></li></ul><ul><li><p>appendfilename appendonly.aof</p><p>​    指定更新日志文件名</p></li></ul><ul><li><p>appendfsync</p><p>​    指定更新日志条件：</p><ul><li>no  表示等操作系统进行数据缓存同步到磁盘</li><li>always  表示每次更新后手动调用fsync()将数据写到磁盘 (慢，安全)</li><li>everysec   表示每秒同步一次</li></ul></li></ul><ul><li><p>vm-enabled  no</p><p>​    指定是否启用虚拟机内存机制，默认为no。VM机制将数据分页存放，由Redis将访问较少的页存到swap中。</p></li></ul><ul><li><p>vm-swap-file  </p><p>​    虚拟内存文件路径，默认为/tmp/redis.swap</p></li></ul><ul><li><p>vm-max-memory 0</p><p>​    将所有大于vm-max-memory的数据存入虚拟内存，无论cm-max-memory设置多小，所有所有数据都是存储在内存的。也就是说当设置为0，所有value都存在swap区。</p></li></ul><ul><li><p>vm-page-size 32</p><p>​        Redis swap文件分成了许多的page，一个对象可以保存多个page上，但一个page上不能被多个对象共享。建议如果存储很多小对象，page大小设置为32或者64bytes;如果设置很多大对象，page可以设置更大。</p></li></ul><h1 id="Redis内存维护策略"><a href="#Redis内存维护策略" class="headerlink" title="Redis内存维护策略"></a>Redis内存维护策略</h1><p>​        redis作为优秀的内存中间件，内存消耗是一个不可忽视问题，所以需要整理内存，维护系统性能。有两种解决方案</p><ol><li>为数据设置超时时间</li></ol><ol start="2"><li>采用LRU算法将不用的数据删除</li></ol><ul><li>volatile-lru  设定超时时间的数据中，删除最不常用的数据</li><li>allkeys-lru   所有key中最近最不常使用的数据进行删除</li><li>volatile-random   在设定超时的数据中随机删除</li><li>allkeys-random     所有key中随机删除</li><li>volatile-tll     全部设定超时时间的数据，之后排序，将马上要过期的数据进行删除</li><li>Noeviction 如果设置成该属性，则不会删除操作，如果内存溢出则报错返回</li><li>volatile-lfu   设定超时时间的数据中删除使用频率最少的键</li><li>allkeys-lfu    所有key中删除使用频率最少的键</li></ul><h1 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h1><h2 id="键命令"><a href="#键命令" class="headerlink" title="键命令"></a>键命令</h2><ul><li><p>DEL key</p><p>​    用于key存在时删除 key</p></li><li><p>DUMP  key</p><p>​    序列化给定key,并返回被序列化的值</p></li><li><p>EXISTS key</p><p>​    检查给定key是否存在</p></li><li><p>EXPIRE key seconds</p><p>​    为给定的key设置过期时间（秒）</p></li><li><p>TTL key</p><p>​    返回给定key的剩余存活时间，-1代表永久有效，-2代表过期无效</p></li><li><p>PEXPIRE key milliseconds (毫秒)</p><p>​    为给定的key设置过期时间（豪秒）</p></li><li><p>PTTL key</p><p>​    返回给定key的剩余存活时间,毫秒计算</p></li><li><p>PERSIST key</p><p>​    移除key的过期时间，设置持久</p></li><li><p>KEYS pattern</p><p>​    查找所有符合给定模式的key 。*代表所有  ?代表一个规范</p></li><li><p>RENAME key newkey</p><p>​    重命名key</p></li><li><p>MOVE key db</p><p>​    移动当前数据库的key到指定数据库</p></li><li><p>TYPE key</p><p>返回key所存储value的值</p></li></ul><h2 id="数据库命令"><a href="#数据库命令" class="headerlink" title="数据库命令"></a>数据库命令</h2><p>​    Redis默认16个数据库，通过整数索引标识，默认情况连接到数据库0</p><ul><li><p>select 数据库索引  </p><p>​    数据库切换</p></li><li><p>move key  数据库索引  </p><p>​    将单前key移动到另外的数据库</p></li><li><p>flushdb</p><p>​    清除当前数据的所有key</p></li><li><p>flushall</p><p>​    清除所有数据库的key</p></li></ul><h1 id="Redis常用数据类型"><a href="#Redis常用数据类型" class="headerlink" title="Redis常用数据类型"></a>Redis常用数据类型</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>介绍</strong></p><p>​        String是redis最基本的数据类型，是二进制安全的，意味着redis的string可以包含任何数据，比如jpg图片或者序列化对象。</p><p><strong>String命令</strong></p><ul><li><p>SET key value</p><p>​    设置给定的value值，如果key存在则覆盖旧值</p></li><li><p>SETNX  key value</p><p>​    只有key不存在时才进行设置</p></li><li><p>GET key</p><p>​    获取指定的key值，如果key不存在返回nil，如果key存储的不是string类型，返回一个错误</p></li><li><p>GETRANGE key start end</p><p>​    用于获取存储在key中字符串的子字符串，字符串的截取范围由start和end决定（包括start和end）</p></li><li><p>GETBIT key offset</p><p>​    对key所存储的字符串，获取指定偏移量上的位</p></li><li><p>MGET key1 key2….</p><p>​    获取多个key的值</p></li><li><p>GETSET  key  value</p><p>​    用于设置指定key的值并返回旧值，如果key之前不存在则返回nil</p></li><li><p>STRLEN  key</p><p>​    返回key对应字符串的长度</p></li><li><p>DEL key</p><p>​    删除指定的key</p></li><li><p>INCRBY key [增量值]</p><p>​    将存储数字自增（默认1），如果key不存在则初始化位0再进行自增</p></li><li><p>DECR key [减值]</p></li><li><p>APPEND key value</p><p>将指定value追加到存储值末尾</p></li></ul><p><strong>应用场景</strong></p><ol><li>string通常用于保存单个字符或者json字符串数据</li><li>因为string的二进制安全的，所以可以保存图片文件的内容当作字符串来存储</li><li>计数器 （例如：粉丝数、登陆错误次数记录）</li></ol><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p><strong>介绍</strong></p><p>​        hash是一个string类型的field和value的映射表，hash特别适合存储对象，Redis每个hash可以存储2^32^-1键值对</p><p><strong>Hash命令</strong></p><ul><li><p>HSET key  field value [field value field value……]</p><p>​    设置一对或多对键值到key中</p></li><li><p>HGET key field</p><p>​    获取key中field对应的值</p></li><li><p>HMGET key filed filed…. </p><p>​    获取key中多个field的值</p></li><li><p>HGETALL key </p><p>​    返回key中所有的字段和值</p></li><li><p>HKEYS key</p><p>​    获取key中所有的字段</p></li><li><p>HLEN key  </p><p>​    获取哈希表中的字段数量</p></li><li><p>HDEL key field [field….]</p><p>​    删除一个或多个HASH表字段</p></li></ul><p><strong>应用场景</strong></p><p>​        基于hash的特性，我们可以用hash类型来存储java bean对象</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><strong>介绍</strong></p><p>​        Redis中的List是简单的字符串列表，按照插入的顺序排序，可以添加一个元素到列表的左边或右边。一个列表最多可以包含2^32-1个元素。</p><p><strong>List命令</strong></p><ul><li><p>LPUSH key value [value…….]</p><p>将一个或多个值插入列表左侧</p></li><li><p>RPUSH key value [value…….]</p><p>​    将一个或多个值插入列表右侧</p></li><li><p>LPUSHX key value </p><p>​    将一个值插入列表左侧，如果列表不存在则无效</p></li><li><p>RPUSHX key value </p><p>​    将一个值插入列表右侧，如果列表不存在则无效</p></li><li><p>LLEN key</p><p>​    获取列表长度</p></li><li><p>LINDEX key index</p><p>​    获取列表指定下标的的元素</p></li><li><p>LRANGE key start end</p><p>​    获取列表指定范围内的值（0表示第一个元素，1表示第二个元素，-1代表最后一个元素，-2代表倒数第二个元素）</p></li><li><p>LPOP </p><p>​    从左侧获取并移除第一个元素</p></li><li><p>RPOP </p><p>​    从右侧获取并移除第一个元素</p></li><li><p>BLPOP key [key2…] timeout(秒)</p><p>​    阻塞地移除并获取第一个元素,直到超时或者发现可弹出数据</p></li><li><p>BRPOP key [key2…] timeout(秒)</p><p>​    阻塞地移除并获取右侧第一个元素,直到超时或者发现可弹出数据</p></li><li><p>LTRIM key start end</p><p>​    对列表进行修剪，不在区间内的元素将被删除</p></li><li><p>LSET key index value</p><p>​    对指定索引的元素进行设置</p></li><li><p>LINSERT key BEFORE | AFTER word value</p><p>​    将value插入列表中，位于值world之前或之后</p></li><li><p>RPOPLPUSH  source destination</p><p>​    移除列表的最后一个元素并添加到另一个列表返回</p></li><li><p>BRPOPLPUSH  source destination timeout</p><p>​    阻塞地进行</p></li></ul><p><strong>应用场景</strong></p><ol><li><p>对数据量大的集合进行数据删减</p><p>​    数据列表显示、关注列表、粉丝列表‘、留言评价、热点新闻</p></li><li><p>任务队列</p><p>​    list可以用来实现一个消息队列，而且可以确保先后顺序</p></li></ol><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><strong>介绍</strong></p><p>​        Redis的set是String类型的无序集合。集合的成员是唯一的。Redis中的集合是通过哈希来实现的，所以添加，删除，查找的复杂的都是O(1)。集合中最大成员数为2^32^-1。</p><p><strong>Set命令</strong></p><ul><li><p>SADD key value [value]</p><p>​    往集合中存储一个或多个成员</p></li><li><p>SCARD key</p><p>​    获取集合成员个数</p></li><li><p>SMEMBERS key</p><p>​    获取集合中所以成员</p></li><li><p>SISMEMBER key value</p><p>​    判断集合中是否存在某个value</p></li><li><p>SRANDMEMBER key [count]</p><p>​    随机返回集合中一个或多个成员</p></li><li><p>SREM key value [value…]</p><p>​    移除集合中一个或多个成员</p></li><li><p>SPOP key [count]</p><p>​    随机移除并返回集合中的一个元素</p></li><li><p>SMOVE source destination value</p><p>​    将value从source集合移到destination集合</p></li><li><p>SDIFF key1 [key2]</p><p>​    返回所有给定集合的差集</p></li><li><p>SDIFF destination key1 [key2]</p><p>​    返回所有给定集合的差集,并存放在destination 中</p></li><li><p>SINTER key1 [key2]</p><p>​    返回所有给定集合的交集</p></li><li><p>SINTER destination key1 [key2]</p><p>​    返回所有给定集合的交集,并存放在destination 中</p></li><li><p>SUNION key1 [key2]</p><p>​    返回所有给定集合的并集</p></li><li><p>SUNION destination key1 [key2]</p><p>​    返回所有给定集合的并集,并存放在destination 中</p></li></ul><p><strong>应用场景</strong></p><p>​        常用于两个集合数据之间的交叉并运算</p><ol><li>方便实现如共同关注、共同喜好、二度好友功能</li><li>利用唯一性可以统计网站的独立ip</li></ol><h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><p><strong>介绍</strong></p><p>​        不同于set，zset中每个元素都会关联一个double类型的分数，redis通过分数为元素中的成员进行排序，分数（score）可以重复。</p><p><strong>Zset命令</strong></p><ul><li><p>ZADD key score1 value1 [score2 value2]</p><p>​    向有序集合添加一个或多个成员，或者更新分数</p></li><li><p>ZCARD key</p><p>​    获取有序集合成员个数</p></li><li><p>ZCOUNT key min max</p><p>​    计算在有序集合中指定区间分数的成员数</p></li><li><p>ZRANK key value</p><p>​    返回有序集合中指定成员的索引</p></li><li><p>ZRANGE key start stop [WITHSCORES] </p></li></ul><p>​           返回有序集合中指定区间的成员(从低到高)</p><ul><li><p>ZREVRANGE key start stop [WITHSCORES] </p><p>​    返回有序集合中指定区间的成员(从高到低)</p></li><li><p>ZREM key value [value]</p><p>​    移除一个或多个元素</p></li><li><p>ZREMRANGEBYRANK key start stop</p><p>​    移除排名区间的元素（第一个为0）</p></li><li><p>ZREMRANGEBYSCORE key min max</p></li></ul><p>​            移除分数区间的元素</p><p><strong>应用场景</strong></p><ol><li>存储学生的成绩 value可以是学号，score为分数，这样就可以做到动态排序</li><li>还可以用zset来做带权重的队列，通过score来排序</li></ol><hr><h1 id="Java整合Redis"><a href="#Java整合Redis" class="headerlink" title="Java整合Redis"></a>Java整合Redis</h1><p><strong>通过Jedis访问Redis</strong></p><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试连接</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@org.junit.Test</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//连接远程redis</span></span><br><span class="line">       Jedis jedis = <span class="keyword">new</span> Jedis(ip地址,端口号);</span><br><span class="line">       <span class="comment">//权限验证</span></span><br><span class="line">       jedis.auth(密码);</span><br><span class="line">   </span><br><span class="line">       System.out.<span class="built_in">println</span>(jedis.ping());</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>使用SpringData提供的RedisTemplate</strong></p><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置RedisTemplate（采用注解）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Redis数据源配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisPoolConfig <span class="title">jedisPoolConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">100</span>);<span class="comment">//最大连接数</span></span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">20</span>);<span class="comment">//最大空闲数</span></span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);<span class="comment">//最大连接等待时间</span></span><br><span class="line">        poolConfig.setTestOnBorrow(<span class="keyword">true</span>);<span class="comment">//是否在取出连接前进行检验，如果检验失败则重新获取</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> poolConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring-Redis连接池工厂配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisConnectionFactory <span class="title">jedisConnectionFactory</span><span class="params">(JedisPoolConfig jedisPoolConfig)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        JedisConnectionFactory jedisConnectionFactory = <span class="keyword">new</span> JedisConnectionFactory(jedisPoolConfig);</span><br><span class="line">        jedisConnectionFactory.setHostName(ip地址);</span><br><span class="line">        jedisConnectionFactory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        jedisConnectionFactory.setPort(<span class="number">6379</span>);</span><br><span class="line">        <span class="keyword">return</span> jedisConnectionFactory;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取RedisTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate <span class="title">redisTemplate</span><span class="params">(JedisConnectionFactory jedisConnectionFactory)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">        RedisTemplate&lt;String, String&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">        redisTemplate.setConnectionFactory(jedisConnectionFactory);</span><br><span class="line">     redisTemplate.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        redisTemplate.setValueSerializer(stringRedisSerializer);</span><br><span class="line">        redisTemplate.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(stringRedisSerializer);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>  redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Redis分布订阅"><a href="#Redis分布订阅" class="headerlink" title="Redis分布订阅"></a>Redis分布订阅</h1><p>​        Redis分布订阅（pub/sub）是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。Redis客户端可以订阅任意数量的频道</p><p><img src="https://s2.ax1x.com/2020/02/20/3Z4Jkq.png" alt="image"></p><p><strong>订阅频道</strong></p><ul><li>SUBSCRIBE channel [channel..] 订阅一个或多个频道</li><li>PSUBSCRIBE pattern [pattern..] 订阅一个或多个给定模式的频道</li></ul><p><strong>发布频道</strong></p><ul><li>PUBLISH channel message 将消息发布到指定的频道</li></ul><p><strong>退订频道</strong></p><ul><li><p>UNSUBSCRIBE  channel [channel..]   退订一个或多个频道</p></li><li><p>PUNSUBSCRIBE pattern [pattern..] 退订一个或多个给定模式的频道</p></li></ul><p><strong>应用场景</strong></p><p>这一个功能可以用于各种实时消息系统，比如即时聊天，群聊等功能</p><h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><p><strong>事务介绍</strong></p><p>​        Redis的事务可以一次执行多个命令(允许在一次单独的步骤中执行一组命令)，批量操作在exec命令前被放入队列缓存，收到exec命令后进入事务执行，事务中的任意命令失败，其余命令依然被执行。并且具有以下两个特性。</p><ol><li>Redis会将一个事务的所有命令序列化，然后按顺序执行。</li><li>执行中不会被其他命令插入</li></ol><p>​        一个事务从开始到执行会经历以下三个阶段：开始事务&gt;命令入列&gt;执行事务</p><p><strong>事务命令</strong></p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">DISCARD</td><td align="center">取消事务，放弃执行事务块内的所有命令</td></tr><tr><td align="center">EXEC</td><td align="center">执行所有事务块内的命令</td></tr><tr><td align="center">MUTL</td><td align="center">标记一个事务块的开始</td></tr><tr><td align="center">UNWATCH</td><td align="center">取消watch命令对所有key的监视</td></tr><tr><td align="center">WATCH key [key..]</td><td align="center">监视一个或多个key，如果在事务执行前这些key被其他命令所改动，那么事务将被打断</td></tr></tbody></table><p><strong>事务错误处理</strong></p><p>​        Redis只有对报告错误进行事务回滚，什么叫报告错误？就是比如我在事务里写了 setww a 1这样一条命令，这条命令是无法执行成功的因为命令本身就不合法，所引发的错误。</p><p>​        Redis对于逻辑的错误，只会取消逻辑错误的语句，而不会进行事务回滚。比如 set a bb ； incrby a  。这样的命令就是逻辑错误。</p><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>​    <code>Redis有两种持久化机制：RDB、AOF</code></p><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>​        RDB是redis默认的持久化机制，相当于快照。这种方式就是将内存中的数据以快照的方式写入二进制文件中。默认文件名：dump.rdb</p><p><strong>快照条件</strong></p><ol><li>服务器正常关闭  ./bin/redis-cli shutdown</li><li>执行save(阻塞 保存快照) ；执行bgsave (异步保存)</li><li>flushall命令</li><li>满足redis.conf中save配置条件</li></ol><p><strong>相关配置</strong></p><ul><li><p>save <seconds> <change></p><p>​    指定在多次时间内有多少次更新操作，就将数据同步到数据文件中，可以多条件配合</p><p>​    save 900 1                900秒内有1个更改</p><p>​    save 300  10             300秒内有10个更改</p><p>​    save  60    10000      60秒内有10000个更改</p></li><li><p>rdbcompression </p><p>​    指定存储至本地数据库的时候是否采用LZF压缩，默认为true。如果设置成no可以节省cpu时间，但数据库文件会变大。</p></li><li><p>dbfilename</p><p>​    指定数据库文件名，默认为dump.rdb</p></li><li><p>dir ./</p><p>​    指定数据库文件存放位置</p></li></ul><p><strong>优点</strong></p><ul><li>快照保存数据极快，还原数据极快，适用于灾难备份</li><li>如果对数据完整性一致性要求不高，RDB是很好的选择</li></ul><p><strong>缺点</strong></p><ul><li>小内存机器不适合使用，因为执行rdb快照的时候redis会fork一个进程进行保存工作。</li><li>数据完整性一致性不高，因为RDB最后一次备份有可能宕机</li></ul><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>​        不同于RDB的快照方式，采用AOF可以更好地保证数据的完整性。redis会将每一个收到的写命令通过write函数追加到文件中（默认是appendonly.aof）。当redis重启时，会通过执行文件中的写命令来重建数据库的内容。</p><p><strong>触发条件</strong></p><p>​        根据appendfsync配置策略进行触发</p><p><strong>相关配置</strong></p><ul><li><p>appendonly on</p><p>​    指定是否每次在更新后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断点时导致一段时间的数据丢失。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会有一段时间内只存在于内存中。默认为no</p></li><li><p>appendfilename appendonly.aof</p><p>​    指定更新日志文件名</p></li><li><p>appendfsync</p><p>​    指定更新日志条件：</p><ul><li>no  表示等操作系统进行数据缓存同步到磁盘</li><li>always  表示每次更新后手动调用fsync()将数据写到磁盘 (慢，安全)</li><li>everysec   表示每秒同步一次</li></ul><table><thead><tr><th align="center">参数</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">always</td><td align="center">不丢失数据</td><td align="center">IO开销大</td></tr><tr><td align="center">everysec</td><td align="center">每秒进行与fsync，最多丢失1秒数据</td><td align="center">可能丢失1秒数据</td></tr><tr><td align="center">no</td><td align="center">不需要redis管控</td><td align="center">不可控</td></tr></tbody></table></li></ul><p><strong>AOF重写</strong></p><p>​        由于AOF的追加命令特点，文件一般会比RDB大而且很多是无用的命令。所以redis支持AOF重写优化存储文件。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto</span>-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line"><span class="built_in">auto</span>-aof-rewrite-min-size <span class="number">64</span>mb</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>数据完整性和一致性更高</li></ul><p><strong>缺点</strong></p><ul><li>因为AOF记录的内容多，文件会越来越大，数据恢复也会越来越慢。</li></ul><h1 id="RDB和AOF对比"><a href="#RDB和AOF对比" class="headerlink" title="RDB和AOF对比"></a>RDB和AOF对比</h1><table><thead><tr><th></th><th align="center">RDB</th><th align="center">AOF</th></tr></thead><tbody><tr><td>启动优先级</td><td align="center">低</td><td align="center">高</td></tr><tr><td>文件体积</td><td align="center">小</td><td align="center">大</td></tr><tr><td>恢复速度</td><td align="center">快</td><td align="center">慢</td></tr><tr><td>数据安全性</td><td align="center">不太高有可能丢失数据</td><td align="center">根据策略决定</td></tr></tbody></table><h1 id="Redis缓存与数据库一致性"><a href="#Redis缓存与数据库一致性" class="headerlink" title="Redis缓存与数据库一致性"></a>Redis缓存与数据库一致性</h1><h2 id="实时同步"><a href="#实时同步" class="headerlink" title="实时同步"></a>实时同步</h2><p>​        对一致性比较高的，应采用实时同步方案。即查询缓存查询不到直接查询数据库，保存缓存。更新缓存时，先更新数据库，再设置缓存过期（建议不要更新缓存内容）。</p><p>​        </p><h2 id="异步队列"><a href="#异步队列" class="headerlink" title="异步队列"></a>异步队列</h2><p>​        对于并发程度较高的，可以采用异步队列的方式同步，采用消息中间件来处理消息。</p><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="主从复制的搭建"><a href="#主从复制的搭建" class="headerlink" title="主从复制的搭建"></a>主从复制的搭建</h2><p>​        Redis要实现主从复制架构非常简单，主服务器不需要做任何修改，只需要对从服务器做相应的配置就可以了。</p><p>创建一个从服务器（配置文件需要做相应的修改）</p><p><strong>第一种方式</strong>（通过命令）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/redis-server ./redis.conf -port <span class="number">6380</span> -slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><p><strong>第二种方式</strong>（通过修改配置文件）</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">replicaof</span> 主机<span class="built_in">ip</span> 主机port</span><br></pre></td></tr></table></figure><h2 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h2><ul><li>数据备份：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务实现故障转移；实际上是一种服务冗余</li><li>负载均衡：在主从复制的基础上实现读写分离，由主节点提供写服务，从节点提供读服务，提高Redis的并发能力</li><li>高可用基石：主从复制的哨兵模式和集群实现的基础</li></ul><h2 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h2><p>​        Salve启动成功并连接到master后，会发送一个sync同步命令给主机</p><p>​        Master接收到sync命令后，会在后台启动存盘进程，同时收集所有的修改数据的命令，在后台执行完毕后，<strong>master将整个数据传到salve中，完成一次全量复制</strong>。之后Master继续将修改数据的命令传给salve，完成增量复制。</p><h1 id="Redis-Cluster集群"><a href="#Redis-Cluster集群" class="headerlink" title="Redis Cluster集群"></a>Redis Cluster集群</h1><p>​        Redis3.0之后支持redis-cluster,至少<strong>3(master)+3(slave)</strong>才能建立集群。Redis-Cluster采用无中心化结构，每个节点保存数据和整个集群状态，每个节点都和其他节点连接。</p><p><strong>搭建流程</strong></p><ol><li><p>创建Redis节点安装目录</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /usr/<span class="built_in">local</span>/redis_cluster</span><br></pre></td></tr></table></figure></li><li><p>在redis_cluster目录下创建6个安装文件夹</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="number">7001</span> <span class="number">7002.</span>...<span class="number">.7006</span></span><br></pre></td></tr></table></figure></li><li><p>将redis-conf分别拷贝到安装文件夹下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp  <span class="regexp">/usr/</span>src<span class="regexp">/redis-4.0.1/</span>redis.conf <span class="regexp">/usr/</span>local<span class="regexp">/redis-cluster/</span><span class="number">7001</span></span><br></pre></td></tr></table></figure></li><li><p>分别修改配置文件</p><p><strong>protected-mode</strong>是为了禁用公网外部访问redis cache。启用条件有两个</p><ol><li>没有bind IP</li><li>没有设置访问密码</li></ol><p>如果希望外部访问需要将protected-mode设置为no</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bind 192.168.127.130 <span class="comment">//绑定服务器ip地址</span></span><br><span class="line">port 7001 <span class="comment">//绑定端口号，区分redis实例</span></span><br><span class="line">daemonize yes <span class="comment">//后台运行</span></span><br><span class="line">pidfile /<span class="keyword">var</span>/<span class="keyword">run</span>/redis-7001.pid <span class="comment">//修改pid进程文件</span></span><br><span class="line">logfile /root/application/<span class="keyword">program</span>/redis-<span class="keyword">cluster</span>/7001/redis.<span class="keyword">log</span> <span class="comment">//日志文件位置</span></span><br><span class="line"><span class="keyword">dir</span> /root/application/<span class="keyword">program</span>/redis-<span class="keyword">cluster</span>/7001/  <span class="comment">//数据文件存放地址</span></span><br><span class="line"><span class="keyword">cluster</span>-enabled yes <span class="comment">//启用集群</span></span><br><span class="line"><span class="keyword">cluster</span>-config-<span class="keyword">file</span> nodes-7001.<span class="keyword">conf</span> <span class="comment">//配置每个节点的配置文件</span></span><br><span class="line"><span class="keyword">cluster</span>-node-timeout 15000 <span class="comment">//节点超时时间</span></span><br><span class="line">appendonly yes <span class="comment">//启用AOF持久化策略</span></span><br><span class="line">appendfsync always <span class="comment">//AOF追加策略</span></span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>启动各个redis节点</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">#将redis-4.0.1安装目录下的src复制到7001-7006目录下</span></span><br><span class="line">   <span class="keyword">cd</span>  <span class="string">/usr/src/redis-4.0.1/</span></span><br><span class="line">   cp -r <span class="string">./src</span> <span class="string">/usr/loca/redis_cluster/7001</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">#进入各个目录启动redis</span></span><br><span class="line">   <span class="keyword">cd</span> <span class="string">/usr/local/redis_cluster/</span></span><br><span class="line"><span class="string">./7001/src/redis-server</span> <span class="string">./7001/redis.conf</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>创建集群</strong></p><p>​        Redis官方提供了redis-trib.rb来创建集群，就在解压目录src下。我们可以将这个命令复制到/usr/local/bin下方便我们以后使用</p><p>​        然后直接在命令使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">redis-trib</span><span class="selector-class">.rb</span> <span class="selector-tag">create</span> <span class="selector-tag">--replicas</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:7001</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:7002</span> ....</span><br></pre></td></tr></table></figure><p>​        如果出现了<code>ruby :没有那个文件或目录</code>则需要安装ruby</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y <span class="keyword">install </span>ruby ruby-devel rubygems rpm-<span class="keyword">build</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">gem </span><span class="keyword">install </span>redis</span><br></pre></td></tr></table></figure><p>​        如果还出现错误，则是因为Centos默认支持的ruby版本过低，需要安装rvm，再把ruby提升到2.2.2以上</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">gpg --keyserver hkp:<span class="comment">//keys.gnupg.net --recv-keys</span></span><br><span class="line"><span class="number">409</span>B6B1796C275462A1703113804BB82D39DC0E3</span><br><span class="line"><span class="number">7</span>D2BAF1CF37B13E2069D6956105BD0E739499BDB</span><br><span class="line"></span><br><span class="line">curl -sSL http:<span class="comment">//get.rvm.io | bash -s stable</span></span><br><span class="line"></span><br><span class="line">find / -name rvm-print</span><br><span class="line"></span><br><span class="line">source /usr/local/rvm/scripts/rvm</span><br><span class="line"></span><br><span class="line">rvm list known <span class="comment">//查看ruby版本</span></span><br><span class="line"></span><br><span class="line">rvm install <span class="number">2.4</span><span class="number">.4</span></span><br><span class="line"></span><br><span class="line">rvm use <span class="number">2.4</span><span class="number">.4</span> <span class="comment">//使用版本</span></span><br><span class="line"></span><br><span class="line">rvm use <span class="number">2.4</span><span class="number">.4</span> --dafault <span class="comment">//设置默认版本</span></span><br><span class="line"></span><br><span class="line">ruby --version</span><br><span class="line"></span><br><span class="line">gem install redis</span><br></pre></td></tr></table></figure><p><strong>测试集群</strong></p><ol><li><p>启动上面配置的6个redis，使用redis-trib.rb进行搭建</p></li><li><p>连接集群</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">redis-cli</span> <span class="string">-h</span> <span class="number">127.0</span><span class="number">.01</span> <span class="string">-c</span> <span class="string">-p</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -c 连接集群</span></span><br><span class="line"><span class="comment"># -h 由于绑定了ip地址，所有-h不可省略</span></span><br><span class="line"></span><br><span class="line"><span class="string">cluster</span> <span class="string">nodes</span> <span class="comment">#查看集群状态</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>开放端口权限</strong></p><ol><li><p>一次开放端口权限</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --list-ports <span class="comment">#查看已开放端口</span></span></span><br><span class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --zone=public --add-port=7001/tcp --permanent</span></span><br><span class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --reload</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis简介&quot;&gt;&lt;a href=&quot;#Redis简介&quot; class=&quot;headerlink&quot; title=&quot;Redis简介&quot;&gt;&lt;/a&gt;Redis简介&lt;/h1&gt;&lt;p&gt;​        &lt;code&gt;Redis是一个基于内存、支持持久化、的高性能NoSql的key-value数据库。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Redis的特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持数据持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次进行加载。&lt;/li&gt;
&lt;li&gt;数据结构丰富，支持string、list、set、zset、hash…….&lt;/li&gt;
&lt;li&gt;支持数据备份、集群等高可用功能&lt;/li&gt;
&lt;li&gt;性能高 （读速度：110000次/s，写速度：8100次/s）&lt;/li&gt;
&lt;li&gt;原子性，Redis所有操作都是原子性的&lt;/li&gt;
&lt;li&gt;特性丰富，Redis还支持发布/订阅、通知…..&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Redis" scheme="http://liuyoubin.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>JUC笔记</title>
    <link href="http://liuyoubin.top/2020/02/12/backEnd/java/JUC%E7%AC%94%E8%AE%B0/"/>
    <id>http://liuyoubin.top/2020/02/12/backEnd/java/JUC%E7%AC%94%E8%AE%B0/</id>
    <published>2020-02-12T10:00:47.000Z</published>
    <updated>2020-08-20T08:38:37.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC简介"><a href="#JUC简介" class="headerlink" title="JUC简介"></a>JUC简介</h1><p>​        java.util.concurrent包的简称，目的就是为了更好的支持高并发任务，让开发者利用这个包进行的多线程编程时可以有效的减少竞争条件和死锁线程。</p><a id="more"></a><h1 id="Volatile关键字与内存可见性"><a href="#Volatile关键字与内存可见性" class="headerlink" title="Volatile关键字与内存可见性"></a>Volatile关键字与内存可见性</h1><p>　　对于volatile关键字，不少人应该都用过。这个关键字是用于保证共享变量的<strong>“可见性”，禁止指令进行重排序</strong>。</p><p>　　<strong>“可见性”</strong>：可见性是指当多个线程访问同一个共享变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p>　　“<strong>指令重排序”：</strong>对于没有依赖关系的代码，编译器可能会进行指令重排序，优化计算。</p><p>一、可见性</p><p>1.1 为什么需要保证“可见性”</p><p>　　我们知道所有的指令都需要在cpu中执行，而程序数据在运行过程中都是存放在主存中。在这个过程中就会涉及数据的写入与读出。然而cpu与主存的执行速度相差很大，如何cpu与内存之间直接进行数据交换，那么cpu的运行效率将大大降低为此cpu引入了<strong>高速缓存</strong>的概念。在程序运行过程中会将需要交与cpu处理的数据从主存中复制一份放到高速缓存中，而cpu将从高速缓存中读取写入数据，然后将高速缓存中的数据刷新到主存中。正是由于这这个原因才需要确保共享变量的“可见性”。</p><p>　　看下面的这段代码</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">i</span>=i+<span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>　　当程序运行到这段代码时，首先会将从主存中获取到 i 的值然后写到高速缓存中，cpu在高速缓存中读取数据后进行+1操作再写到高速缓存中。最后再从高速缓存将新值刷新到主存中。</p><p>　　这段代码在单线程中运行是没有问题的，然而在多线程线程环境下就可能会出现问题。</p><p>　　例如现在有两个线程1、2同时执行上面这一段代码，i 的初始值为0。预期的结果是i进行了两次+1操作后，值变成2。但是也可能出现另一种情况。</p><p>线程1和线程2将 i 的值写入自己的高速缓存中，线程1进行+1操作后将值写回主存，此时线程2高速缓存中的值还是0，进行+1操作后写回主存。最终 i 的值是1。 这就出现了<strong>缓存一致性</strong>的问题。此时就需要<strong>volatile</strong>来保证可见性。</p><p>1.2 ”volalite“保证一致性的原理</p><p>　　在有”volatile”修饰的共享变量在进行写操作的时候会，出现在汇编代码后面生成一条<strong>Lock</strong>前缀的指令。这条指令会在多核处理器下引发两件事。</p><p>　　<strong>1）Lock前缀指令会引起处理器缓存写回内存</strong></p><p>　　　　 从上面我们知道，内存中的需要运算的数据会被线程复制一份到高速缓存中，再由cup进行运算写回高速缓存，但是何时写回主存就无法得知。如果变量声明了volatile关键字进行了写操作，那么<strong>JVM就会向处理器发送一条Lock前缀的指令</strong>，此时这个变量所在的缓存的数据就会被写进系统内存。但是这样还无法解决缓存一致因为共享变量的其他缓存的值还是旧的，所有就有了第二条。</p><p>　　<strong>2）一个处理器的缓存写回内存会导致其他处理器的缓存无效</strong></p><p>　　　　为了保证各个处理器的缓存是一样的，每个处理器会通过嗅探在总线上传播数据来检查自己的缓存是不是过期了，当处理器发现自己的缓存对应的内存地址被修改，就会将当前处理器的缓存设置为无效状态，当处理器对数据进行操作的时候会重新从主存中读取数据。</p><p>　　</p><p>　　<strong>通过这两件事，volatile实现了变量的可见性。</strong> </p><hr><p>二 、 禁止指令重排序</p><p>2.1 什么是指令重排序</p><p>　　所谓指令重排序就是编译器和处理器为了代码的执行效率会对指令进行重新排序,我们称之为重排序。但是虽然编译器和处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同。</p><p>　　比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;<span class="comment">//语句1</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">20</span>;<span class="comment">//语句2</span></span><br><span class="line"><span class="keyword">int</span> k = i + j; <span class="comment">//语句3</span></span><br></pre></td></tr></table></figure><p>　　上面这段代码，的执行顺序有可能是语句1-&gt;语句2-&gt;语句3，也有可能是语句2-&gt;语句1-&gt;语句3(指令重排)，但是有没有可能是语句3-&gt;语句2-&gt;语句1？</p><p>答案肯定是不。因为语句三的执行依赖 i 和 j 。指令在重排的时候会考虑数据的依赖性。</p><p> 2.1 为什么要禁止指令重排序</p><p>　　指令重排序在单线程的情况下不会影响程序的正确性，那么多线程的情况下呢? 看以下的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();<span class="comment">//语句1</span></span><br><span class="line"><span class="keyword">boolean</span> isTrue= <span class="keyword">true</span>;<span class="comment">//语句2 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isTrue)&#123;<span class="comment">//语句3 </span></span><br><span class="line"></span><br><span class="line">　　a.<span class="keyword">do</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　假设现在有两个线程1、2.线程。由于语句1和语句2没有依赖性，所以线程1有可能先执行语句2，此时线程2判断到isTrue==true认为可以执行语句3，而此时a并没有初始化，所以程序抛出空指针异常。</p><p>　　由此看出指令重排序在单线程下不会有问题，但是在多线程下还是存在问题。</p><p>　　如果我们将isTrue声明为volatile就能禁止处理器指令重排序按照语句1-&gt;语句2的顺序执行。也就是说<strong>在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</strong></p><p>三、注意</p><ul><li>Volatile不保证变量的原子 性</li><li>Volatile不具有互斥性</li></ul><h1 id="原子变量与CAS算法"><a href="#原子变量与CAS算法" class="headerlink" title="原子变量与CAS算法"></a>原子变量与CAS算法</h1><p>一、 原子性问题        </p><p>​        上面说到Volatile不能保证变量的原子性，下面给一个例子说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAtomicDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AtomicDemo demo = <span class="keyword">new</span> AtomicDemo();</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threadPool.submit(demo);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//获取num的数值，然后执行自增操作</span></span><br><span class="line">        System.out.print(getNum()+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        通过测试可以发现存在原子性问题。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>​        为什么呢？因为自增操作其实是三部分组成</p><ul><li><p>从主存中读取数组 int temp = num</p></li><li><p>执行+1操作  temp = temp +1</p></li><li><p>将更新后的值刷回内存  num = temp</p><p>​        Volailte只保证变量的可见性，也就是对变量的修改其他线程可以立即感知，但是在自增操作中+1操作其实是对临时变量执行的，所以无法保证原子性。</p></li></ul><p>二、原子变量</p><p>​        对于原子变量的问题可以使用<strong>java.util.concurrent.atomic</strong> 包下提供的原子变量进行解决。</p><p>对于原子变量而言：</p><ul><li><p>通过Volatile保证可见性</p></li><li><p>通过CAS（Compare-And-Swap）算法保证原子性</p><p><code>CAS是硬件对于并发操作共享数据的支持,包含了内存值V、预估值A、更新值B。当V==A时V=B</code></p></li></ul><h1 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h1><blockquote><p>JUC提供了一套线程安全的集合类，解决以前的集合类在多线程情况下不安全的问题</p></blockquote><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>​        ConcurrentHashMap是jdk5增加的一个线程安全的哈希表，对于多线程操作性能介于HashMap和HashTable之间，内部采用分段锁代替独占锁提高性能。</p><p>​        当期望多线程访问一个容器时：</p><ul><li>ConcurrentHashMap由于同步HashMap</li><li>ConcurrentSkipListMap优于同步TreeMap</li><li>当查询操作多于更新操作时，CopyOnWriteArrayList由于同步ArrayList</li></ul><h1 id="并发辅助类"><a href="#并发辅助类" class="headerlink" title="并发辅助类"></a>并发辅助类</h1><h2 id="同步计数器CountDownLatch"><a href="#同步计数器CountDownLatch" class="headerlink" title="同步计数器CountDownLatch"></a>同步计数器CountDownLatch</h2><p>​        CountDownLatch是一个同步辅助类，它可以在一组线程完成操作之前，让一个或多个线程一直等待。</p><p>​        形象的说CountDownLath就像一个计数发令枪，这样等到计数完成才发令通知线程继续执行。</p><p>​        下面给一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCountDownLatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计数器</span></span><br><span class="line">            CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                threadPool.submit(<span class="keyword">new</span> Demo(countDownLatch));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计数完毕,主线程才继续执行</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"主线程执行"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    Demo(CountDownLatch countDownLatch)&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//执行完毕计数器减1</span></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pool<span class="number">-1</span>-thread<span class="number">-2</span>执行完毕</span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-1</span>执行完毕</span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-5</span>执行完毕</span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-3</span>执行完毕</span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-4</span>执行完毕</span><br><span class="line">主线程执行</span><br></pre></td></tr></table></figure><h2 id="循环屏障CyclicBarrier"><a href="#循环屏障CyclicBarrier" class="headerlink" title="循环屏障CyclicBarrier"></a>循环屏障CyclicBarrier</h2><p>​        CyclicBarrier允许一组线程全部等待彼此到达共同屏障点的同步辅助类。之所以称为循环，是因为它可以在所以线程释放之后，重新使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"召唤神龙成功！"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">7</span> ; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"收集到第："</span>+temp+<span class="string">"颗龙珠"</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h2><p>​        计数信号量，一个信号量维护一组许可证。信号量通常用于限制线程数，而不是访问某种资源。</p><ul><li>acquire() 获得执行，如果已满则等待直到释放</li><li>release()  会将当前信号量+1，唤醒等待的线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//限制线程数量：停车位</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();<span class="comment">//得到</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"抢到车位"</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"离开车位"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();<span class="comment">//释放</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h1><p>​        相较于实现Runnable方法：</p><ul><li>实现Callable接口的call方法可以有返回值以及可以抛出异常</li><li>执行Callable需要FutureTask实现类的支持，用于接受返回结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//采用线程池方式执行</span></span><br><span class="line">        ExecutorService threadPool = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threadPool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">            CallableDemo callableDemo = <span class="keyword">new</span> CallableDemo();</span><br><span class="line">            Future&lt;Integer&gt; future = threadPool.submit(callableDemo);</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//采用直接创建线程方式执行</span></span><br><span class="line">            FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CallableDemo());</span><br><span class="line">            <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">            Integer result = futureTask.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            result += i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="同步锁Lock"><a href="#同步锁Lock" class="headerlink" title="同步锁Lock"></a>同步锁Lock</h1><p>​        这是一种相比于同步代码块和同步方法更加灵活的同步机制。同步锁Lock是一个显示锁，通过lock()和unlock()进行加锁/解锁。</p><p>​        不同于Synchronized隐式锁，Lock要求我们手动释放锁，这一点至关重要，通常我们在finally块中释放，保证锁的释放完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">"1号窗口"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">"2号窗口"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">"3号窗口"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">                lock.lock();<span class="comment">//加锁</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" 售票成功,余票:"</span> + --ticket);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Synchronized和Lock的区别"><a href="#Synchronized和Lock的区别" class="headerlink" title="Synchronized和Lock的区别"></a>Synchronized和Lock的区别</h2><ul><li>Synchronized 内置关键字，Lock是一个接口</li><li>Synchronized 无法判断获取锁的状态，Lock可以获取锁的一个状态</li><li>Synchronized 会自动释放锁（隐式锁），Lock需要手动去释放锁（显式锁）</li><li>Synchronized 会导致线程的阻塞，Lock可以通过设置使得线程超时等待</li><li>Synchronized 是可重入锁，不可终断，非公平锁，Lock可重入锁，可判断，可设置公平</li><li>Synchronized 适合少量代码同步问题，Lock适合代码量多的同步问题</li></ul><h1 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h1><p><strong>通过synchronized关键字实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Clerk clerk = <span class="keyword">new</span> Clerk();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(clerk),<span class="string">"生产者"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(clerk),<span class="string">"消费者"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> product = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(product&gt;=<span class="number">10</span>)&#123; <span class="comment">//为了避免虚假唤醒，wait()方法应该在循环中</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"货物已满！"</span>);</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+ ++product);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(product&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"缺货中！"</span>);</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+ --product);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    Producer(Clerk clerk)&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            clerk.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    Consumer(Clerk clerk)&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            clerk.sale();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>通过Lock同步锁+Condition实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Clerk clerk = <span class="keyword">new</span> Clerk();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(clerk),<span class="string">"生产者"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(clerk),<span class="string">"消费者"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> product = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (product&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"货物已满！"</span>);</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ ++product);</span><br><span class="line">            condition.signalAll();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (product&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"缺货中！"</span>);</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ --product);</span><br><span class="line">            condition.signalAll();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    Producer(Clerk clerk)&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            clerk.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    Consumer(Clerk clerk)&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            clerk.sale();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程按序交替"><a href="#线程按序交替" class="headerlink" title="线程按序交替"></a>线程按序交替</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 实现ABC三个线程交替打印</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadLoop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        LoopDemo loopDemo = <span class="keyword">new</span> LoopDemo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">                loopDemo.loopA(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A线程"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">                loopDemo.loopB(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B线程"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">                loopDemo.loopC(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C线程"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoopDemo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示轮到第几个线程执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loopA</span><span class="params">(<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">1</span>)&#123;<span class="comment">//判断</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"第"</span>+col+<span class="string">"轮 第"</span>+i+<span class="string">"次"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            number=<span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loopB</span><span class="params">(<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">2</span>)&#123;<span class="comment">//判断</span></span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"第"</span>+col+<span class="string">"轮 第"</span>+i+<span class="string">"次"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            number=<span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loopC</span><span class="params">(<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">3</span>)&#123;<span class="comment">//判断</span></span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"第"</span>+col+<span class="string">"轮 第"</span>+i+<span class="string">"次"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            number=<span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="读写锁ReadWriteLock"><a href="#读写锁ReadWriteLock" class="headerlink" title="读写锁ReadWriteLock"></a>读写锁ReadWriteLock</h1><p>​        读写锁维护了一对锁，一个叫读锁一个叫写锁。读锁允许多个线程同时持有，而写锁是独占的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读写锁</span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//加读锁</span></span><br><span class="line">        lock.readLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+num);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加写锁</span></span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自旋锁-SpinLock"><a href="#自旋锁-SpinLock" class="headerlink" title="自旋锁 SpinLock"></a>自旋锁 SpinLock</h1><p>​        是指尝试获取锁失败的线程不会立即阻塞，而是采用<strong>循环的方式去尝试获取锁</strong>，这样的好处是减少线程上下文切换，缺点是会消耗CPU。</p><h2 id="手写自旋锁"><a href="#手写自旋锁" class="headerlink" title="手写自旋锁"></a>手写自旋锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Object&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>, thread));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span> );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="阻塞队列-BlockingQueue"><a href="#阻塞队列-BlockingQueue" class="headerlink" title="阻塞队列 BlockingQueue"></a>阻塞队列 BlockingQueue</h1><p><img src="https://s2.ax1x.com/2020/02/25/3Jx1df.png" alt="image"></p><h2 id="四组API"><a href="#四组API" class="headerlink" title="四组API"></a><strong>四组API</strong></h2><table><thead><tr><th align="center">操作方式</th><th align="center">抛出异常</th><th align="center">返回值，不抛出异常</th><th align="center">阻塞 等待</th><th align="center">超时 等待</th></tr></thead><tbody><tr><td align="center">添加</td><td align="center">add</td><td align="center">offer</td><td align="center">put</td><td align="center">offer(E,timeout,unit)</td></tr><tr><td align="center">移除</td><td align="center">remove</td><td align="center">poll</td><td align="center">take</td><td align="center">poll(timeout,unit)</td></tr><tr><td align="center">判断队列首元素</td><td align="center">element</td><td align="center">peek</td><td align="center"></td><td align="center"></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 抛出异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Object&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="number">1</span>));<span class="comment">//添加成功返回true</span></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="number">2</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="number">3</span>));</span><br><span class="line">        <span class="comment">//队列满,抛出IllegalStateException: Queue full</span></span><br><span class="line">        <span class="comment">//System.out.println(blockingQueue.add(4));</span></span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.remove());<span class="comment">//移除成功返回元素</span></span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        <span class="comment">//队列空,抛出NoSuchElementException</span></span><br><span class="line">        <span class="comment">//System.out.println(blockingQueue.remove());</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 有返回值，不抛出异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tes2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Object&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="number">1</span>));<span class="comment">//添加成功返回true</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="number">2</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="number">3</span>));</span><br><span class="line">        <span class="comment">//队列满,返回false,不抛出异常</span></span><br><span class="line">        <span class="comment">//System.out.println(blockingQueue.offer(4));</span></span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.poll());<span class="comment">//移除成功返回元素</span></span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        <span class="comment">//队列空,返回null,不抛出异常</span></span><br><span class="line">        <span class="comment">//System.out.println(blockingQueue.poll());</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 阻塞等待</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Object&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        blockingQueue.put(<span class="number">1</span>);</span><br><span class="line">        blockingQueue.put(<span class="number">2</span>);</span><br><span class="line">        blockingQueue.put(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//队列满,阻塞等待</span></span><br><span class="line">        <span class="comment">//System.out.println(blockingQueue.put(4));</span></span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.take());<span class="comment">//移除成功返回元素</span></span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        <span class="comment">//队列空,阻塞等待</span></span><br><span class="line">        <span class="comment">//System.out.println(blockingQueue.take());</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Object&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        blockingQueue.offer(<span class="number">1</span>);</span><br><span class="line">        blockingQueue.offer(<span class="number">2</span>);</span><br><span class="line">        blockingQueue.offer(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//队列满,超时等待  时间到后依然无法插入则返回false</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="number">4</span>,<span class="number">5</span>,TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.take());<span class="comment">//移除成功返回元素</span></span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        <span class="comment">//队列空,超时等待   时间到后依然无法取出则返回null</span></span><br><span class="line">        System.out.println(blockingQueue.poll(<span class="number">5</span>, TimeUnit.SECONDS));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>扩展</strong></p><p>​        同步队列<strong>SynchronousQueue</strong>,同步队列与其他队列不同。它不存储元素，每put一个元素后，就必须等待take元素后才能继续put。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>一、 线程池提供了一个线程队列，队列中保存着所有等待的线程, 避免了创建与销毁的额外开销，提高了性能。</p><p>二、 线程池体系结构</p><p><img src="https://s2.ax1x.com/2020/02/13/1O1vC9.png" alt="image"></p><h2 id="三大方法"><a href="#三大方法" class="headerlink" title="三大方法"></a>三大方法</h2><ul><li><p>*<em>ExecutorService   Executors.newFixedThreadPool() *</em> 创建固定大小的线程池</p></li><li><p>*<em>ExecutorService   Executors.newCachedThreadPool() *</em> 创建缓存线程池，大小根据需求自动更改</p></li><li><p>*<em>ExecutorService   Executors.newSingleThreadExecutor() *</em>创建单个线程池，只要一个线程</p></li></ul><p>  除了这三个还有一个是调度线程池</p><p><strong>ScheduledExecutorService   Executors.newScheduledThreadPool</strong>   创建固定大小线程池，可以延迟或定时的执行任务</p><h2 id="七大参数"><a href="#七大参数" class="headerlink" title="七大参数"></a>七大参数</h2><p>​        先看看上面三大创建线程池的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        可以看出本质上都是实例化了ThreadPoolExecutor，只是方法参数不同</p><p>而阿里巴巴开发手册有一点要求就是：</p><blockquote><p>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样 的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 </p><p>说明：Executors 返回的线程池对象的弊端如下： </p><p>1）FixedThreadPool 和 SingleThreadPool: 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 </p><p>2）CachedThreadPool 和 ScheduledThreadPool: 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p></blockquote><p>看看ThreadPoolExecutor的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, //核心线程池大小</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,//最大线程池大小</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,//超时时间，时间过了没人使用就会释放</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,//超时单位</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,//阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,//线程工厂，一般不用改动</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler//拒绝策略)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="四种拒绝策略"><a href="#四种拒绝策略" class="headerlink" title="四种拒绝策略"></a>四种拒绝策略</h2><p><img src="https://s2.ax1x.com/2020/02/25/3tFG6O.png" alt="image"></p><ol><li><p>什么时候会触发拒绝策略呢？</p><p>​    当线程池达到最大承载，还有任务提交到线程池的时候。最大承载: <strong>阻塞队列大小+最大线程数</strong>    </p><p>​    就像下面这段代码，自定义了一个线程池。此线程池的最大承载=<strong>阻塞队列大小+最大线程数</strong>=3+5=8，现在我提交了9个任务，线程池就会触发拒绝策略AbortPolicy，抛出异常。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>,<span class="comment">//核心线程池大小</span></span><br><span class="line">            <span class="number">5</span>,<span class="comment">//最大线程池大小</span></span><br><span class="line">            <span class="number">3</span>,<span class="comment">//超时时间，时间过了没人使用就会释放</span></span><br><span class="line">            TimeUnit.SECONDS,<span class="comment">//超时单位</span></span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),<span class="comment">//阻塞队列</span></span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());<span class="comment">//阻塞队列满了，还有任务添加就抛异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">        threadPool.execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" ok"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>四大拒绝策略的定义</li></ol><table><thead><tr><th align="center">拒绝策略</th><th align="center">执行行为</th></tr></thead><tbody><tr><td align="center">AbortPolicy</td><td align="center">抛出异常</td></tr><tr><td align="center">CallerRunsPolicy</td><td align="center">线程池拒绝处理，由提交的线程自行处理</td></tr><tr><td align="center">DiscardPolicy</td><td align="center">丢掉任务，不会抛出异常</td></tr><tr><td align="center">DiscardOldestPolicy</td><td align="center">尝试和最早的任务竞争线程，失败则丢掉任务，不会抛出异常</td></tr></tbody></table><h2 id="小结与拓展"><a href="#小结与拓展" class="headerlink" title="小结与拓展"></a>小结与拓展</h2><ol><li>最大线程数应该定义多少<ul><li>CPU密集型  一般服务器有多少核心线程数就定义多少；可以通过Runtime.getRuntime().availableProcessors()获取</li><li>IO密集型 （ io十分占用资源） 判断程序中十分耗费io的线程数，使得最大线程数&gt;该数目</li></ul></li></ol><h1 id="手写线程池"><a href="#手写线程池" class="headerlink" title="手写线程池"></a>手写线程池</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedSizeThreadPool</span> </span>&#123;</span><br><span class="line"><span class="comment">//1.需要有一个仓库来存放提交的任务</span></span><br><span class="line"><span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; blockingQueue;</span><br><span class="line"><span class="comment">//2.需要有一个线程的集合</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Thread&gt; workers;</span><br><span class="line">    <span class="comment">//3.标志线程池的工作状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isWorking = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//4.需要有一个人来干活</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> FixedSizeThreadPool pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(FixedSizeThreadPool pool)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.pool = pool;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//希望它能够不断地向仓库拿东西</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">this</span>.pool.isWorking||<span class="keyword">this</span>.pool.blockingQueue.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">Runnable task = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.pool.isWorking) &#123;</span><br><span class="line">                        <span class="comment">//阻塞地从队列拿取任务</span></span><br><span class="line">task = <span class="keyword">this</span>.pool.blockingQueue.take();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//非阻塞地拿取任务，队列为空则返回null</span></span><br><span class="line">task = <span class="keyword">this</span>.pool.blockingQueue.poll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(task!=<span class="keyword">null</span>) &#123;</span><br><span class="line">task.run();</span><br><span class="line">System.out.println(<span class="string">"线程："</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.需要进行线程池初始化---规定仓库的大小和集合的大小，同时把线程准备好</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FixedSizeThreadPool</span><span class="params">(<span class="keyword">int</span> poolSize,<span class="keyword">int</span> taskSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(poolSize&lt;=<span class="number">0</span>||taskSize&lt;=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"非法参数"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.blockingQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(taskSize);</span><br><span class="line"><span class="keyword">this</span>.workers = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;poolSize;i++) &#123;</span><br><span class="line">Worker worker = <span class="keyword">new</span> Worker(<span class="keyword">this</span>);</span><br><span class="line">worker.start();</span><br><span class="line">workers.add(worker);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6，向仓库存放任务(非阻塞)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">submit</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.isWorking) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.blockingQueue.offer(task);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//7，向仓库存放任务(阻塞)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.blockingQueue.put(task);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//8.关闭线程池</span></span><br><span class="line"><span class="comment">//关闭前，不能让新线程进来</span></span><br><span class="line"><span class="comment">//关闭前，要让仓库中的东西执行完</span></span><br><span class="line"><span class="comment">//关闭的时候，如果再去仓库拿东西，就不能再阻塞了</span></span><br><span class="line"><span class="comment">//关闭的时候，如果线程已经阻塞，那么就全部中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.isWorking = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//到线程集合里面，判断线程状态</span></span><br><span class="line"><span class="keyword">for</span>(Thread thread:workers) &#123;</span><br><span class="line"><span class="keyword">if</span>(thread.getState().equals(Thread.State.WAITING)||thread.getState().equals(Thread.State.BLOCKED)) &#123;</span><br><span class="line">thread.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h1><blockquote><p>集合和数据库是负责存储的</p><p>计算应该交给流来处理</p></blockquote><p><strong>流式计算</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 看一道题,必须使用一行代码实现</span></span><br><span class="line"><span class="comment">    * 现在有五个用户,筛选</span></span><br><span class="line"><span class="comment">    * 1. ID必须是偶数</span></span><br><span class="line"><span class="comment">    * 2. 年龄必须大于23岁</span></span><br><span class="line"><span class="comment">    * 3. 用户名转成大写字母</span></span><br><span class="line"><span class="comment">    * 4. 用户名字母倒着排序</span></span><br><span class="line"><span class="comment">    * 5. 只输出一个用户</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       User u1 = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"a"</span>,<span class="number">21</span>);</span><br><span class="line">       User u2 = <span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">"b"</span>,<span class="number">24</span>);</span><br><span class="line">       User u3 = <span class="keyword">new</span> User(<span class="number">3</span>,<span class="string">"c"</span>,<span class="number">23</span>);</span><br><span class="line">       User u4 = <span class="keyword">new</span> User(<span class="number">4</span>,<span class="string">"d"</span>,<span class="number">24</span>);</span><br><span class="line">       User u5 = <span class="keyword">new</span> User(<span class="number">5</span>,<span class="string">"e"</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">       List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//lambda表达式、链式编程、函数式接口、Stream流计算</span></span><br><span class="line">       list.stream()</span><br><span class="line">               .filter(u-&gt;&#123; <span class="keyword">return</span> (u.getId()&amp;<span class="number">1</span>)==<span class="number">0</span>; &#125;)</span><br><span class="line">               .filter(u-&gt;&#123;<span class="keyword">return</span> u.getAge()&gt;<span class="number">23</span>;&#125;)</span><br><span class="line">               .map(u-&gt;&#123;<span class="keyword">return</span> u.getName().toUpperCase();&#125;)</span><br><span class="line">               .sorted((uu1,uu2)-&gt;&#123;<span class="keyword">return</span> uu2.compareTo(uu1);&#125;)</span><br><span class="line">               .limit(<span class="number">1</span>)</span><br><span class="line">               .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h1><p>​        ==分支合并框架，把大任务拆成小任务！并发执行任务提高效率！==</p><p><img src="https://s2.ax1x.com/2020/02/25/3tfF1O.png" alt="image"></p><p><strong>例子与对比</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long start;</span><br><span class="line">    <span class="keyword">private</span> Long end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//临界值</span></span><br><span class="line">    <span class="keyword">private</span> Long temp = <span class="number">10000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinDemo</span><span class="params">(Long start, Long end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((end-start)&lt;temp)&#123;<span class="comment">//正常计算</span></span><br><span class="line">            Long sum = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (Long i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//forkjoin</span></span><br><span class="line">            Long middle = (end+start)/<span class="number">2</span>;<span class="comment">//中间值</span></span><br><span class="line">            ForkJoinDemo task1 = <span class="keyword">new</span> ForkJoinDemo(start, middle);</span><br><span class="line">            task1.fork();<span class="comment">//拆分任务，把任务压入线程队列</span></span><br><span class="line">            ForkJoinDemo task2 =<span class="keyword">new</span> ForkJoinDemo(middle+<span class="number">1</span>, end);</span><br><span class="line">            task2.fork();<span class="comment">//拆分任务，把任务压入线程队列</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> task1.join()+task2.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===============================测试对比===============================</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Long sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (Long i = <span class="number">1L</span>; i &lt;= <span class="number">100000000L</span>; i++) &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"sum:"</span>+sum+<span class="string">" 耗费时间："</span>+(end-start));<span class="comment">//1091ms</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ForkJoin计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinDemo forkJoinDemo = <span class="keyword">new</span> ForkJoinDemo(<span class="number">1L</span>, <span class="number">100000000L</span>);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(forkJoinDemo);</span><br><span class="line">        Long sum = submit.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"sum:"</span>+sum+<span class="string">" 耗费时间："</span>+(end-start));<span class="comment">//772ms</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并行流计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//这个方法是左开区间，右闭区间</span></span><br><span class="line">        <span class="keyword">long</span> sum = LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">100000000L</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"sum:"</span>+sum+<span class="string">" 耗费时间："</span>+(end-start));<span class="comment">//144ms</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h1><blockquote><p>Future的设计初衷：对将来的某个事件的结果进行建模</p></blockquote><p><img src="https://s2.ax1x.com/2020/02/26/3txny9.png" alt="image"></p><blockquote><p>CompletableFuture是对Future的增强，可以使用来完成异步任务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有返回值的runAsync异步回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//开启一个异步任务</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" runAsync"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"runMain"</span>);</span><br><span class="line"></span><br><span class="line">        completableFuture.get();<span class="comment">//阻塞获取执行结果</span></span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有返回值的supplyAsync异步回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">       CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" supplyAsync"</span>);</span><br><span class="line">            <span class="comment">//int s = 10/0;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Integer integer = completableFuture2.whenComplete((u, t) -&gt; &#123;<span class="comment">//编译时回调</span></span><br><span class="line">            System.out.println(u);<span class="comment">//编译正确返回的结果</span></span><br><span class="line">            System.out.println(t);<span class="comment">//编译失败返回的结果</span></span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;<span class="comment">//编译失败时回调</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">        &#125;).get();</span><br><span class="line"></span><br><span class="line">        System.out.println(integer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><blockquote><p>​        JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。</p><p>​        JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p></blockquote><p><img src="https://s2.ax1x.com/2020/02/26/3UIlid.png" alt="image"></p><p>​        <strong>内存交互操作有八种，虚拟机实现保证每一个操作都是原子性的，不可分的。(对于double、long类型来说load、read、store、write操作在某些平台上允许例外)。</strong></p><ul><li><p>lock（锁定）：作用于主存上的变量，把一个变量表标识为线程独享</p></li><li><p>unlock（解锁）：作用于主存上的变量， 把一个处于锁定的变量释放出来</p></li><li><p>read（读取）：作用于主存上的变量，读取主存上的变量</p></li><li><p>load（载入）：作用于工作内存的变量，将read读取的变量放入工作内存</p></li><li><p>use（使用）：作用于工作内存的变量，把工作内存中的变量传输给执行引擎，每当虚拟机需要使用变量时，使用这个命令</p></li><li><p>assign（赋值）：作用于工作内存的变量，把执行引擎的值放入工作内存的对应变量中</p></li><li><p>store（存储）：作用于主存上的变量，将工作内存的值传到主存</p></li><li><p>write（写入）：将store传输的值存储到主存变量中</p></li></ul><p><strong>JMM对这八种指令，制定了如下操作</strong></p><ul><li><p>不允许read和load、store和write操作之一单独出现。即使用了read必须执行load，使用了store必须执行write</p></li><li><p>不允许线程丢弃它最近的assign操作，即工作内存变量的数据发生变化，必须告知主存</p></li><li><p>不允许一个线程将没有assign的数据同步回主存</p></li><li><p>一个新的变量必须在主存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作前，必须经过assign和load操作</p></li><li><p>一个变量同一时间只有一个变量进行lock操作，多次lock后必须执行相同次数的unlock才能解锁</p></li><li><p>如果对一个变量进行lock操作，回清空所有工作内存中此变量的值，在执行引擎使用该变量时，必须重新load或assign操作初始化变量的值</p></li><li><p>如果一个变量没有被lock，则不能unlock，也不能unlock一个被其他线程锁住的变量</p></li><li><p>对一个变量unlock之前，必须将变量同步回主存</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JUC简介&quot;&gt;&lt;a href=&quot;#JUC简介&quot; class=&quot;headerlink&quot; title=&quot;JUC简介&quot;&gt;&lt;/a&gt;JUC简介&lt;/h1&gt;&lt;p&gt;​        java.util.concurrent包的简称，目的就是为了更好的支持高并发任务，让开发者利用这个包进行的多线程编程时可以有效的减少竞争条件和死锁线程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="并发" scheme="http://liuyoubin.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Java" scheme="http://liuyoubin.top/tags/Java/"/>
    
      <category term="多线程" scheme="http://liuyoubin.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop入门</title>
    <link href="http://liuyoubin.top/2020/02/10/backEnd/bigData/Hadoop%E5%85%A5%E9%97%A8/"/>
    <id>http://liuyoubin.top/2020/02/10/backEnd/bigData/Hadoop%E5%85%A5%E9%97%A8/</id>
    <published>2020-02-10T15:08:12.000Z</published>
    <updated>2020-07-22T07:14:57.749Z</updated>
    
    <content type="html"><![CDATA[<div class="note info">            <p>​        Hadoop入门笔记，Hadoop是一个由Apache基金会开发的分布式系统基础架构，主要解决海量数据存储与海量数据计算分析问题。</p>          </div><a id="more"></a><h1 id="大数据生态概述"><a href="#大数据生态概述" class="headerlink" title="大数据生态概述"></a>大数据生态概述</h1><p><img src="https://s1.ax1x.com/2020/06/20/N1PcXq.png" alt="imgae"></p><ul><li><p>Sqoop：Sqoop是一款开源的工具，主要用于在Hadoop、Hive与传统的数据库(MySql)间进行数据的传递，可以将一个关系型数据库（例如 ：MySQL，Oracle 等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。</p></li><li><p>Flume：Flume是Cloudera提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统，Flume支持在日志系统中定制各类数据发送方，用于收集数据；同时，Flume提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力。</p></li><li><p>Kafka：Kafka是一种高吞吐量的分布式发布订阅消息系统，有如下特性：</p><ul><li>通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。</li><li>高吞吐量：即使是非常普通的硬件Kafka也可以支持每秒数百万的消息。</li><li>支持通过Kafka服务器和消费机集群来分区消息。</li><li>支持Hadoop并行数据加载。</li></ul></li><li><p>Storm：Storm用于“连续计算”，对数据流做连续查询，在计算时就将结果以流的形式输出给用户。</p></li><li><p>Spark：Spark是当前最流行的开源大数据内存计算框架。可以基于Hadoop上存储的大数据进行计算。</p></li><li><p>Oozie：Oozie是一个管理Hdoop作业（job）的工作流程调度管理系统。</p></li><li><p>Hbase：HBase是一个分布式的、面向列的开源数据库。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。</p></li><li><p>Hive：Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的SQL查询功能，可以将SQL语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。</p></li><li><p>R语言：R是用于统计分析、绘图的语言和操作环境。R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。</p></li><li><p>Mahout：Apache Mahout是个可扩展的机器学习和数据挖掘库。</p></li><li><p>ZooKeeper：Zookeeper是Google的Chubby一个开源的实现。它是一个针对大型分布式系统的可靠协调系统，提供的功能包括：配置维护、名字服务、 分布式同步、组服务等。ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p></li></ul><h1 id="Hadoop架构概述"><a href="#Hadoop架构概述" class="headerlink" title="Hadoop架构概述"></a>Hadoop架构概述</h1><p><img src="https://s1.ax1x.com/2020/06/20/N1CtdU.png" alt="image"></p><h2 id="HDFS架构概述"><a href="#HDFS架构概述" class="headerlink" title="HDFS架构概述"></a>HDFS架构概述</h2><ul><li>NameNode（nn）<ul><li>存储文件的元数据，如文件名，文件目录结构、文件属性（生成时间、副本数、文件权限），以及每个文件的块和块所在的DataNote等</li></ul></li><li>DataNode（dn） <ul><li>本地文件存储文件块数据，以及数据块的校验和</li></ul></li><li>Secondary NameNode（2nn）<ul><li>用来监视HDFS状态的辅助后台程序，每隔一段时间获取HDFS元数据的快照</li></ul></li></ul><h2 id="YARN架构"><a href="#YARN架构" class="headerlink" title="YARN架构"></a>YARN架构</h2><ul><li><p>ResourceManager（RM）</p><ul><li>处理客户端请求</li><li>监控NodeManager</li><li>启动或监控ApplicationMaster</li><li>资源的分配与调度</li></ul></li><li><p>NodeManager（NM）</p><ul><li>管理单个节点上的资源</li><li>处理ResourceManager的命令</li><li>处理ApplicationMaster的命令</li></ul></li><li><p>ApplicationMaster（AM）</p><ul><li>负责数据的切分</li><li>为应用程序申请资源，并分配给内部的任务</li><li>任务的监控与容错</li></ul></li><li><p>Container</p><ul><li>Container是YARN中资源抽象，封装了某个节点上的维度资源，如内存、cpu、磁盘、网络    </li></ul></li></ul><p><img src="https://s1.ax1x.com/2020/06/19/NMyHhV.png" alt="image"></p><h2 id="MapReduce架构概述"><a href="#MapReduce架构概述" class="headerlink" title="MapReduce架构概述"></a>MapReduce架构概述</h2><p><strong>MapReduce将计算过程分为两个阶段，Map和Reduce</strong></p><ol><li>Map阶段并行处理输入的数据</li><li>Reduce阶段对Map结果进行汇总</li></ol><p><img src="https://s1.ax1x.com/2020/06/20/NljQuF.png" alt="image"></p><h1 id="Linux环境准备及安装"><a href="#Linux环境准备及安装" class="headerlink" title="Linux环境准备及安装"></a>Linux环境准备及安装</h1><ol><li><p>准备虚拟机</p></li><li><p>修改相关配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//查看网卡Mac地址</span><br><span class="line">[root@hadoop01 ~]# vim /etc/udev/rules.d/70-persistent-net.rules </span><br><span class="line">//修改ip </span><br><span class="line">[root@hadoop01 ~]# vim /etc/sysconfig/network-scripts/ifcfg-eth0 </span><br><span class="line">//修改主机名</span><br><span class="line">[root@hadoop01 ~]# vim /etc/sysconfig/network</span><br><span class="line">//配置ip、主机映射</span><br><span class="line">[root@hadoop01 ~]# vim /etc/hosts</span><br></pre></td></tr></table></figure></li><li><p>在/opt下创建两个文件夹 module、software</p><ul><li>将jdk和hadoop的jar包传输到software下</li></ul></li><li><p>安装jdk</p><ul><li><p>将jdk解压到module下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf jdk-8u144-linux-x64.tar.gz -C /opt/module</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入环境配置文件</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">在文件末尾添加</span></span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_144</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">刷新配置</span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li></ul></li><li><p>安装Hadoop</p><ul><li><p>解压hadoop</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf hadoop-2.7.2.tar.gz -C /opt/module/</span><br></pre></td></tr></table></figure></li><li><p>配置环境配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入环境配置文件</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">在文件末尾添加</span></span><br><span class="line">export HADOOP_HOME=/opt/module/hadoop-2.7.2</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">刷新配置</span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="Hadoop运行模式"><a href="#Hadoop运行模式" class="headerlink" title="Hadoop运行模式"></a>Hadoop运行模式</h1><p><a href="http://hadoop.apache.org/docs/r2.7.2/" target="_blank" rel="noopener">Hadoop官网手册</a></p><h2 id="本地模式"><a href="#本地模式" class="headerlink" title="本地模式"></a>本地模式</h2><h3 id="Grep案例"><a href="#Grep案例" class="headerlink" title="Grep案例"></a>Grep案例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">切换到hadoop目录下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /opt/module/hadoop-2.7.2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">操作步骤</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir input</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp etc/hadoop/*.xml input</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar grep input output <span class="string">'dfs[a-z.]+'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat output/*</span></span><br></pre></td></tr></table></figure><h3 id="WordCount案例"><a href="#WordCount案例" class="headerlink" title="WordCount案例"></a>WordCount案例</h3><ol><li><p>在hadoop下创建一个wcinput文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir wcinput</span></span><br></pre></td></tr></table></figure></li><li><p>在wcinput下创建一个wc.input文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> wcinput</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch wc.input</span></span><br></pre></td></tr></table></figure></li><li><p>编辑wc.input文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim wc.input </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">在文件中输入一些数据作为测试</span></span><br><span class="line">hadoop yarn</span><br><span class="line">hadoop mapreduce</span><br><span class="line">root</span><br><span class="line">liuyoubin</span><br></pre></td></tr></table></figure></li><li><p>回到hadoop目录执行程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount wcinput wcoutput</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="伪分布式模式"><a href="#伪分布式模式" class="headerlink" title="伪分布式模式"></a>伪分布式模式</h2><h3 id="启动HDFS并运行MapReduce"><a href="#启动HDFS并运行MapReduce" class="headerlink" title="启动HDFS并运行MapReduce"></a>启动HDFS并运行MapReduce</h3><h4 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h4><ol><li><p>配置hadoop-env.sh</p><ul><li><p>获取JDK路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop01 ~]# echo $JAVA_HOME</span><br><span class="line">/opt/module/jdk1.8.0_144</span><br></pre></td></tr></table></figure></li><li><p>修改JAVA_HOME路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_144</span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置：core-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定HDFS中NameNode的地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop01:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定Hadoop运行时产生文件的存储目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/module/hadoop-2.7.2/data/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置：hdfs-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定HDFS副本的数量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h4><ol><li><p>格式化NameNode （第一次启动时需要格式化）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/hdfs namenode -format</span></span><br></pre></td></tr></table></figure></li><li><p>启动NameNode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sbin/hadoop-daemon.sh start namenode</span></span><br></pre></td></tr></table></figure></li><li><p>启动DataNode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sbin/hadoop-daemon.sh start datanode</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="查看集群"><a href="#查看集群" class="headerlink" title="查看集群"></a>查看集群</h4><ol><li><p>查看是否启动成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jps</span></span><br></pre></td></tr></table></figure></li><li><p>访问 ip:50070 能否访问成功</p><p><img src="https://s1.ax1x.com/2020/07/15/UwDX0f.png" alt="image"></p></li></ol><h4 id="集群操作"><a href="#集群操作" class="headerlink" title="集群操作"></a>集群操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在HDFS创建多级目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bin/hdfs dfs -mkdir -p /user/lyb/input</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将Linux本地文件上传到HDFS</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bin/hdfs dfs -put wcinput/wc.input /user/lyb/input</span></span><br></pre></td></tr></table></figure><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ol><li><p><strong>不能一直格式化NameNode</strong></p><p>​        格式化NameNode会产生新的集群id，导致NameNode和DataNode集群id不一样，找不到以往数据。所以格式化NameNode之前要先停止相关进程，清除log和data文件夹数据。</p></li></ol><h3 id="启动YARN并运行MapReduce"><a href="#启动YARN并运行MapReduce" class="headerlink" title="启动YARN并运行MapReduce"></a>启动YARN并运行MapReduce</h3><h4 id="配置集群-1"><a href="#配置集群-1" class="headerlink" title="配置集群"></a>配置集群</h4><ol><li><p>配置yarn-env.sh</p><ul><li><p>修改JAVA_HOME路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> some Java parameters</span></span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_144</span><br><span class="line">if [ "$JAVA_HOME" != "" ]; then</span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="built_in">echo</span> <span class="string">"run java in <span class="variable">$JAVA_HOME</span>"</span></span></span><br><span class="line">  JAVA_HOME=$JAVA_HOME</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置：yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Reducer获取数据的方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定YARN的ResourceManager的地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop01<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>3 . 配置：mapred-env.sh</p><ul><li>配置一下JAVA_HOME</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_144</span><br></pre></td></tr></table></figure><ol start="4"><li><p>配置： (对mapred-site.xml.template重新命名为) mapred-site.xml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mv mapred-site.xml.template mapred-site.xml</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim mapred-site.xml</span></span><br><span class="line"></span><br><span class="line">&lt;!-- 指定MR运行在YARN上 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">&lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></li></ol><h4 id="启动集群-1"><a href="#启动集群-1" class="headerlink" title="启动集群"></a>启动集群</h4><ol><li><p>启动前必须保证NameNode和DataNode已经启动</p></li><li><p>启动ResourceManager</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sbin/yarn-daemon.sh start resourcemanager</span></span><br></pre></td></tr></table></figure></li><li><p>启动NodeManager</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sbin/yarn-daemon.sh start nodemanager</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="集群操作-1"><a href="#集群操作-1" class="headerlink" title="集群操作"></a>集群操作</h4><ol><li><p>YARN的浏览器页面查看 <a href="http://192.168.33.131:8088/cluster" target="_blank" rel="noopener">http://192.168.33.131:8088/cluster</a></p><p><img src="https://s1.ax1x.com/2020/07/17/U6HbTI.png" alt="image"></p></li><li><p>执行MapReduce程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/hadoop jar</span></span><br><span class="line"> share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount /user/lyb/input  /user/lyb/output</span><br></pre></td></tr></table></figure></li><li><p>查看运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/hdfs dfs -cat /user/lyb/output/*</span></span><br></pre></td></tr></table></figure><p><img src="F:%5Cpicture%5Cblog_picture%5CHadoop%E5%85%A5%E9%97%A8%5CU6qfMD.png" alt="image"></p></li></ol><h4 id="配置历史服务器"><a href="#配置历史服务器" class="headerlink" title="配置历史服务器"></a>配置历史服务器</h4><p>​        为了查看程序的历史运行情况，需要配置一下历史服务器。具体配置步骤如下：</p><ol><li><p>配置mapred-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 历史服务器端地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop01:10020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 历史服务器web端地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop01:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>启动历史服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sbin/mr-jobhistory-daemon.sh start historyserver</span></span><br></pre></td></tr></table></figure></li><li><p>查看JobHistory</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">注意本机如果没有做好host映射请使用ip进行访问</span></span><br><span class="line">http://hadoop01:19888/jobhistory</span><br></pre></td></tr></table></figure></li></ol><h4 id="配置日志的聚集"><a href="#配置日志的聚集" class="headerlink" title="配置日志的聚集"></a>配置日志的聚集</h4><p>​        日志聚集概念：应用运行完成以后，将程序运行日志信息上传到HDFS系统上。</p><p>​        日志聚集功能好处：可以方便的查看到程序运行详情，方便开发调试。</p><p>​        <strong>注意：开启日志聚集功能，需要重新启动NodeManager 、ResourceManager和HistoryManager。</strong></p><p>​        开启日志聚集功能具体步骤如下：</p><ol><li><p>配置yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 日志聚集功能使能 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation-enable<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 日志保留时间设置7天 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation.retain-seconds<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>604800<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>关闭NodeManager 、ResourceManager和HistoryManager</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sbin/yarn-daemon.sh stop resourcemanager</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sbin/yarn-daemon.sh stop nodemanager</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sbin/mr-jobhistory-daemon.sh stop historyserver</span></span><br></pre></td></tr></table></figure></li><li><p>启动NodeManager 、ResourceManager和HistoryManager</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sbin/yarn-daemon.sh start resourcemanager</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sbin/yarn-daemon.sh start nodemanager</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sbin/mr-jobhistory-daemon.sh start historyserver</span></span><br></pre></td></tr></table></figure></li><li><p>删除HDFS上已经存在的输出文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/hdfs dfs -rm -r /user/lyb/output</span></span><br></pre></td></tr></table></figure></li><li><p>执行MapReduce程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount /user/lyb/input  /user/lyb/output</span></span><br></pre></td></tr></table></figure></li><li><p>查看日志 <a href="http://192.168.33.131:19888/jobhistory" target="_blank" rel="noopener">http://192.168.33.131:19888/jobhistory</a></p><p><img src="https://s1.ax1x.com/2020/07/17/U6vy3q.png" alt="image"></p><p><img src="https://s1.ax1x.com/2020/07/17/U6v2uT.png" alt="image"></p><p><img src="https://s1.ax1x.com/2020/07/17/U6vvUH.png" alt="image"></p></li></ol><h2 id="完全分布式模式"><a href="#完全分布式模式" class="headerlink" title="完全分布式模式"></a>完全分布式模式</h2>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;
            &lt;p&gt;​        Hadoop入门笔记，Hadoop是一个由Apache基金会开发的分布式系统基础架构，主要解决海量数据存储与海量数据计算分析问题。&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="大数据" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hadoop" scheme="http://liuyoubin.top/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB与MYISAM</title>
    <link href="http://liuyoubin.top/2020/02/10/backEnd/dataBase/InnoDB%E4%B8%8EMYISAM/"/>
    <id>http://liuyoubin.top/2020/02/10/backEnd/dataBase/InnoDB%E4%B8%8EMYISAM/</id>
    <published>2020-02-09T16:31:14.000Z</published>
    <updated>2020-03-18T13:06:07.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a><strong>事务</strong></h2><p><strong>InnoDB支持事务，MyISAM不支持事务</strong></p><p>InnoDB默认将每一条sql语句都封装成事务，在实际开发中最后用具体的事务进行管理</p><a id="more"></a><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a><strong>外键</strong></h2><p><strong>InnoDB支持外键，MyISAM不支持外键</strong></p><h2 id="行级锁与表级锁"><a href="#行级锁与表级锁" class="headerlink" title="行级锁与表级锁"></a><strong>行级锁与表级锁</strong></h2><p><strong>InnoDB支持行级锁和表级锁，MyISAM只支持表级锁</strong></p><p>​        MyISAM的表级锁有两种模式：读锁（共享锁），写锁（排它锁）。所谓读锁就是在对表进行读操作的时候允许其他用户对表进行读操作，而阻塞其他用户对表进行写操作。而写锁就是在对表进行写操作的时候，阻塞其他用户的读操作和写操作。</p><p>​        InnoDB是通过对索引进行加锁实现行级锁的。所以如果不是通过索引条件来进行检索数据会导致行锁失效。在InnoDB两个事务发生死锁的时候，会计算出每个事务影响的行数，然后回滚行数少的那个事务。</p><p>​        比较：</p><ul><li>表锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突概率高，并发度最低</li><li>行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a><strong>索引</strong></h2><p><strong>InnoDB和MYISAM的索引结构都是B+树，不同的是InnoDB是聚集索引而MYISAM非聚集索引</strong></p><h3 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a><strong>B树和B+树</strong></h3><p><img src="https://s2.ax1x.com/2020/02/10/15umVO.png" alt="image"></p><p><img src="https://s2.ax1x.com/2020/02/10/15U3tI.png" alt="image"></p><p><strong>在结构上：</strong>B树的数据都是分布存在整棵树中，而B+树的数据只存放在叶子节点中，非叶子节点只存放数据的索引。</p><p><strong>B+树的优势</strong></p><ul><li><strong>B+树的磁盘读写代价更低</strong>：由于B+的数据都存在叶子节点中，所以每个非叶子节点就可以存放更多的索引信息，树就更加矮胖，IO读写次数也会更少。</li><li><strong>B+树的查询效率更稳定：</strong>由于B+的数据都存在叶子节点中，所以每一次查询的路径长度相同，效率稳定。</li><li><strong>B+树的区间查询更高效</strong>：B树的数据分布存储在整棵树中，所以区间查询效率低。而B+树的所有数据都在叶子节点且叶子节点还指向相邻的叶子节点，这样区间的查找效率就比较高。</li></ul><h3 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a><strong>聚集索引与非聚集索引</strong></h3><p><strong>非聚集索引</strong></p><p>​        所谓的非聚集索引就是指索引文件和数据文件是分离的，索引文件仅保存数据所在的物理地址。索引示例如下：</p><p><img src="https://s2.ax1x.com/2020/02/10/15d8Qf.png" alt="image"></p><p>​        </p><p><strong>聚集索引</strong></p><p>​        所谓聚集，就是指实际数据和主键索引存储在一起。</p><p>对于InnoDB来说：</p><ul><li>主键索引文件既存储索引又存储实际数据</li><li>如果没有指定主键，MySql会指定UniqueKey做主键</li><li>如果没有主键，则生成一个内部列作为主键</li><li>而对于辅助索引，实际存储的是主键值，也就是说会进行两次索引查询</li></ul><p><img src="https://s2.ax1x.com/2020/02/10/15y1AO.png" alt="image"></p><p>​                                                                                                                                                            </p><h2 id="具体行数的保存"><a href="#具体行数的保存" class="headerlink" title="具体行数的保存"></a>具体行数的保存</h2><p>​        InnoDB不保存表的具体行数，也就是说执行<code>select count(*) from  table</code>的时候InnoDB需要遍历整张表来计算，而MyISAM可以直接读出保存的行数</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>对于有事务要求的选择InnoDB，如果不需要可以考虑MyISAM</li><li>对于查询比较多的业务，考虑MyISAM。对于修改、插入操作比较频繁的可以选择InnoDB</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h1&gt;&lt;h2 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;&lt;strong&gt;事务&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;InnoDB支持事务，MyISAM不支持事务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;InnoDB默认将每一条sql语句都封装成事务，在实际开发中最后用具体的事务进行管理&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="数据库" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySql" scheme="http://liuyoubin.top/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>JVM探究</title>
    <link href="http://liuyoubin.top/2020/02/08/backEnd/java/JVM%E6%8E%A2%E7%A9%B6/"/>
    <id>http://liuyoubin.top/2020/02/08/backEnd/java/JVM%E6%8E%A2%E7%A9%B6/</id>
    <published>2020-02-08T09:45:26.000Z</published>
    <updated>2020-03-07T15:39:26.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM位置"><a href="#JVM位置" class="headerlink" title="JVM位置"></a>JVM位置</h1><p><img src="https://s2.ax1x.com/2020/02/28/3Dqzng.png" alt="image"></p><a id="more"></a><h1 id="JVM体系"><a href="#JVM体系" class="headerlink" title="JVM体系"></a>JVM体系</h1><p><img src="https://s2.ax1x.com/2020/02/28/3DXT74.png" alt="image"></p><h1 id="类加载器及双亲委派机制"><a href="#类加载器及双亲委派机制" class="headerlink" title="类加载器及双亲委派机制"></a>类加载器及双亲委派机制</h1><blockquote><p>通过类限定名将类动态地的字节码二进制流加载进JVM</p></blockquote><h2 id="类加载器体系"><a href="#类加载器体系" class="headerlink" title="类加载器体系"></a>类加载器体系</h2><p><img src="https://s2.ax1x.com/2020/02/28/3Djrgx.png" alt="image"></p><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><ol><li>类加载器收到类加载的请求</li><li>自己首先检查是否已经加载过这个类，如果以及加载过则不会加载。否则转到第3步</li><li>先将请求委派给父加载器，一直到启动类加载器</li><li>启动类加载器检查是否可以加载，如果可以则加载，如果无法加载则通知子加载器加载，一直到最下的加载器</li><li>如果所有加载器都无法加载则抛ClassNotFoundException</li></ol><h1 id="GC-Root"><a href="#GC-Root" class="headerlink" title="GC Root"></a>GC Root</h1><p>*<em>JVM如何判断一个对象是不再使用的对象(垃圾)? *</em></p><p>​    使用可达性分析算法，从一系列名为<strong>GC Root</strong>的对象出发，如果待判断的对象没有被GC Root任何引用链相连时，则说明此对象是不可用对象。</p><p><strong>哪些对象可以作为GC Root？</strong></p><ul><li>虚拟机栈（栈帧中的局部变量表）中引用的对象</li><li>方法区中的静态属性引用的对象</li><li>方法区中的常量引用的对象</li><li>本地方法栈中JNI（Native方法）引用的对象</li></ul><h1 id="四大引用"><a href="#四大引用" class="headerlink" title="四大引用"></a>四大引用</h1><p><img src="https://s2.ax1x.com/2020/03/07/3OnaRg.png" alt="image"></p><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>​        当内存不足时，JVM开始回收垃圾，对于强引用的对象，就算是出现OOM也不会对该对象进行回收</p><p>​        强引用就是我们常见的对象引用，当一个对象赋给一个引用变量，垃圾回收器就不回收该对象，强引用是引起OOM的主要原因之一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>​        相对于强引用来说软化了一些，需要实现java.lang.SolfReference类来实现</p><p>​        对于软引用的对象，当<strong>系统内存充足时不会被回收，当系统内存不足时会被回收。</strong>软引用通常用在对内存敏感的程序中，比如高速缓存中就用的软引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> Object());</span><br></pre></td></tr></table></figure><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>​        只要垃圾回收一执行，不管内存是否足够，弱引用的对象都会被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> Object());</span><br></pre></td></tr></table></figure><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>​        形同虚设的引用，如果一个对象仅持有虚引用，那么就和没有任何引用一样，在任何时候都可能被垃圾回收，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列(ReferenceQueue)联合使用。</p><p>​        虚引用的作用主要是跟踪对象被垃圾回收的状态。仅仅是提供一种确保对象被fianlize后，做某些事的机制。PhantomReference的get方法总返回null,其意义在说明一个对象进入到finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作。</p><p>​        换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候收到一个系统通知或者后续进一步处理。在Java中允许使用finalize()方法在垃圾收集器将对象回收之前做必要的清理工作。</p><h2 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h2><p>​        引用队列的作用：当软引用、弱引用、虚引用关联了引用队列，那么当这些引用的对象在被垃圾回收前，引用会被保存在引用队列中。</p><h1 id="GC-垃圾回收"><a href="#GC-垃圾回收" class="headerlink" title="GC 垃圾回收"></a>GC 垃圾回收</h1><h2 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h2><ol><li><p><strong>复制算法</strong></p><p>​        该算法将内存平均分成两部分，然后每次只使用其中的一部分，当这部分内存满的时候，将内存中所有存活的对象复制到另一个内存中，然后将之前的内存清空，只使用这部分内存，循环下去。</p><p>​        这个算法与标记-整理算法的区别在于，该算法不是在同一个区域复制，而是将所有存活的对象复制到另一个区域内。</p></li><li><p><strong>标记-清除算法</strong></p><p>​        为每个对象存储一个标记位，记录对象的状态（活着或是死亡）。</p><p>​        分为两个阶段，一个是标记阶段，这个阶段内，为每个对象更新标记位，检查对象是否死亡；第二个阶段是清除阶段，该阶段对死亡的对象进行清除，执行 GC 操作。</p></li><li><p><strong>标记-整理算法</strong></p><p>​        标记-整理法是标记-清除法的一个改进版。同样，在标记阶段，该算法也将所有对象标记为存活和死亡两种状态；不同的是，在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是将所有存活的对象整理一下，放到另一处空间，然后把剩下的所有对象全部清除。这样就达到了标记-整理的目的。</p></li><li><p><strong>引用计数算法</strong></p><p>​        每个对象在创建的时候，就给这个对象绑定一个计数器。每当有一个引用指向该对象时，计数器加一；每当有一个指向它的引用被删除时，计数器减一。这样，当没有引用指向该对象时，该对象死亡，计数器为0，这时就应该对这个对象进行垃圾回收操作。</p></li></ol><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="https://images2015.cnblogs.com/blog/249993/201703/249993-20170308202431391-1323581863.png" alt="image"></p><ol><li><p><strong>Serial（串行垃圾收集器）</strong></p><p>​        它为单线程环境下设计且只使用一个线程进行垃圾回收，会暂停所有用户线程，不适合服务器环境。</p><p>虽然需要暂停用户线程，但是简单高效，对于单CPU环境比较合适。</p><p><strong>对应JVM参数：-XX:+UseSerialGC</strong></p><p><strong>开启后会使用：Serial+Serial Old的收集器组合</strong></p><p><img src="https://s2.ax1x.com/2020/03/07/3jajXR.png" alt="image"></p></li><li><p><strong>ParNew（并行垃圾收集器）</strong></p><p>​    ParNew是Serial的多线程版本，通常和CMS配合使用，其余行为和Serial一样。</p><p><strong>对应JVM参数：-XX:+UseParNewGC</strong></p><p><strong>开启后会使用：Serial+Serial Old的收集器组合</strong></p><p><img src="F:%5Cpicture%5Cblog_picture%5CJVM%E6%8E%A2%E7%A9%B6%5C3jwnM9-1583590582707.png" alt="image"></p></li><li><p><strong>Parallel(并行垃圾回收器)</strong></p><p>​    多个垃圾收集线程并行工作，同样会暂停用户线程，适用于科学计算/大数据处理等弱交互场景。类似ParNew，俗称吞吐量优先收集器。</p><p><strong>对应JVM参数：-XX:+UseParallerGC或-XX:+UseParallerOldGC（互相激活）</strong></p><p><img src="https://s2.ax1x.com/2020/03/07/3jToHx.png" alt="image"></p><p><img src="https://s2.ax1x.com/2020/03/07/3jwnM9.png" alt="image"></p></li><li><p><strong>Parallel Old</strong>整理</p><p>Parallel的老年代版本，jdk1.6之后提供，关注吞吐量。</p></li><li><p><strong>CMS(并发标记清除)</strong></p></li></ol><p>​        用户线程和GC线程同时执行（不一定并行，可能交替执行），不需要停止用户线程，适用于对响应时间有要求的场景</p><p><img src="https://s2.ax1x.com/2020/03/07/3jqBGT.png" alt="image"></p><ol start="6"><li><strong>G1</strong></li></ol><p>​    G1垃圾回收器将堆内存分割成不同的区域然后并发的对其进行垃圾回收</p><h1 id="JVM常用参数"><a href="#JVM常用参数" class="headerlink" title="JVM常用参数"></a>JVM常用参数</h1><h2 id="查看JVM参数命令"><a href="#查看JVM参数命令" class="headerlink" title="查看JVM参数命令"></a>查看JVM参数命令</h2><ul><li><p>jps -l </p><p>查看当前的java进程</p></li><li><p>jinfo -flag 参数 进程号</p><p>查看某个进程的指定参数开启情况</p></li><li><p>jinfo -flags 进程</p><p>查看某个进程的所以参数开启情况</p></li></ul><hr><ul><li><p>java -XX:+PrintFlagsInitial</p><p>参看初始化参数情况</p></li><li><p>java -XX:+PrintFlagsFinal</p><p>参看修改后参数情况</p></li><li><p>java -XX:+PrintCommandLineFlags -version</p></li></ul><h2 id="标配参数"><a href="#标配参数" class="headerlink" title="标配参数"></a>标配参数</h2><ul><li>-version</li><li>-help</li><li>-showversion</li></ul><h2 id="X参数"><a href="#X参数" class="headerlink" title="X参数"></a>X参数</h2><ul><li>-Xint 解释执行</li><li>-Xcomp 第一次使用就编译成本地代码</li><li>-Xmixed 混合模式</li></ul><h2 id="XX参数"><a href="#XX参数" class="headerlink" title="XX参数"></a>XX参数</h2><h3 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h3><blockquote><p>-XX:+或者-某个参数 （表示开启和关闭）</p></blockquote><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-XX:+PrintGCDetails</td><td align="center">开启打印GC收集细节</td></tr><tr><td align="center">-XX:+UseSerialGC</td><td align="center">使用串行垃圾回收器</td></tr><tr><td align="center">-XX:+HeapDumpOnOutOfMemoryError</td><td align="center">设置当首次遭遇内存溢出时导出此时堆中相关信息</td></tr></tbody></table><h3 id="KV类型"><a href="#KV类型" class="headerlink" title="KV类型"></a>KV类型</h3><blockquote><p> -XX:key=value</p></blockquote><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-XX:InitialHeapSize= (等价于-Xms)</td><td align="center">初始堆内存大小</td></tr><tr><td align="center">-XX:MaxHeapSize= (等价于-Xmx)</td><td align="center">最大堆内存大小</td></tr><tr><td align="center">-XX:ThreadStackSize=(等价于-Xss)</td><td align="center">单个线程栈的大小（默认为512K~1024K）</td></tr><tr><td align="center">-XX:HeapDumpPath=</td><td align="center">指定导出堆信息时的路径或文件名</td></tr><tr><td align="center">-XX:MetaSpace=128M</td><td align="center">设置元空间内存大小</td></tr><tr><td align="center">-XX:MaxTenuringThreshold=15</td><td align="center">设置新生代进行老年代的存活次数</td></tr><tr><td align="center">-XX:SurvivorRatio</td><td align="center">设置eden区和survivor的比例。默认值为8，也就是8:1:1</td></tr><tr><td align="center">-XX:NewRatio</td><td align="center">设置新生代和老年代在堆中的占比,默认值为2。也就是Old:New=2:1</td></tr></tbody></table><h1 id="JVM-堆"><a href="#JVM-堆" class="headerlink" title="JVM 堆"></a>JVM 堆</h1><p><img src="https://s2.ax1x.com/2020/03/06/3LghuQ.png" alt="image"></p><h2 id="MinorGC过程"><a href="#MinorGC过程" class="headerlink" title="MinorGC过程"></a>MinorGC过程</h2><ol><li><p><strong>Eden区和From区上存活的对象复制到SurvivorTo区，存活对象年龄加1</strong></p><p>首先，当Eden区满的时候会触发第一次GC，把还活着的对象拷贝到SurvivorFrom区；当Eden区再次满的时候会扫描Eden区和SurvicorTo区，将存活的对象复制到To区，存活的对象年龄加1</p></li><li><p><strong>清除Eden区和SurvivorFrom的可回收对象</strong></p></li><li><p><strong>SurvivorFrom和SurvivorTo互相交换</strong></p></li></ol><h1 id="GC-日志"><a href="#GC-日志" class="headerlink" title="GC 日志"></a>GC 日志</h1><blockquote><p>可以使用-XX:+PrintGCDetails开启GC日志打印</p></blockquote><p><strong>GC日志图解</strong></p><p><img src="https://s2.ax1x.com/2020/03/06/3L0029.png" alt="image"></p><p><strong>Full GC图解</strong></p><p><img src="https://s2.ax1x.com/2020/03/06/3Lski8.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM位置&quot;&gt;&lt;a href=&quot;#JVM位置&quot; class=&quot;headerlink&quot; title=&quot;JVM位置&quot;&gt;&lt;/a&gt;JVM位置&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/28/3Dqzng.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="Java" scheme="http://liuyoubin.top/tags/Java/"/>
    
      <category term="JVM" scheme="http://liuyoubin.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Spring扩展2-Transaction</title>
    <link href="http://liuyoubin.top/2020/02/07/backEnd/framework/Spring%E6%89%A9%E5%B1%952-Transaction/"/>
    <id>http://liuyoubin.top/2020/02/07/backEnd/framework/Spring%E6%89%A9%E5%B1%952-Transaction/</id>
    <published>2020-02-07T08:43:18.000Z</published>
    <updated>2020-02-09T04:16:01.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务-Transaction"><a href="#事务-Transaction" class="headerlink" title="事务(Transaction)"></a>事务(Transaction)</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>​        事务是一系列操作的工作单元，是数据库操作的最小工作单元，这些操作要么同时成功，要么同时失败。</p><a id="more"></a><h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><p>​        <strong>事务的四大特性:ACID</strong></p><ul><li><p>原子性  (Atomicity) </p><p>​        原子性是指一个事务是一个不可分割的整体，其中的操作要么全部成功，要么全部失败。如果其中某个操作发生错误那么所有的操作要回滚，数据库返回到事务开始前状态。</p></li></ul><ul><li><p>一致性  (Consistency)</p><p>​        一致性是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行前后都是合法的数据状态。</p></li></ul><ul><li><p>隔离性  (isolation)</p><p>​        隔离性是指不同事务之间操作是隔离的，并发执行之间不能相互干扰影响。</p></li></ul><ul><li><p>持久性  (Durability)</p><p>​        持久性是指事务一旦提交，它对数据库的改变就是永久的，不会因为宕机或其他故障而影响。</p></li></ul><h1 id="Transactional"><a href="#Transactional" class="headerlink" title="Transactional"></a>Transactional</h1><p>​        Spring提供了基于AOP的声明式事务来帮我们管理事务。Spring声明式事务可以通过 配置XML进行配置，也可以采用注解式的声明式事务。</p><p>​        下面给出两种配置的示例:</p><h2 id="XML配置声明式事务"><a href="#XML配置声明式事务" class="headerlink" title="XML配置声明式事务"></a>XML配置声明式事务</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/s_01?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf-8<span class="symbol">&amp;amp;</span>useSSL=false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"lyb980328"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 配置事务的通知 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAd"</span> <span class="attr">transaction-manager</span>=<span class="string">"txManager"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置哪些方法使用什么样的事务，以及事务的传播特性 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get"</span>  <span class="attr">read-only</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"insert"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"delete"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--通过aop将事务通知切入方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.lyb.dao.Imp.*.*(..))"</span> <span class="attr">id</span>=<span class="string">"point"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAd"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="注解方式配置声明式事务"><a href="#注解方式配置声明式事务" class="headerlink" title="注解方式配置声明式事务"></a>注解方式配置声明式事务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">//开启声明式事务</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value = &#123;<span class="string">"com.lyb.service"</span>,<span class="string">"com.lyb.dao"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> PropertyVetoException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> PropertyVetoException </span>&#123;</span><br><span class="line">        ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">        dataSource.setUser(<span class="string">"root"</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">"lyb980328"</span>);</span><br><span class="line">        dataSource.setDriverClass(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        dataSource.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/s_02?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">jdbcTemplate</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册事务管理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">//声明这个方法的事务特性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userDao.insert();</span><br><span class="line">        <span class="comment">//模拟出错</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Transaction三大接口"><a href="#Transaction三大接口" class="headerlink" title="Transaction三大接口"></a>Transaction三大接口</h1><ul><li><p>PlatformTransactionManager</p><p>​        PlatformTransactionManager根据TransactionBefination提供的事务信息进行配置，是事务管理器的基类。Mybatis/JDBC使用DataSourceTransactionManager。一共三个方法：</p><ul><li>getTransaction（TransactionDefination），在当前环境中获取一个事务，如果没有则新建</li><li>commit  提交事务</li><li>rollback  回滚事务</li></ul></li><li><p>TransactionDefination：封装了事务隔离级别，超时时间等</p></li><li><p>TransactionStatus：封装了事务具体运行的状态</p></li></ul><h1 id="Transactional的配置项"><a href="#Transactional的配置项" class="headerlink" title="Transactional的配置项"></a>Transactional的配置项</h1><table><thead><tr><th align="center">配置项目</th><th align="center">含义</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">定义事务管理器</td><td align="center">这是Spring容器中的一个Bean，这个Bean需要实现PlatformTransactionManager</td></tr><tr><td align="center">transactionManager</td><td align="center">同上</td><td align="center">同上</td></tr><tr><td align="center">isolation</td><td align="center">隔离级别</td><td align="center">定义不同事务在并发执行时的隔离级别，默认隔离级别取决于所用数据库默认的隔离级别</td></tr><tr><td align="center">propagation</td><td align="center">传播行为</td><td align="center">事务传播行为，默认值为PROPAGATION.REQUIRED</td></tr><tr><td align="center">timeout</td><td align="center">超时时间</td><td align="center">单位为秒，当超时时，会引发异常，默认回滚</td></tr><tr><td align="center">readOnly</td><td align="center">是否只读</td><td align="center">默认为false</td></tr><tr><td align="center">rollbackFor</td><td align="center">回滚事务异常类定义</td><td align="center">定义当前事务发生该异常时才发生回滚，否则提交事务</td></tr><tr><td align="center">rollbackForClassName</td><td align="center">回滚事务的异常类名定义</td><td align="center">同上，只是用类名定义</td></tr><tr><td align="center">noRollbackFor</td><td align="center">产生哪些异常不回滚事务</td><td align="center">产生该异常时，事务继续执行</td></tr><tr><td align="center">noRollbackForClassName</td><td align="center">产生哪些异常不回滚事务</td><td align="center">同上，只是用类名定义</td></tr></tbody></table><h1 id="Transactional事务生效条件"><a href="#Transactional事务生效条件" class="headerlink" title="Transactional事务生效条件"></a>Transactional事务生效条件</h1><ul><li>@Transaction只对<strong>public</strong>修饰的方法起效，如果将@Transaction注解在<strong>protected、private</strong>上，编译可以通过但是事务不起作用。</li></ul><hr><ul><li>在默认条件下，事务只对运行时异常(RuntimeException)起作用，对于检查异常(check exception)不起作用。</li></ul><p>  首先我们来看一幅图：</p><p>  <img src="https://s2.ax1x.com/2020/02/08/1WZ2Nt.png" alt="image"></p><p>  ​        我们知道在java中RuntimeException及其子类都是运行时异常，对于运行时异常我们可以不用try catch捕获，也不用throws进行声明。而其他异常一般都是检查异常，对于检查异常我们要不然就进行try catch，要不然就要通过throws进行声明。</p><p>  ​        <strong>而在Spring事务中，在默认情况下只有发生运行时异常，事务才会发生回滚。</strong></p><p>  ​        <strong>并且不管是运行时异常和检查时异常只有在抛出的时候才是触发时机，也就是说在默认情况下如果你用try catch捕获运行时异常，事务也同样不会回滚。</strong></p><p>  ​        下面看几个例子：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 发生算术异常（运行时异常），所以事务会回滚</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">       studentMapper.updateStudent(student);</span><br><span class="line">       <span class="keyword">int</span> i =  <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 虽然发生了算术异常（运行时异常），但是异常被捕获没有继续抛出，所以事务不会回滚</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      studentMapper.updateStudent(student);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="keyword">int</span> i =  <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span>(RuntimeException)&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 由于抛出的是检查时异常，所以事务不会回滚</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(Student student)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       studentMapper.updateStudent(student);</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"异常"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>  ​            </p><p>  ​        如果想让发生检查时异常也发生回滚可以通过rollbackFor/rollbackForClassName属性指定，同理也可以用noRollbackFor/noRollbackForClassName来指定发生运行时异常不回滚。注意这里的“发生异常”指的是抛出异常，被try catch的异常不会触发回滚。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">* rollbackFor指定了Exception异常，所以事务会回滚</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">   @<span class="title">Override</span></span></span><br><span class="line"><span class="class">   <span class="title">public</span> <span class="title">void</span> <span class="title">updateStudent</span>(<span class="title">Student</span> <span class="title">student</span>) <span class="title">throws</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">       studentMapper.updateStudent(student);</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"异常"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 虽然rollbackFor指定了Exception异常，但是Exception异常被捕获，所以事务不会回滚</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">   @<span class="title">Override</span></span></span><br><span class="line"><span class="class">   <span class="title">public</span> <span class="title">void</span> <span class="title">updateStudent</span>(<span class="title">Student</span> <span class="title">student</span>) </span>&#123;</span><br><span class="line">       studentMapper.updateStudent(student);</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"异常"</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="isolation事务隔离级别"><a href="#isolation事务隔离级别" class="headerlink" title="isolation事务隔离级别"></a>isolation事务隔离级别</h1><p>​        <strong>所谓隔离级别就是指不同事务在并发执行的时候，互相的影响程度。我么在进行事务操作的过程中有可能引发以下三种情况。</strong></p><ul><li><p>脏读</p><p>​        所谓脏读就是读取未提交数据。比如：A事务修改了某一条数据但是还没提交，B事务读取了A事务修改后的数据，此时如果A事务发生了回滚，那么就发生了脏读。</p></li><li><p>不可重复读</p><p>​        不可重复读，通俗的讲就是一个事务多次读取同一数据，结果却不一样。比如：A事务先读取了一条数据的值为0，B事务在A事务读取后，将这条数据的值改成1然后提交，A事务再次读取这条数据发现和这前不一样了，这就是不可重复的。</p></li><li><p>幻读</p><p>​        幻读就是同一个事务中进行多次同一查询，但由于其他事务的增加数据的行为，每次查询返回的结果级都不一样。</p></li></ul><p>​      <strong>Spring针对上面三种情况，提供了5种隔离级别来解决。</strong></p><ul><li><p>DEFAULT  默认级别</p><p>​        这个级别取决于所用数据库的默认隔离级别，MySQL默认隔离级别REPEATABLE_READ</p></li></ul><ul><li><p>READ_UNCOMMITED 未提交读级别</p><p>​        在这个级别，事务可以读到别的事务未提交的数据，可能出现脏读、不可重复读、幻读</p></li></ul><ul><li><p>READ_COMMITED  已提交读级别</p><p>​        在这个级别，一个事务只能读取其他事务已提交的修改。在这个隔离级别解决了脏读，但依然存在不可重复读和幻读。因为其他事务可能会有多次commit。</p></li></ul><ul><li><p>REPEATABLE_READ  可重复读取级别</p><p>​            在这个级别，一个事务多次执行查询同一数据将返回同一结果，不受其他事务的影响(只针对修改操作)。在这个隔离级别解决了脏读、不可重复读 ，但依然存在幻读。因为此时其他事务可以插入数据。</p></li></ul><ul><li><p>SERIALIZABLE  序列化级别</p><p>​            在这个级别，所有事务将逐个执行，这样事务之间就完全隔离。在这个隔离级别解决了脏读、不可重复读和幻读。</p></li></ul><h1 id="Propagation事务传播行为"><a href="#Propagation事务传播行为" class="headerlink" title="Propagation事务传播行为"></a>Propagation事务传播行为</h1><p>​        <strong>事务传播行为也就是多个事务方法相互调用时，事务如何在方法中传播。Spring定义了七种事务传播行为。</strong></p><ul><li><p>REQUIRED (默认)</p><p>​        如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务</p><p>​        通俗的讲：</p><p>​                A方法调用B方法</p><p>​                B方法的事务传播行为如果是REQUIRED，那么如果A方法存在事务那么B方法就加入A事务，如果A方法不存在事务，那B方法就自己创建事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">*  测试发现只要有一个方法出现异常，两个方法就都进行回滚，证明两个方法在同一个事务中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">(Student student1, Student student2)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//新增Student1</span></span><br><span class="line">       studentMapper.insertStudent(student1);</span><br><span class="line">  </span><br><span class="line">       <span class="comment">//调用事务方法修改student2</span></span><br><span class="line">       updateStudent(student2);</span><br><span class="line">  </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Transactional</span>(propadation=Propagation.REQUIRED)</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">       studentMapper.updateStudent(student);</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>SUPPORTS</p><p>​    自身不会开启事务，在事务范围内则使用相同事务，否则不使用事务。</p><p>​    通俗的讲：</p><p>​                A方法调用B方法</p><p>​                B方法的事务传播行为如果是SUPPORTS，那么如果A方法存在事务那么B方法就加入A事务，如果A方法不存在事务，那B方法就不使用事务</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">*  就像下面这个例子，由于A方法没有事务(因为A方法的调用者没有事务)，所以B方法也就不用事务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(propadation=Propagation.SUPPORTS)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">(Student student1, Student student2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新增Student1</span></span><br><span class="line">    studentMapper.insertStudent(student1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用事务方法修改student2</span></span><br><span class="line">    updateStudent(student2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(propadation=Propagation.SUPPORTS)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">    studentMapper.updateStudent(student);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>MANDATORY</p><p>​    支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p><p>​    通俗的讲：</p><p>​                A方法调用B方法</p><p>​                B方法的事务传播行为如果是MANDATORY，那么如果A方法存在事务那么B方法就加入A事务，如果A方法不存在事务，那B方法就抛出异常</p></li></ul><ul><li><p>REQUIRES_NEW</p><p>​    创建新事务，无论当前存不存在事务，都创建新事务</p><p>​    通俗的讲：</p><p>​                A方法调用B方法</p><p>​                B方法的事务传播行为如果是REQUIRES_NEW，那么如果A方法无论存不存在事务，B方法都会自己开启一个新事务。</p></li></ul><ul><li><p>NOT_SUPPORTED</p><p>​    以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</p><p>​    通俗的讲：</p><p>​                A方法调用B方法</p><p>​                B方法的事务传播行为如果是NOT_SUPPORTED，那么如果A方法存在事务，运行到B方法的时候A事务挂起，B方法会以非事务运行，B运行完毕后A事务才继续执行。</p></li></ul><ul><li><p>NEVER</p><p>​    以非事务方式执行，如果当前存在事务，则抛出异常</p><p>​    通俗的讲：</p><p>​                A方法调用B方法</p><p>​                B方法的事务传播行为如果是NEVER，那么如果A方法存在事务，那么B方法就会抛异常</p></li></ul><ul><li><p>NESTED</p><p>​        如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作</p><p>​        和REQUIRES_NEW相似，不同的是REQUIRES_NEW中的两个事务是独立的。而NESTED的事务要依赖于父事务，如果父事务回滚，那么自己事务也会回滚。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;事务-Transaction&quot;&gt;&lt;a href=&quot;#事务-Transaction&quot; class=&quot;headerlink&quot; title=&quot;事务(Transaction)&quot;&gt;&lt;/a&gt;事务(Transaction)&lt;/h1&gt;&lt;h2 id=&quot;什么是事务&quot;&gt;&lt;a href=&quot;#什么是事务&quot; class=&quot;headerlink&quot; title=&quot;什么是事务&quot;&gt;&lt;/a&gt;什么是事务&lt;/h2&gt;&lt;p&gt;​        事务是一系列操作的工作单元，是数据库操作的最小工作单元，这些操作要么同时成功，要么同时失败。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Spring" scheme="http://liuyoubin.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Linux Shell编程基础</title>
    <link href="http://liuyoubin.top/2020/02/02/backEnd/Linux-Shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://liuyoubin.top/2020/02/02/backEnd/Linux-Shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2020-02-02T15:21:24.000Z</published>
    <updated>2020-02-26T07:30:32.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell是什么"><a href="#Shell是什么" class="headerlink" title="Shell是什么"></a>Shell是什么</h1><p>​        shell是一个命令行解释器，它为用户提供了一个向内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。</p><p><img src="https://s2.ax1x.com/2020/02/03/1NYgiQ.png" alt="image"></p><a id="more"></a><h1 id="Shell快速入门"><a href="#Shell快速入门" class="headerlink" title="Shell快速入门"></a>Shell快速入门</h1><h2 id="Shell脚本的执行方式"><a href="#Shell脚本的执行方式" class="headerlink" title="Shell脚本的执行方式"></a>Shell脚本的执行方式</h2><p><strong>脚本格式要求</strong></p><ol><li><p>脚本以<code>#!/bin/bash</code>开头</p></li><li><p>脚本需要有可执行权限</p></li></ol><p><strong>编写第一个Shell脚本</strong></p><p>​        要求：编写一个脚本输出hello world!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim helloworld.sh</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello  world!"</span></span><br></pre></td></tr></table></figure><ul><li><p>执行方式1(输入脚本的绝对路径或者相对路径)</p><ul><li><p>首先要赋予脚本+x权限</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">744</span> helloworld.sh</span><br></pre></td></tr></table></figure></li><li><p>执行脚本</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">相对路径  ./helloworld.<span class="keyword">sh</span></span><br><span class="line">绝对路径  /root/<span class="keyword">shell</span>/helloworld.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>执行方式2(sh+脚本)</p><ul><li><p>不用赋予脚本+x权限，直接执行</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sh</span> helloworld.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h2><p><strong>Shell变量</strong></p><ol><li><p>Linux shell变量有 <strong>系统变量</strong>和<strong>用户自定义变量</strong></p></li><li><p>系统变量例如： $HOME、$PWD、$SHELL、￥USER</p></li><li><p>输入系统中所有系统变量: set</p></li></ol><p><strong>定义变量的规则</strong></p><ol><li>变量名称可以由字母、数组、下划线组成，但不能由下划线开头</li><li>等号两边不能有空格</li><li>变量名称一般大写</li></ol><p><strong>Shell变量的定义</strong></p><ol><li>定义变量: 变量=值</li><li>撤销变量：unset 变量</li><li>声明静态变量: readonly  变量, 注意不能unset </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">A=100</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"A=<span class="variable">$A</span>"</span></span><br><span class="line"><span class="built_in">unset</span> A</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"A=<span class="variable">$A</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">readonly</span> B=200</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"B=<span class="variable">$B</span>"</span></span><br><span class="line"><span class="built_in">unset</span> B</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">A=100</span><br><span class="line">A=</span><br><span class="line">B=200</span><br><span class="line">./helloworld.sh: line 11: <span class="built_in">unset</span>: B: cannot <span class="built_in">unset</span>: <span class="built_in">readonly</span> variable</span><br></pre></td></tr></table></figure><p><strong>将命令返回值赋给变量</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. <span class="attribute">A</span>=`ls -la`</span><br><span class="line">2. <span class="attribute">A</span>=$(ls -la)</span><br></pre></td></tr></table></figure><p><strong>设置环境变量</strong></p><ul><li>Shell可以通过export设置全局环境变量</li><li>通过source /etc/profile刷新配置</li><li>其他Shell脚本可以访问到这个环境变量</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在Shell脚本中 定义一个环境变量</span></span><br><span class="line"><span class="attribute">TOMCAT_HOME</span>=/usr/local/tomcat/bin</span><br><span class="line"><span class="builtin-name">export</span> TOMCAT_HOME</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"><span class="comment">#刷新配置</span></span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"><span class="comment">#其他Shell进行使用</span></span><br><span class="line">echo <span class="variable">$TOMCAT_HOME</span></span><br></pre></td></tr></table></figure><p><strong>位置参数变量</strong></p><p>​        当我们执行一个shell脚本时，如果希望获取命令行的参数信息，就可以使用到位置参数变量，比如： ./helloworld.sh 100 200 可以在脚本中获得到参数信息。</p><p>​        <strong>基本语法：</strong></p><ul><li><p>$n  (n为数字，$0代表命令本身，$1-9代表一到九参数，10以上的参数需要大括号包裹比如${12})</p></li><li><p>$*  (代表命令行中所有参数，把所有参数看做一个整体)</p></li><li><p>$@  (代表命令行中所有参数，但是$@把每个参数区别对待)</p></li><li><p>$#  (代表命令行中所有参数的个数)</p><p>​    <strong>示例：</strong></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取到各个参数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$0</span> <span class="variable">$1</span> <span class="variable">$2</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"$*"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"参数个数=<span class="variable">$#</span>"</span></span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">./positionPara 100 200</span><br><span class="line"> </span><br><span class="line">----</span><br><span class="line">./positionPara.sh 100 200</span><br><span class="line">100 200</span><br><span class="line">100 200</span><br><span class="line">参数个数=2</span><br></pre></td></tr></table></figure><p><strong>预定义变量</strong></p><ul><li><p>$$  (当前进程的进程号（PID）)</p></li><li><p>$!   (后台运行的最后一个进程的进程号(PID))</p></li><li><p>$？ (最后一个执行的命令的返回状态，如果这个变量为0则代表执行成功，否则执行失败)</p><p>​    <strong>示例：</strong></p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="string">echo</span> <span class="string">"当前进程号=$$"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#后台的方式运行helloworld.sh</span></span><br><span class="line"><span class="string">./helloworld.sh</span> <span class="string">&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="string">echo</span> <span class="string">"最后的进程号=$!"</span></span><br><span class="line"></span><br><span class="line"><span class="string">echo</span> <span class="string">"执行的值=$?"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">./preVAl.sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">当前进程号=30981</span></span><br><span class="line"><span class="string">最后的进程号=30982</span></span><br><span class="line"><span class="string">执行的值=0</span></span><br><span class="line"><span class="string">[root@izm5e4zm50doq1ptls492gz</span> <span class="string">shell]#</span> <span class="string">hello</span>  <span class="string">world!</span></span><br></pre></td></tr></table></figure><h2 id="Shell运算符"><a href="#Shell运算符" class="headerlink" title="Shell运算符"></a>Shell运算符</h2><p><strong>基本语法</strong></p><ul><li><p>“$((运算符))” 或 “$[运算符]”</p></li><li><p>expr m + n  //注意运算符之间要有空格</p></li><li><p>expr m - n</p></li><li><p>expr \*   //乘</p></li><li><p>expr /</p></li><li><p>%</p></li></ul><p>​    <strong>示例：</strong></p><p>​                <strong>案例1：</strong>计算 (2+3)* 8的值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第一种方式 $(())</span></span><br><span class="line"><span class="string">RESULT1=$(((2+3)*8))</span></span><br><span class="line"><span class="string">echo</span> <span class="string">"RESULT1=$RESULT1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第二种方式 $[] (推荐)</span></span><br><span class="line"><span class="string">RESULT2=$[(2+3)*8]</span></span><br><span class="line"><span class="string">echo</span> <span class="string">"RESULT2=$RESULT2"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第三种方式 expr</span></span><br><span class="line"><span class="string">TEMP=`expr</span> <span class="number">2</span> <span class="string">+</span> <span class="number">3</span><span class="string">`</span></span><br><span class="line"><span class="string">RESULT3=`expr</span> <span class="string">$TEMP</span> <span class="string">\*</span> <span class="number">8</span><span class="string">`</span></span><br><span class="line"><span class="string">echo</span> <span class="string">"RESULT3=$RESULT3"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">./demo.sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">RESULT1=40</span></span><br><span class="line"><span class="string">RESULT2=40</span></span><br><span class="line"><span class="string">RESULT3=40</span></span><br></pre></td></tr></table></figure><p>​                <strong>案例2：</strong>求出两个参数的和</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="string">RESULT=$[$1+$2]</span></span><br><span class="line"><span class="string">echo</span> <span class="string">"RESULT=$RESULT"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">./add.sh</span> <span class="number">100</span> <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">RESULT=300</span></span><br></pre></td></tr></table></figure><h2 id="Shell流程控制"><a href="#Shell流程控制" class="headerlink" title="Shell流程控制"></a>Shell流程控制</h2><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p><strong>基本语法</strong></p><ul><li><p>[ condition ] （condition前后要有空格）</p></li><li><p>[ condition ] &amp;&amp; echo OK || echo NO  （条件满足执行语句）</p></li></ul><p><strong>常用判断条件</strong></p><ul><li><p>两个整数的比较</p><ul><li>=  字符串比较</li><li>-lt    小于</li><li>-le   小于等于</li><li>-eq  等于</li><li>-gt   大于</li><li>-ge  大于等于</li><li>-ne  不等于</li></ul></li><li><p>按照文件权限进行判断</p><ul><li>-r   有读的权限</li><li>-w  有写的权限</li><li>-x   有执行的权限</li></ul></li><li><p>按照文件类型进行判断</p><ul><li>-f    文件存在且是一个常规文件</li><li>-e   文件存在</li><li>-d   文件存在且是一个目录</li></ul></li></ul><p><strong>示例</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断 “OK”是否等于“OK”</span></span><br><span class="line"></span><br><span class="line"><span class="string">if</span> <span class="string">[</span> <span class="string">"OK"</span> <span class="string">=</span> <span class="string">"OK"</span> <span class="string">]</span></span><br><span class="line"><span class="string">then</span> </span><br><span class="line">  <span class="string">echo</span> <span class="string">"equal"</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断 23是否大于22</span></span><br><span class="line"><span class="string">if</span> <span class="string">[</span> <span class="number">23</span> <span class="string">-gt</span> <span class="number">22</span> <span class="string">]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line">  <span class="string">echo</span> <span class="string">"大于"</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断/root/shell/helloworld.sh目录中的文件是否存在</span></span><br><span class="line"><span class="string">if</span> <span class="string">[</span> <span class="string">-e</span> <span class="string">/root/shell/helloworld.sh</span> <span class="string">]</span></span><br><span class="line"><span class="string">then</span> </span><br><span class="line">  <span class="string">echo</span> <span class="string">"存在"</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">./condition.sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">equal</span></span><br><span class="line"><span class="string">大于</span></span><br><span class="line"><span class="string">存在</span></span><br></pre></td></tr></table></figure><h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><p><strong>基本语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">程序</span><br><span class="line"><span class="keyword">elif</span> [ condition ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"> 程序</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$1</span> -ge 60 ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"及格"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$1</span> -lt 60 ]</span><br><span class="line">  <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"不及格"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="case语法"><a href="#case语法" class="headerlink" title="case语法"></a>case语法</h3><p><strong>基本语法</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line"><span class="string">"值1"</span>)</span><br><span class="line">程序<span class="number">1</span></span><br><span class="line">;;</span><br><span class="line"><span class="string">"值2"</span>)</span><br><span class="line">程序<span class="number">2</span></span><br><span class="line">;;</span><br><span class="line">....</span><br><span class="line">*)</span><br><span class="line"><span class="section">default</span>程序</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line"><span class="string">"1"</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"星期一"</span></span><br><span class="line">;;</span><br><span class="line"><span class="string">"2"</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"星期二"</span></span><br><span class="line">;;</span><br><span class="line"><span class="string">"3"</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"星期三"</span></span><br><span class="line">;;</span><br><span class="line"><span class="string">"4"</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"星期四"</span></span><br><span class="line">;;</span><br><span class="line"><span class="string">"5"</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"星期五"</span></span><br><span class="line">;;</span><br><span class="line"><span class="string">"6"</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"星期六"</span></span><br><span class="line">;;</span><br><span class="line"><span class="string">"7"</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"星期天"</span></span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"出错"</span></span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><strong>基本语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">语法一:</span><br><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 值1 值2 值3...</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"> 程序</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">语法二:</span><br><span class="line"><span class="keyword">for</span>((初始值;循环控制块;变量变化))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"> 程序</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><p>​    <strong>示例一：</strong>打印命令行参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"$*"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"the num is <span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">./fordemo1.sh 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">the num is 1 2 3 4 5</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"the num is <span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">./fordemo2.sh 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">the num is 1</span><br><span class="line">the num is 2</span><br><span class="line">the num is 3</span><br><span class="line">the num is 4</span><br><span class="line">the num is 5</span><br></pre></td></tr></table></figure><p><strong>示例二：</strong>打印从1加到100的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">SUM=0</span><br><span class="line"><span class="keyword">for</span>((i=1;i&lt;=100;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"> SUM=$[<span class="variable">$SUM</span>+<span class="variable">$i</span>]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"SUM=<span class="variable">$SUM</span>"</span></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">./fordemo3.sh</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">SUM=5050</span><br></pre></td></tr></table></figure><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p><strong>基本语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">程序</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><p>​        <strong>示例一：</strong>从命令行输入n,统计从1+…+n的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">SUM=0</span><br><span class="line">i=0</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -le <span class="variable">$1</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"> SUM=$[<span class="variable">$SUM</span>+<span class="variable">$i</span>]</span><br><span class="line"> i=$[<span class="variable">$i</span>+1]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"SUM=<span class="variable">$SUM</span>"</span></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">./while.sh 100</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">SUM=5050</span><br></pre></td></tr></table></figure><h2 id="Shell读取控制台输入"><a href="#Shell读取控制台输入" class="headerlink" title="Shell读取控制台输入"></a>Shell读取控制台输入</h2><p><strong>基本语法</strong></p><p>read (选项) (参数)</p><p>选项：</p><ul><li>-p 指定读取值时的提示符</li><li>-t   指定读取值时等待的时间(秒)</li></ul><p>参数：指定读取值的变量名</p><p><strong>示例：</strong>读取控制台一个num值，10秒后输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"请输入一个数num="</span> -t 10  NUM</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"你输入的值是=<span class="variable">$NUM</span>"</span></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">./read.sh</span><br><span class="line">请输入一个数num=18</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">你输入的值是=18</span><br></pre></td></tr></table></figure><h2 id="Shell中的函数"><a href="#Shell中的函数" class="headerlink" title="Shell中的函数"></a>Shell中的函数</h2><p><strong>函数介绍</strong></p><p>​        Shell编程有系统函数和自定义函数两种</p><p><strong>系统函数</strong></p><ul><li><p><strong>basename函数</strong></p><ul><li>功能 : 返回完整路径最后/的部分，常用于获取文件</li><li>basename [pathname] [suffix]<ul><li>suffix为后缀，如果suffix被指定，basename会将pathname中的suffix去掉</li></ul></li></ul></li><li><p><strong>dirname函数</strong></p><ul><li>功能 : 返回完整路径最后 / 前面的部分，常用于返回路径部分</li><li>dirname [pathname] </li></ul></li></ul><p><strong>自定义函数</strong></p><p>​        <strong>基本语法</strong></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="function"><span class="keyword">function</span></span>] funname[()]</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">Action</span>;</span><br><span class="line">[<span class="keyword">return</span> <span class="built_in">int</span>;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用直接写函数名: funname [值]</span><br></pre></td></tr></table></figure><p>​            <strong>示例：</strong>计算输入两个参数的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getSun</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">SUM=$[<span class="variable">$n1</span>+<span class="variable">$n2</span>]</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"和是=<span class="variable">$SUM</span>"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"请输入第一个数n1:"</span> n1</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"请输入第二个数n2:"</span> n2</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">getSun <span class="variable">$n1</span> <span class="variable">$n2</span></span><br></pre></td></tr></table></figure><h1 id="Shell编程综合案例"><a href="#Shell编程综合案例" class="headerlink" title="Shell编程综合案例"></a>Shell编程综合案例</h1><p><strong>需求分析</strong></p><ul><li>每天凌晨2:10备份数据库db01到/data/backup/db</li><li>备份开始和备份结束都能给出相应的提示信息</li><li>备份后的文件要求以备份时间为文件名，并打包成.tar.gz的形式，比如: 2020-02-02_020103.tar.gz</li><li>在备份的同时检查是否有10天前备份的数据库文件，如果有就将其删除</li></ul><p><strong>代码实现</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">设置备份的路径</span></span><br><span class="line">BACKUP=/data/backup/db</span><br><span class="line"><span class="meta">#</span><span class="bash">获取当前的时间作为文件名</span></span><br><span class="line">DATETIME=$(date +%Y-%m-%d_%H%M%S)</span><br><span class="line"></span><br><span class="line">echo "============================开始备份================================"</span><br><span class="line">echo "===============备份的路径是 $BACKUP/$DATETIME.tar.gz==============="</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">主机</span></span><br><span class="line">HOST=localhost</span><br><span class="line"><span class="meta">#</span><span class="bash">用户名</span></span><br><span class="line">DB_USER=root</span><br><span class="line"><span class="meta">#</span><span class="bash">密码</span></span><br><span class="line">DB_PASS=lyb980328</span><br><span class="line"><span class="meta">#</span><span class="bash">备份数据库名</span></span><br><span class="line">DATABASE=db01</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">创建备份的路径,不存在就创建</span></span><br><span class="line">[ ! -d "$BACKUP" ] &amp;&amp; mkdir -p "$BACKUP"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">执行mysql备份指令</span></span><br><span class="line">mysqldump -u$&#123;DB_USER&#125; -p$&#123;DB_PASS&#125; --host=$HOST $DATABASE | gzip &gt; $BACKUP/$DATETIME.sql.gz</span><br><span class="line"><span class="meta">#</span><span class="bash">打包备份文件</span></span><br><span class="line">cd $BACKUP</span><br><span class="line">tar -zcvf $DATETIME.tar.gz $DATETIME.sql.gz</span><br><span class="line"><span class="meta">#</span><span class="bash">删除临时文件</span></span><br><span class="line">rm -rf $DATETIME.sql.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除十天前的备份文件</span></span><br><span class="line">find $BACKUP -mtime +10 -name "*.tar.gz" -exec rm -f &#123;&#125; \;</span><br><span class="line"></span><br><span class="line">echo "===================备份成功======================="    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">crontab -e</span><br><span class="line"></span><br><span class="line">10 2 * * * ./root/shell/mysql_backup.db.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Shell是什么&quot;&gt;&lt;a href=&quot;#Shell是什么&quot; class=&quot;headerlink&quot; title=&quot;Shell是什么&quot;&gt;&lt;/a&gt;Shell是什么&lt;/h1&gt;&lt;p&gt;​        shell是一个命令行解释器，它为用户提供了一个向内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/03/1NYgiQ.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Linux" scheme="http://liuyoubin.top/tags/Linux/"/>
    
      <category term="Shell" scheme="http://liuyoubin.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习笔记</title>
    <link href="http://liuyoubin.top/2020/01/31/backEnd/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://liuyoubin.top/2020/01/31/backEnd/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-01-31T03:01:40.000Z</published>
    <updated>2020-02-25T17:18:29.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker为什么会出现"><a href="#Docker为什么会出现" class="headerlink" title="Docker为什么会出现"></a>Docker为什么会出现</h1><p>​    以前在服务器上部署一个应用，除了应用本身还要安装各种相应的软件、依赖，进行各种相应的配置。这种方式不仅费时费力还不能跨平台，不利于应用的集群部署。</p><p>​        Docker的出现提供了一个解决方案，打破了<code>程序及应用</code>的传统观念。<code>通过镜像（images）将作业系统核心除外，运作应用所需的系统环境，由下而上进行打包，达到应用程序跨平台无缝部署运行。</code></p><a id="more"></a><h1 id="Docker三要素"><a href="#Docker三要素" class="headerlink" title="Docker三要素"></a>Docker三要素</h1><ul><li><p>镜像</p><p>​        Docker镜像(Image)就是一个<code>只读</code>的模板，一个镜像可以用来创建多个Docker容器。</p></li><li><p>容器</p><p>​        Docker容器(Container)是用镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做一个简易版的Linux环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p></li><li><p>仓库</p><p>​        仓库（Repository）是<code>集中存放镜像文件</code>的场所。</p><p>​        仓库和仓库注册服务器（Registry）是有区别的，仓库注册服务器上可以存放着多个仓库，每个仓库又包含了多个镜像，每个镜像有不同的标签(tag)。</p></li></ul><h1 id="Docker的安装与启动"><a href="#Docker的安装与启动" class="headerlink" title="Docker的安装与启动"></a>Docker的安装与启动</h1><p>​        docker可以安装在windows上也可以安装在Linux上，我们学习开发的肯定是学习Linux版本的安装。</p><p>​        这里Linux的版本是<code>CentOS 7.7</code></p><p><strong>步骤：</strong></p><ol><li><p>安装所需的软件包</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">yum</span> <span class="string">install -y yum-utils \</span></span><br><span class="line">  <span class="meta">device-mapper-persistent-data</span> <span class="string">\</span></span><br><span class="line"> <span class="attr">lvm2</span></span><br></pre></td></tr></table></figure></li><li><p>设置存储库</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager \</span><br><span class="line">    --<span class="built_in">add</span>-repo \</span><br><span class="line">    http<span class="variable">s:</span>//download.docker.<span class="keyword">com</span>/linux/centos/docker-<span class="keyword">ce</span>.repo</span><br></pre></td></tr></table></figure></li><li><p>安装docker社区版</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-<span class="keyword">ce</span> docker-<span class="keyword">ce</span>-cli containerd.io</span><br></pre></td></tr></table></figure><p>具体内容参考官网的说明:<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/</a></p></li><li><p>启动docker</p> <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> docker</span><br></pre></td></tr></table></figure></li><li><p>阿里云镜像加速配置</p><p>​        由于docker hub网站在国外，镜像拉取的速度很慢。所以要配置阿里云镜像加速    </p><p>​        首先登陆阿里云平台，获取加速地址(<strong>容器镜像服务&gt;镜像加速器)</strong>)</p><p>​        按照说明新建或修改 /etc/docker/daemon.json 文件，添加以下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [<span class="string">"https://tw8jn1y0.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        systemctl daemon-reload </p><p>​        systemctl restart docker</p></li></ol><h1 id="Docker底层原理"><a href="#Docker底层原理" class="headerlink" title="Docker底层原理"></a>Docker底层原理</h1><p><strong>Docker的运行原理</strong></p><p>​        Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。</p><p><img src="https://s2.ax1x.com/2020/01/31/13cruR.png" alt="image"></p><p><strong>为什么Docker比MV快</strong></p><ul><li>docker不需要Hypervisor实现硬件资源虚拟化，运行在docker容器上的程序直接使用宿主机的硬件资源，因此在硬件利用率上比MV高。</li><li>docker利用宿主机的内核，而不需要Guest OS。因此docker在新建一个容器是不需要加载操作系统，而是直接利用宿主机的操作系统，速度比需要加载Guest OS的MV更快。</li></ul><h1 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><ul><li><p>查看docker版本</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">version</span></span><br></pre></td></tr></table></figure></li><li><p>查看docker具体信息</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> <span class="literal">info</span></span><br></pre></td></tr></table></figure></li><li><p>查看docker帮助命令</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="comment">--help</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><ul><li><p>列出本地的镜像</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> images<span class="meta"> [OPTIONS]</span></span><br></pre></td></tr></table></figure><p>OPTIONS说明:</p><ul><li>-a  列出本地所有镜像(含中间映像层)</li><li>-q   只显示镜像ID</li><li>–digests  显示镜像的摘要信息</li><li>–no-trunc  显示完整的镜像信息</li></ul><p>例子:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          <span class="keyword">TAG</span>                 <span class="title">IMAGE</span> ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              fce289e99eb9        <span class="number">13</span> months ago       <span class="number">1.84</span>kB</span><br></pre></td></tr></table></figure><p>各表项说明：</p><table><thead><tr><th align="center">REPOSITORY</th><th align="center">TAG</th><th align="center">IMAGE ID</th><th align="center">CREATED</th><th align="center">SIZE</th></tr></thead><tbody><tr><td align="center">表示镜像的仓库源</td><td align="center">镜像的标签</td><td align="center">镜像ID</td><td align="center">镜像创建的时间</td><td align="center">镜像的大小</td></tr></tbody></table><p>​        同一个仓库源可以有多个TAG，代表这个仓库源的不同版本。我们使用REPOSITORY:TAG来指定版本，如果不指定默认latest版本。</p></li></ul><hr><ul><li><p>查看docker hub上的某个镜像</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">search</span> [<span class="keyword">OPTIONS</span>] 镜像名字</span><br></pre></td></tr></table></figure><p>OPTIONS说明:</p><ul><li>–no-trunc 查看完整的镜像信息</li><li>-s 列出收藏数不小于指定值的镜像</li><li>–automated 只列出automated build类型的镜像</li></ul></li></ul><hr><ul><li><p>下载镜像</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名字[:<span class="keyword">tag</span>]</span><br></pre></td></tr></table></figure></li><li><p>删除镜像</p><ul><li><p>删除单个镜像</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> rmi -f 镜像ID/唯一镜像名</span><br></pre></td></tr></table></figure><ul><li>-f 强制删除</li></ul></li><li><p>删除多个镜像</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f 镜像ID<span class="regexp">/唯一镜像名 镜像ID/</span>唯一镜像名 镜像ID<span class="regexp">/唯一镜像名...</span></span><br></pre></td></tr></table></figure></li><li><p>删除所有镜像</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f <span class="constructor">$(<span class="params">docker</span> <span class="params">images</span> -<span class="params">qa</span>)</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><ul><li><p>新建并启动容器</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="comment">[OPTIONS]</span> 镜像ID/唯一镜像名 <span class="comment">[COMMAND]</span> <span class="comment">[ARG...]</span></span><br></pre></td></tr></table></figure><p> [OPTIONS]说明：</p><ul><li><p>–name=”容器新名字”：为容器指定一个名称</p></li><li><p>-d : 后台运行容器，并返回容器ID，也即启动守护式容器</p></li><li><p>-i : 以交互模式运行容器，通常与-t同时运行</p></li><li><p>-t : 为容器重新分配一个伪输入终端，通常与-i同时使用</p></li><li><p>-P : 随机端口映射</p></li><li><p>-p: 指定端口映射，有以下四种形式</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ip:</span> <span class="string">hostPort:</span>containerPort</span><br><span class="line"><span class="string">ip:</span>:containerPort</span><br><span class="line"><span class="string">hostPort:</span>containerPort</span><br><span class="line">containerPort</span><br></pre></td></tr></table></figure></li></ul><p><strong>扩展：</strong></p><p>​        当我们以<code>docker run -d  容器Id</code>启动一个后台守护进程后，如果docker没有前台进程，那么这个后台进程会立即自杀。</p></li></ul><hr><ul><li><p>查看当前正在运行的容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> ps<span class="meta"> [OPTIONS]</span></span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li>-a ： 列出当前所有正在运行的容器+历史上运行过的容器</li><li>-l ：显示最近创建的容器</li><li>-n : 显示最近创建的n个容器</li><li>-q : 静默模式，只显示容器编号</li><li>–no-trunc ：不截断输出</li></ul></li><li><p>退出容器</p><ul><li><p>容器停止退出</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure></li><li><p>容器不停止退出</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+<span class="keyword">P</span>+Q</span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动容器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">start</span> 容器<span class="keyword">ID</span>/容器名</span><br></pre></td></tr></table></figure></li><li><p>重启容器</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">restart</span> 容器ID/容器名</span><br></pre></td></tr></table></figure></li><li><p>停止容器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">stop</span> 容器<span class="keyword">ID</span>/容器名</span><br></pre></td></tr></table></figure></li><li><p>强制停止容器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">kill</span> 容器<span class="keyword">ID</span>/容器名</span><br></pre></td></tr></table></figure></li><li><p>删除已停止的容器</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> rm 容器ID/容器名</span><br></pre></td></tr></table></figure><ul><li><p>删除多个容器</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f <span class="constructor">$(<span class="params">docker</span> <span class="params">ps</span> -<span class="params">a</span> -<span class="params">q</span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a -q <span class="string">| xargs docker rm</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看容器日志</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -t <span class="comment">--tail 容器ID</span></span><br></pre></td></tr></table></figure><ul><li>-t : 加入时间戳</li><li>-f : 跟随最新的打印日志</li><li>–tail 数字 显示最后多少条 </li></ul></li><li><p>查看容器内进程</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">top</span> 容器ID</span><br></pre></td></tr></table></figure></li><li><p>查看容器内部细节</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">inspect</span> 容器ID</span><br></pre></td></tr></table></figure></li><li><p>进入正在运行的容器并以命令行交互</p><ul><li><p>在容器中打开新的终端，并且可以启动新的进程</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -<span class="keyword">it</span> 容器ID bashShell</span><br></pre></td></tr></table></figure><p>​    当bashShell=/bin/bash时，直接进入到容器终端</p></li><li><p>直接进入容器启动命令的终端，不会启动新的进程</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">attach</span> 容器ID</span><br></pre></td></tr></table></figure></li></ul></li><li><p>将容器内的文件拷贝到主机上</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> <span class="meta">cp</span> 容器ID:容器内路径  目的主机的路径</span><br></pre></td></tr></table></figure></li></ul><h1 id="Docker镜像详解"><a href="#Docker镜像详解" class="headerlink" title="Docker镜像详解"></a>Docker镜像详解</h1><h2 id="联合文件系统（UnionFS）"><a href="#联合文件系统（UnionFS）" class="headerlink" title="联合文件系统（UnionFS）"></a><strong>联合文件系统（UnionFS）</strong></h2><p>​        Union文件系统是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层提交，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础，镜像可以通过分层来继承，基于基础镜像，可以制作各种具体的应用镜像。</p><p>​        特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终包含所有底层的文件和目录。</p><h2 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a><strong>Docker镜像加载原理</strong></h2><p>​        docker的镜像实际上由一层一层的文件系统组成，也就是UnionFS。</p><p>​        bootfs(boot file system)主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动会加载bootfs文件系统。<code>Docker镜像的最底层是bootfs。</code>这一层与我们的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p><p>​        rootfs(root file system),在bootfs之上。包含的就是典型Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。</p><p><img src="https://s2.ax1x.com/2020/02/01/1G0FoD.png" alt="image"></p><h2 id="Docker为什么要采用分层结构"><a href="#Docker为什么要采用分层结构" class="headerlink" title="Docker为什么要采用分层结构"></a><strong>Docker为什么要采用分层结构</strong></h2><p>​    共享资源：比如有多个镜像都从相同的base镜像构建而来，那么宿主机只需要在磁盘上保存一份base镜像，同时在内存中加载一份base镜像，就可以为所有容器服务了。</p><h2 id="镜像制作命令"><a href="#镜像制作命令" class="headerlink" title="镜像制作命令"></a><strong>镜像制作命令</strong></h2><p>​        我们可以通过镜像创建容器，也可以将自己定制的容器创建成一个新的镜像。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">commit</span> -m <span class="string">"提交的描述信息"</span> -a <span class="string">"作者"</span> 容器<span class="keyword">ID</span> 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure><h1 id="Docker容器数据卷"><a href="#Docker容器数据卷" class="headerlink" title="Docker容器数据卷"></a>Docker容器数据卷</h1><p><strong>什么是容器数据卷</strong></p><p>​        这要从docker的理念开始讲起 。docker是将应用和运行的环境打包成容器运行，有时在容器运行时产生的文件是我们需要的，但是随着容器的关闭这些文件会消失。我们将文件持久化。还有另外的一种需求，我们希望容器之间可以共享数据 。为了数据能够保存，我们使用容器数据卷来完成。</p><p><strong>容器数据卷的作用</strong></p><p>​        卷就是目录或者文件，存在于一个或多个容器中，但不属于联合文件系统。</p><p>​        卷的设计目的就是数据持久化，完全独立于容器的生命周期，因此删除容器不会删除其挂载的数据卷。</p><p>​        特点:</p><ol><li><p>数据卷可在容器之间共享和重用数据</p><pre><code>2. 卷中的更改可以直接生效              3. 数据卷中的更改不会包含在镜像的更新中          4. 数据卷的生命周期一直持续到没有容器使用它为止</code></pre></li></ol><p><strong>容器数据卷的添加</strong></p><ul><li><p>直接命令添加</p><p>命令:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -<span class="keyword">it</span> -v /宿主机绝对路径目录 : /容器内目录   镜像名</span><br></pre></td></tr></table></figure><p>命令(带权限): 容器只能读取数据卷的数据，不能进行增加和修改</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -<span class="keyword">it</span> -v /宿主机绝对路径目录 : /容器内目录 :ro  镜像名</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Dockerfile  添加</p><ul><li><p>在宿主机根目录下新建myDocker文件夹进入</p></li><li><p>新建Dockerfile ，并使用VOLUME指令来给镜像添加一个或多个数据卷</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># volume test</span></span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/dataVolumeContainer1"</span>,<span class="string">"/dataVolumeContainer2"</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"finished,------success"</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br></pre></td></tr></table></figure></li><li><p>通过Dockerfile 使用build命令构建一个新的镜像</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> <span class="keyword">build </span>-f /myDocker/Dockerfile  -t lyb/centos .</span><br></pre></td></tr></table></figure><ul><li>-f : 指明Dockerfile 的路径</li><li>-t : 镜像名字</li></ul></li><li><p>run新建的镜像，会发现容器的根目录下已经有 dataVolumeContainer1 和dataVolumeContainer2 两个目录</p></li><li><p>考虑到移植性的问题，通过Dockerfile 方式添加数据卷是无法指定数据卷挂载到宿主机的哪个目录。但是docker会帮我们默认指定，通过<code>docker inspect</code>命令查看</p></li></ul></li></ul><p><strong>数据卷容器</strong></p><p>​        命名的容器挂载数据卷，其它容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器，称之为数据卷容器。</p><p>​        <strong>例子：</strong></p><p>​                用上面新建的镜像创建一个容器</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -<span class="keyword">it</span>  <span class="comment">--name dc01 lyb/centos</span></span><br></pre></td></tr></table></figure><p>​                再建立两个容器都以dc01为父容器</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -<span class="keyword">it</span> <span class="comment">--name dc02 --volumes-from dc01 lyb/centos</span></span><br><span class="line">docker <span class="built_in">run</span> -<span class="keyword">it</span> <span class="comment">--name dc03 --volumes-from dc01 lyb/centos</span></span><br></pre></td></tr></table></figure><p>​                实现的效果：dc01、dc02、dc03三个容器的数据卷会实现传递共享，三个容器之间的数据可以共享，即使某一个容器删除其余两个容器依旧可以实现共享。</p><p>​            </p><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><h2 id="Dockerfile-基础"><a href="#Dockerfile-基础" class="headerlink" title="Dockerfile 基础"></a><strong>Dockerfile 基础</strong></h2><p><strong>Dockerfile 是什么：</strong></p><p>​    Dockerfile 是用来构建Docker镜像的Docker文件，是由一系列命令和参数构成的脚本。</p><p><strong>构建三步骤：</strong></p><ul><li>编写Dockerfile 文件</li><li>docker build </li><li>docker run</li></ul><p><strong>Dockerfile 内容基础知识</strong></p><ul><li>每条保留字指令都必须为大写字母且后面至少一个参数</li><li>指令按照从上到下，顺序执行</li><li>‘#’ 表示注释</li><li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li></ul><p><strong>Docker执行Dockerfile 的大致流程</strong></p><ol><li>docker从基础镜像运行一个容器</li><li>执行一条指令并对容器作出修改</li><li>执行类似docker commit的操作提交一个新的镜像层</li><li>docker再基于刚才提交的镜像运行一个新的容器</li><li>执行Dockerfile 中下一条指令直到所有指令都执行完成</li></ol><hr><h2 id="Dockerfile-保留字指令"><a href="#Dockerfile-保留字指令" class="headerlink" title="Dockerfile 保留字指令"></a><strong>Dockerfile 保留字指令</strong></h2><ul><li>FROM    基础镜像，当前新镜像是基于哪个镜像</li><li>MAINTAINER     镜像维护者的姓名和邮箱地址</li><li>RUN  容器构建时需要运行的命令</li><li>EXPOSE   当前容器对外暴露的端口号</li><li>WORKDIR    指定在创建容器后，终端默认登陆的进来工作目录</li><li>ENV    用来在构建镜像过程中设置环境变量</li><li>ADD    将宿主机目录下的文件拷贝进镜像且ADD命令会自动除了URL和解压tar压缩包</li><li>COPY   类似ADD ，拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件/目录 复制到新一层的镜像内的&lt;目标路径&gt;位置</li><li>VOLUME   容器数据卷，用于数据保存和持久化</li><li>CMD   指定一个容器启动时要运行的命令，<code>Dockerfile 可以有多个CMD指令但只有最后一个生效，CMD会被docker run 之后的参数替换</code><ul><li>CMD指令两种格式<ul><li>CMD &lt;命令&gt;</li><li>CMD [“可执行文件”，“参数1”，”参数2“，……]</li></ul></li></ul></li><li>ENTRYPOINT   指定一个容器启动时要运行的命令，<code>和CMD不同的是ENTRYPOINT 只能有一个，但是docker run之后的参数会当作参数追加到ENTRYPOINT 命令</code>。</li><li>ONBUILD 当构建一个被继承的Dockerfile 运行命令，父镜像在被子继承后，父镜像的onbuild被触发</li></ul><h2 id="DocderFile案例"><a href="#DocderFile案例" class="headerlink" title="DocderFile案例"></a><strong>DocderFile案例</strong></h2><p><strong>Base镜像</strong></p><p>​        Docker Hub中99%的镜像都是通过base镜像中安装和配置需要的软件构建出来的。</p><hr><p><strong>定制自定义Centos镜像</strong></p><p>​        <strong>定制前 :</strong> 精简的Centos镜像的默认终端目录是根目录，且不支持ifconfig和vim</p><p>​        *<em>定制要求 : *</em> 终端默认目录在/usr/local,支持ifconfig和vim</p><p>​        <strong>定制过程：</strong>        </p><p>​                <strong>1.编写Dockerfile 文件</strong>        </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span>  lyb&lt;<span class="number">734635746</span>@qq.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span>  MYPATH  /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">  yum -y install vim</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">  yum -y install net-tools</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br></pre></td></tr></table></figure><p>​                <strong>2.制作镜像</strong>        </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f Dockerfile  -t lyb/mycentcs:<span class="number">1.3</span> .</span><br></pre></td></tr></table></figure><p>​                <strong>3.根据镜像制作容器进行验证</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -<span class="keyword">it</span> lyb/mycentcs:<span class="number">1.3</span></span><br></pre></td></tr></table></figure><hr><p><strong>构建Tomcat9镜像</strong></p><p>​        <strong>构建前准备：</strong></p><ol><li><p>建立一个目录用于构建  /root/myTomcat</p></li><li><p>在上述目录下</p><p>新建</p><p>​    a.txt </p><p>​    Dockerfile </p><p>存放</p><p>​    apache-tomcat-9.0.8.tar.gz</p><p>​    jdk-8u241-linux-x64.tar.gz</p><p><strong>构建：</strong></p></li></ol><ol><li><p>编写Dockerfile </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span>  lyb&lt;<span class="number">734635746</span>@qq.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#把宿主机当前上下文的a.txt拷贝到容器/usr/loacal/路径下</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> c.txt  /usr/<span class="built_in">local</span>/container.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#把java与tomcat添加并解压到容器中</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> jdk-8u241-linux-x64.tar.gz  /usr/<span class="built_in">local</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> apache-tomcat-9.0.8.tar.gz  /usr/<span class="built_in">local</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装vim编译器</span></span><br><span class="line">RUM yum -y install vim</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置终端登陆目录</span></span><br><span class="line"><span class="keyword">ENV</span> MYPATH /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置java与tomcat环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/local/jdk1.<span class="number">8.0</span>_241</span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line"><span class="keyword">ENV</span> CATALINA_HOME /usr/local/apache-tomcat-<span class="number">9.0</span>.<span class="number">8</span></span><br><span class="line"><span class="keyword">eNV</span> CATALINA_BASE /usr/local/apache-tomcat-<span class="number">9.0</span>.<span class="number">8</span></span><br><span class="line"><span class="keyword">ENV</span> PATH $PATH:$JAVA_HOME/bin:$CAYALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line">$容器运行时监听的端口</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行时启动tomcat</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /usr/<span class="built_in">local</span>/apache-tomcat-9.0.8/bin/startup.sh &amp;&amp; tail -F /usr/<span class="built_in">local</span>/apache-tomcat-9.0.8/bin/logs/catalina.out</span></span><br></pre></td></tr></table></figure></li><li><p>制作镜像</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> <span class="keyword">build </span>Dockerfile  lyb/mytomcat9 .</span><br></pre></td></tr></table></figure></li></ol><h1 id="Docker小结"><a href="#Docker小结" class="headerlink" title="Docker小结"></a>Docker小结</h1><p><img src="https://s2.ax1x.com/2020/02/02/1Ydin0.png" alt="image"></p><h1 id="Docker常用安装"><a href="#Docker常用安装" class="headerlink" title="Docker常用安装"></a>Docker常用安装</h1><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p>​        <strong>拉取镜像</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:<span class="number">5.7</span></span><br></pre></td></tr></table></figure><p>​        <strong>新建并启动容器</strong></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p <span class="number">3306</span>:<span class="number">3306</span> --name mysql \</span><br><span class="line">-v /root/mysql_docker/<span class="symbol">conf:</span>/etc/mysql/conf.d \</span><br><span class="line">-v /root/mysql_docker/<span class="symbol">logs:</span>/logs \</span><br><span class="line">-v /root/mysql_docker/<span class="symbol">data:</span>/var/<span class="class"><span class="keyword">lib</span>/<span class="title">mysql</span> \</span></span><br><span class="line">-e MYSQL_ROOT_PASSWORD=<span class="number">123456</span> \</span><br><span class="line">-d <span class="symbol">mysql:</span><span class="number">5.7</span></span><br></pre></td></tr></table></figure><p>​        <strong>进入容器就可以操作mysql了</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it <span class="string">mysql:</span><span class="number">5.7</span> <span class="regexp">/bin/</span>bash</span><br></pre></td></tr></table></figure><h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><p>​        <strong>拉取镜像</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull <span class="keyword">redi</span><span class="variable">s:3</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure><p>​        <strong>新建并启动容器</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p <span class="number">6379</span>:<span class="number">6379</span> \</span><br><span class="line">-v <span class="regexp">/root/</span>redis_docker<span class="regexp">/data:/</span>data \</span><br><span class="line">-v <span class="regexp">/root/</span>redis_docker<span class="regexp">/conf/</span>redis.<span class="string">conf:</span><span class="regexp">/usr/</span>local<span class="regexp">/etc/</span>redis/redis.conf \</span><br><span class="line">-d <span class="string">redis:</span><span class="number">3.2</span> \</span><br><span class="line">redis-server <span class="regexp">/usr/</span>local<span class="regexp">/etc/</span>redis/redis.conf \</span><br><span class="line">--appendonly yes</span><br></pre></td></tr></table></figure><p>​        <strong>在宿主机建立redis.conf挂载到redis中</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /root/redis_docker/<span class="keyword">conf</span>/redis.<span class="keyword">conf</span></span><br><span class="line">touch redis.<span class="keyword">conf</span></span><br><span class="line"><span class="keyword">vim</span> redis.<span class="keyword">conf</span> (自行添加redis配置文件)</span><br></pre></td></tr></table></figure><p>​        <strong>测试redis-cli连接</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">exec</span> -it 容器ID redis-cli</span><br><span class="line"></span><br><span class="line">操作测试</span><br><span class="line"></span><br><span class="line"><span class="keyword">shutdown</span></span><br></pre></td></tr></table></figure><p>​        <strong>检查/root/redis_docker/data/appendonly.aof是否持久化成功</strong></p><h1 id="推送镜像到阿里云"><a href="#推送镜像到阿里云" class="headerlink" title="推送镜像到阿里云"></a>推送镜像到阿里云</h1><ol><li><p>准备好要推送的镜像，这里这接用上面案例制作的镜像</p></li><li><p>准备阿里云开发者平台 <a href="http://dev.aliyun.com/search.html" target="_blank" rel="noopener">http://dev.aliyun.com/search.html</a></p></li><li><p>建立镜像仓库(选择本地仓库)</p></li><li><p>将镜像推送到阿里云</p></li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker login --username=***(具体查看操作说明)***** registry.<span class="keyword">cn</span>-qingdao.aliyuncs.<span class="keyword">com</span></span><br><span class="line">$ sudo docker <span class="keyword">tag</span> [ImageId] registry.<span class="keyword">cn</span>-qingdao.aliyuncs.<span class="keyword">com</span>/lybhub/mycento<span class="variable">s:</span>[镜像版本号]</span><br><span class="line">$ sudo docker push registry.<span class="keyword">cn</span>-qingdao.aliyuncs.<span class="keyword">com</span>/lybhub/mycento<span class="variable">s:</span>[镜像版本号]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker为什么会出现&quot;&gt;&lt;a href=&quot;#Docker为什么会出现&quot; class=&quot;headerlink&quot; title=&quot;Docker为什么会出现&quot;&gt;&lt;/a&gt;Docker为什么会出现&lt;/h1&gt;&lt;p&gt;​    以前在服务器上部署一个应用，除了应用本身还要安装各种相应的软件、依赖，进行各种相应的配置。这种方式不仅费时费力还不能跨平台，不利于应用的集群部署。&lt;/p&gt;
&lt;p&gt;​        Docker的出现提供了一个解决方案，打破了&lt;code&gt;程序及应用&lt;/code&gt;的传统观念。&lt;code&gt;通过镜像（images）将作业系统核心除外，运作应用所需的系统环境，由下而上进行打包，达到应用程序跨平台无缝部署运行。&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Docker" scheme="http://liuyoubin.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Nginx学习笔记</title>
    <link href="http://liuyoubin.top/2020/01/29/backEnd/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://liuyoubin.top/2020/01/29/backEnd/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-01-29T15:36:02.000Z</published>
    <updated>2020-03-19T13:17:40.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx是什么"><a href="#Nginx是什么" class="headerlink" title="Nginx是什么?"></a>Nginx是什么?</h1><p>​        Nginx是一个高性能的HTTP和反向代理的web服务器，具有轻量级、占用内存少、并发能力强的特点。</p><a id="more"></a><h1 id="Nginx的应用"><a href="#Nginx的应用" class="headerlink" title="Nginx的应用"></a>Nginx的应用</h1><ol><li><p>Nginx作为Web服务器</p><p>​        Nginx可以作为静态页面的web服务器、支持CGI协议的动态语言，例如：php。</p></li><li><p>正向代理</p><p>​        Nginx可以作正向代理来进行上网。正向代理:是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。正向代理中客户端对于目标服务器是透明的。</p></li></ol><p><img src="https://s2.ax1x.com/2020/01/30/1lS7wV.png" alt="image"></p><ol start="3"><li><p>反向代理</p><p>​        反向代理：我们只 需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返 回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器 地址，隐藏了真实服务器 IP 地址。反向代理中目标服务器对于客户端是透明的。</p></li></ol><p><img src="https://s2.ax1x.com/2020/01/30/1lpVld.png" alt="image"></p><ol start="4"><li><p>负载均衡</p><p>​        客户端发送多个请求到服务器，服务器处理请求，再将结果返回给客户端。这种传统架构随着信息数量的增长以及业务的日益复杂，服务器性能渐渐出现了瓶颈。为了缓解服务器的压力我们可以将同一应用部署到多个服务器上对外提供同一种服务，这就是集群的概念。而将大量的请求负载分发到不同服务器上，这就是负载均衡。</p></li></ol><p><img src="https://s2.ax1x.com/2020/01/30/1lp20x.png" alt="image"></p><ol start="5"><li><p>动静分离</p><p>为了加快网址的解析速度，可以把网站的动态页面和静态页面让不同服务器来解析。</p></li></ol><p><img src="https://s2.ax1x.com/2020/01/30/1l9iBq.png" alt="image"></p><h1 id="Nginx的安装与启动"><a href="#Nginx的安装与启动" class="headerlink" title="Nginx的安装与启动"></a>Nginx的安装与启动</h1><p>nginx有windows版本和linux版本，windows版本的安装比较简单，这里主要记录Linux版本的安装</p><ol><li>进入Nginx的官网<a href="http://nginx.org选择版本进行下载，我这里选择nginx-1.12.1稳定版本进行安装" target="_blank" rel="noopener">http://nginx.org选择版本进行下载，我这里选择nginx-1.12.1稳定版本进行安装</a></li></ol><p><img src="https://s2.ax1x.com/2020/01/30/1lCui8.png" alt="image"></p><ol start="2"><li>安装nginx所需要的依赖</li></ol><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc <span class="literal">zlib</span> <span class="literal">zlib</span>-devel pcre-devel openssl openssl-devel</span><br></pre></td></tr></table></figure><ol start="3"><li>安装nginx</li></ol><ul><li>解压nginx-xxxx.tar.gz</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-zxvf</span> <span class="selector-tag">nginx-1</span><span class="selector-class">.12</span><span class="selector-class">.2</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure><ul><li>进入到nginx目录执行./configure命令 </li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./configure</span></span><br></pre></td></tr></table></figure><ul><li>执行安装命令</li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span> &amp;&amp; <span class="built_in">make</span> install</span><br></pre></td></tr></table></figure><ol start="4"><li><p>检查是否安装成功</p><p>​    进入到/usr/local中查看，如果安装成功会在这个目录下看到nginx目录。</p></li><li><p>启动nginx</p><p>在/usr/local/nginx/sbin中会有一个<code>nginx</code>启动命令。我们在这个目录下执行下面的命令就可以启动nginx了</p></li></ol><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./nginx</span></span><br></pre></td></tr></table></figure><p>​        通过检查进程确定nginx是否正确启动</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ps</span> -ef | <span class="keyword">grep</span> nginx</span><br></pre></td></tr></table></figure><h1 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h1><p>记住必须进入到/usr/local/nginx/sbin后才能使用nginx命令</p><ul><li><p>查看nginx版本号</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./nginx</span> -v</span><br></pre></td></tr></table></figure></li><li><p>启动nginx</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./nginx</span></span><br></pre></td></tr></table></figure></li><li><p>关闭nginx</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./nginx</span> -s stop 或者 <span class="string">./nginx</span> -s <span class="keyword">quit</span></span><br></pre></td></tr></table></figure></li><li><p>重加载</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./nginx</span> -s <span class="keyword">reload</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Nginx的配置文件"><a href="#Nginx的配置文件" class="headerlink" title="Nginx的配置文件"></a>Nginx的配置文件</h1><h2 id="配置文件位置"><a href="#配置文件位置" class="headerlink" title="配置文件位置"></a>配置文件位置</h2><p><code>/usr/local/nginx/conf/nginx.conf</code></p><h2 id="配置文件的组成"><a href="#配置文件的组成" class="headerlink" title="配置文件的组成"></a>配置文件的组成</h2><blockquote><p>nginx配置文件由三部分组成：全局块、events块、http块</p></blockquote><h3 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h3><p>​        从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配 置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以 及配置文件的引入等。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">来指定Nginx Worker进程运行用户以及用户组，默认由nobody账号运行。也可以创建nginx用户指定用户。</span><br><span class="line">可以通过</span><br><span class="line"><span class="attribute">groupadd</span> home </span><br><span class="line">useradd -g home lyb</span><br><span class="line">来增加用户组和用户</span><br><span class="line">*/</span><br><span class="line">user  nobody;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是</span><br><span class="line">会受到硬件、软件等设备的制约</span><br><span class="line">*/</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">用来定义全局错误日志文件。日志输出级别有debug、info、notice、warn、error、crit可供选择，其中，debug输出日志最为最详细，而crit输出日志最少。</span><br><span class="line">*/</span><br><span class="line"><span class="attribute">error_log</span>  logs/error.log;</span><br><span class="line"><span class="attribute">error_log</span>  logs/error.log  <span class="literal">notice</span>;</span><br><span class="line"><span class="attribute">error_log</span>  logs/error.log  <span class="literal">info</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">用来指定进程id的存储文件位置</span><br><span class="line">*/</span><br><span class="line"><span class="attribute">pid</span>   logs/nginx.pid;</span><br></pre></td></tr></table></figure><h3 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h3><p>​        events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">用来指定Nginx的工作模式。Nginx支持的工作模式有select、poll、kqueue、epoll、rtsig和/dev/poll。</span><br><span class="line"></span><br><span class="line">其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，不同的是epoll用在Linux平台上，而kqueue用在BSD系统中,对于Linux系统，epoll工作模式是首选。</span><br><span class="line">*/</span><br><span class="line"><span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">用于定义Nginx每个进程的最大连接数，即接收前端的最大请求数，默认是1024。</span><br><span class="line"></span><br><span class="line">最大客户端连接数由worker_processes和worker_connections决定，即Max_clients=worker_processes*worker_connections，</span><br><span class="line"></span><br><span class="line">在作为反向代理时，Max_clients变为：Max_clients = worker_processes * worker_connections/4</span><br><span class="line"></span><br><span class="line">进程的最大连接数受Linux系统进程的最大打开文件数限制，在执行操作系统命令“ulimit -n 65536”后worker_connections的设置才能生效。</span><br><span class="line">*/</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h3><p>​        这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意的是：http 块也可以包括 http 全局块、server 块</p><h4 id="http全局块"><a href="#http全局块" class="headerlink" title="http全局块"></a>http全局块</h4><p>​        http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">/**</span><br><span class="line">来用设定文件的mime类型,类型在配置文件目录下的mime.type文件定义，来告诉nginx来识别文件类型。</span><br><span class="line">*/</span><br><span class="line"><span class="attribute">include</span>       mime.types;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">设定了默认的类型为二进制流，也就是当文件类型未定义时使用这种方式，例如在没有配置asp的locate环境时，Nginx是不予解析的，此时，用浏览器访问asp文件就会出现下载了。</span><br><span class="line">*/</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">报文大小限制    </span><br><span class="line">*/</span><br><span class="line"><span class="attribute">client_max_body_size</span> <span class="number">1024m</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">用于设置日志的格式，和记录哪些参数，这里设置为main，刚好用于access_log来纪录这种类型。</span><br><span class="line">*/</span><br><span class="line">    <span class="comment">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">    <span class="comment">#                  '$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">    <span class="comment">#                  '"$http_user_agent" "$http_x_forwarded_for"';</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="server块"><a href="#server块" class="headerlink" title="server块"></a>server块</h4><p>​        这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了 节省互联网服务器硬件成本。 每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。 而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。</p><ul><li><p>全局server块</p><p>​        最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置</p><ul><li><p>listen：用于指定虚拟主机的服务端口。</p></li><li><p>server_name：用来指定IP地址或者域名，多个域名之间用空格分开。</p></li><li><p>root ：表示在这整个server虚拟主机内，全部的root web根目录。注意要和locate {}下面定义的区分开来</p></li><li><p>index ：全局定义访问的默认首页地址。注意要和locate {}下面定义的区分开来。</p></li><li><p>charset：用于设置网页的默认编码格式。</p></li><li><p>access_log：用来指定此虚拟主机的访问日志存放路径，最后的main用于指定访问日志的输出格式。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line">        <span class="attribute">root</span>   /Users/app/lyb;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.php; </span><br><span class="line">        <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line">        <span class="attribute">access_log</span>  logs/host.access.log  main;</span><br><span class="line">        <span class="attribute">aerror_log</span>  logs/host.<span class="literal">error</span>.log   main;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>location块</p><p>​        一个 server 块可以配置多个 location 块。 这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称 （也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓 存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</p></li></ul><h1 id="Nginx配置实例"><a href="#Nginx配置实例" class="headerlink" title="Nginx配置实例"></a>Nginx配置实例</h1><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p><strong>实现效果：</strong>在浏览器中输入<a href="http://www.lyb.com,跳转到Linux上的tomcat主页面" target="_blank" rel="noopener">www.lyb.com,跳转到Linux上的tomcat主页面</a></p><p><strong>准备工作：</strong> 在Linux安装nginx和tomcat</p><p><strong>开始配置：</strong></p><ul><li><p>在本地的host文件中配置<a href="http://www.lyb.com映射到nginx所在服务器的ip" target="_blank" rel="noopener">www.lyb.com映射到nginx所在服务器的ip</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务器<span class="selector-tag">ip</span> <span class="selector-tag">www</span><span class="selector-class">.lyb</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure></li><li><p>在nginx中进行反向代理配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">       listen       80; //监听的端口</span><br><span class="line">       server_name  **.**.**.**; //nginx所在服务器ip</span><br><span class="line">  </span><br><span class="line">       <span class="comment">#charset koi8-r;</span></span><br><span class="line">  </span><br><span class="line">       <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line">  </span><br><span class="line">       <span class="attribute">location</span> / &#123;</span><br><span class="line">           <span class="attribute">root</span>   html;</span><br><span class="line">           proxy_pass http://127.0.0.1:8080; //设置代理转发                                         index  index.html index.htm;                                                       &#125;</span><br><span class="line">   ....</span><br></pre></td></tr></table></figure></li><li><p>重启nginx即可实现反向代理转发</p></li></ul><p><strong>扩展：</strong></p><p>​        如果想实现根据不同的请求路径跳转到不同的服务可以设置多个location，例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">       listen       80; //监听的端口</span><br><span class="line">       server_name  **.**.**.**; //nginx所在服务器ip</span><br><span class="line"></span><br><span class="line">       <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">       <span class="attribute">location</span> <span class="regexp">~ /user/</span> &#123;</span><br><span class="line">           proxy_pass http://127.0.0.1:8080; //设置代理转发                                        &#125;</span><br><span class="line">           </span><br><span class="line">         <span class="attribute">location</span> <span class="regexp">~ /vod/</span> &#123;</span><br><span class="line">           proxy_pass http://127.0.0.1:8081; //设置代理转发                                        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ /oss/</span> &#123;</span><br><span class="line">           proxy_pass http://127.0.0.1:8082; //设置代理转发                                        &#125;</span><br><span class="line">      ....</span><br></pre></td></tr></table></figure><p><strong>location指令说明：</strong></p><p>​        该指令用于匹配URL，语法如下 </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> [ = | <span class="regexp">~ |</span> <span class="regexp">~* |</span><span class="regexp"> ^~</span> ] URL&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配 成功，就停止继续向下搜索并立即处理该请求</p></li><li><p>~：用于表示 uri 包含正则表达式，并且区分大小写</p></li><li><p>~*：用于表示 uri 包含正则表达式，并且不区分大小写</p></li><li><p>^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字 符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配</p></li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p><strong>实现效果：</strong>在浏览器中输入http://服务器ip/vod/a.html,让这个请求分发到8080和8081两给tomcat上，实现轮询负载均衡</p><p><strong>准备工作：</strong>在服务器上开启两个tomcat，一个监听8080端口，一个监听8081端口。分别在两个tomat下部署vod应用，在应用下放置a.html文件用于测试。</p><p><strong>开始配置：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">   upstream myserver&#123; //配置负载均衡模块</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:8081</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">47.105.165.248</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            proxy_pass http://myserver; //设置负载转发，这里填的是负载均衡模块的名字</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">      .......</span><br></pre></td></tr></table></figure><p><strong>扩展：</strong></p><p>​        <strong>Nginx提供几种负载均衡策略</strong></p><ul><li><p>轮询（默认）</p><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream myserver&#123; //配置负载均衡模块</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:8081</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>weight</p><p>weight 代表权重默认为 1,权重越高被分配的客户端越多 指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> myserver&#123;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.5.21</span> weight=<span class="number">1</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.5.22</span> weight=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ip_hash</p><p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> server_pool&#123;</span><br><span class="line">ip_hash;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.5.21:80</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.5.22:80</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>fair（第三方）</p><p>​        更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。</p></li></ul><p>  <strong>负载均衡调度状态</strong></p><p>  ​        在upstream模块中。server指令除了可以设置服务器的ip和端口，也可以设置负载均衡调度状态。</p><ul><li>down  表示这台服务器不参与负载均衡</li><li>backup  表示这台服务器作为备用机器，当所有其他非备用机器故障或宕机时才启用</li><li>max_fails  允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误</li><li>fail_timeout： 在经历过max_fails 次失败后，暂停服务的时间</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> server_group &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:80</span> backup;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.2:80</span> down;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.3:8080</span>  max_fails=<span class="number">3</span>  fail_timeout=<span class="number">20s</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.4:8080</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p><strong>实现效果：</strong>访问/www/a.html可以访问到服务器上/data/www/a.html,访问/image/scroll.png可以访问到服务器上/data/image/scroll.png</p><p><strong>准备工作：</strong>在Linux的/目录下一个data目录，data目录下建立一个www和image文件夹用于存放静态资源</p><p><strong>开始配置：</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">       <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">       <span class="attribute">server_name</span>  **.**.**.**;</span><br><span class="line"></span><br><span class="line">       <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">       <span class="attribute">location</span> /www/ &#123;</span><br><span class="line">           <span class="attribute">root</span>   /data/;</span><br><span class="line">           <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="attribute">location</span> /image/ &#123;</span><br><span class="line">           <span class="attribute">root</span> /data/;</span><br><span class="line">           autoindex on; //列出当前文件夹中的资源</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h1 id="Nginx高可用集群"><a href="#Nginx高可用集群" class="headerlink" title="Nginx高可用集群"></a>Nginx高可用集群</h1><p><strong>准备工作：</strong></p><ul><li><p>准备两台Linux服务器</p></li><li><p>两台服务器安装好nginx，参考上面的配置</p></li><li><p>两台服务器安装好keepalived</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> keepalived -y</span><br></pre></td></tr></table></figure><p>安装好后可以在/etc/中找到keepalived</p></li></ul><p><strong>Keepalived+Nginx(主从模式)</strong></p><ul><li>修改keeyalived.conf文件(/etc/keeyalived.conf)  可以参考以下配置</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line"> notification_email &#123;</span><br><span class="line"> </span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line">     notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">     smtp_server 192.168.17.129</span><br><span class="line">     smtp_connect_timeout 30</span><br><span class="line">     router_id LVS_DEVEL  #访问本机的名字，可以通过/etc/hots进行设置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_http_port &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in"> script </span><span class="string">"/usr/local/src/nginx_check.sh"</span> #脚本文件</span><br><span class="line"></span><br><span class="line">     interval 2 #（检测脚本执行的间隔）</span><br><span class="line"></span><br><span class="line">     weight -20 # 权重的改变，当服务器挂掉时做出改变</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">     state BACKUP # 备份服务器上将 MASTER 改为 BACKUP</span><br><span class="line">    <span class="built_in"> interface </span>ens33 #网卡，可以通过ifconfig进行查看</span><br><span class="line">     virtual_router_id 51 # 主、备机的 virtual_router_id 必须相同</span><br><span class="line">     priority 100 # 主、备机取不同的优先级，主机值较大，备份机值较小</span><br><span class="line">     advert_int 1  # 心跳检测时间</span><br><span class="line">     </span><br><span class="line">     authentication &#123; #权限验证</span><br><span class="line">         auth_type PASS</span><br><span class="line">         auth_pass 1111</span><br><span class="line">  &#125;</span><br><span class="line"> virtual_ipaddress &#123;</span><br><span class="line"> 192.168.17.50 #<span class="built_in"> VRRP </span>H 虚拟地址</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加nginx_check.sh 脚本文件，路径对应上面keeyalived.conf的配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">A=`ps -C nginx –no-header |wc -l`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$A</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line"> /usr/<span class="built_in">local</span>/nginx/sbin/nginx  <span class="comment">#nginx启动脚本位置</span></span><br><span class="line"> sleep 2</span><br><span class="line"> <span class="keyword">if</span> [ `ps -C nginx --no-header |wc -l` -eq 0 ];<span class="keyword">then</span></span><br><span class="line"> killall keepalived</span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li>启动Nginx和Keepalived</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./nginx</span><br><span class="line">systemctl <span class="literal">start</span> keepalived.service</span><br></pre></td></tr></table></figure><h1 id="Nginx原理"><a href="#Nginx原理" class="headerlink" title="Nginx原理"></a>Nginx原理</h1><p><strong>master&amp;worker</strong></p><p>​        nginx服务有一个master进程和多个woker进程(通过worker_processes决定)。master进程负责管理、监控worker进程，而worker进程负责具体的请求处理。</p><p>​        请求首先发给master进程，由master通知worker进行争抢。</p><p><img src="https://s2.ax1x.com/2020/01/31/11csLq.png" alt="image"></p><p>*<em>master-workers 的机制的好处 *</em></p><ul><li>对于每一个worker来说，由于是独立的进程，不需要加锁，节省的加锁带来的开销，彼此之间互不影响。</li><li>每一个worker独立工作，当一个进程退出后，其他进程还可以继续工作，降低了风险。master 进程可以很快启动新的 worker 进程</li><li>有利于热加载的实现</li></ul><p><strong>需要设置多少个 worker</strong></p><p>​        Nginx 同 redis 类似都采用了 io 多路复用机制，每个 worker 都是一个独立的进程，但每个进 程里只有一个主线程，通过异步非阻塞的方式来处理请求， 即使是千上万个请求也不在话 下。每个 worker 的线程可以把一个 cpu 的性能发挥到极致。所以 worker 数和服务器的 cpu 数相等是最为适宜的。设少了会浪费 cpu，设多了会造成 cpu 频繁切换上下文带来的损耗。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置 worker 数量。</span></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#work 绑定 cpu(4 work 绑定 4cpu)。</span></span><br><span class="line">worker_cpu_affinity <span class="number">0001</span> <span class="number">0010</span> <span class="number">0100</span> <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#work 绑定 cpu (4 work 绑定 8cpu 中的 4 个) 。</span></span><br><span class="line">worker_cpu_affinity <span class="number">0000001</span> <span class="number">00000010</span> <span class="number">00000100</span> <span class="number">00001000</span></span><br></pre></td></tr></table></figure><p><strong>连接数 worker_connection</strong></p><p>​        这个值是表示每个 worker 进程所能建立连接的最大值，所以，一个 nginx 能建立的最大连接 数，应该是 worker_connections * worker_processes。当然，这里说的是最大连接数，对于 HTTP 请 求 本 地 资 源 来 说 ， 能 够 支 持 的 最 大 并 发 数 量 是 worker_connections * worker_processes，如果是支持 http1.1 的浏览器每次访问要占两个连接，所以普通的静态访 问最大并发数是： worker_connections * worker_processes /2，而如果是 HTTP 作 为反向代 理来说，最大并发数量应该是 worker_connections * worker_processes/4。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服 务的连接，会占用两个连接。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Nginx是什么&quot;&gt;&lt;a href=&quot;#Nginx是什么&quot; class=&quot;headerlink&quot; title=&quot;Nginx是什么?&quot;&gt;&lt;/a&gt;Nginx是什么?&lt;/h1&gt;&lt;p&gt;​        Nginx是一个高性能的HTTP和反向代理的web服务器，具有轻量级、占用内存少、并发能力强的特点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Nginx" scheme="http://liuyoubin.top/tags/Nginx/"/>
    
  </entry>
  
</feed>
