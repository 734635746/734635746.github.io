<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>何处似樽前</title>
  
  <subtitle>博观而约取，厚积而薄发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liuyoubin.top/"/>
  <updated>2020-03-24T09:48:59.331Z</updated>
  <id>http://liuyoubin.top/</id>
  
  <author>
    <name>liuyoubin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MyCat入门</title>
    <link href="http://liuyoubin.top/2020/03/14/backEnd/database/MyCat%E5%85%A5%E9%97%A8/"/>
    <id>http://liuyoubin.top/2020/03/14/backEnd/database/MyCat%E5%85%A5%E9%97%A8/</id>
    <published>2020-03-14T08:35:28.000Z</published>
    <updated>2020-03-24T09:48:59.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>​        MyCat 是一个开源的分布式数据库系统，但是由于真正的数据库需要存储引擎，而 Mycat 并没有存 储引擎，所以并不是完全意义的分布式数据库系统<br> ​        MyCat是一个数据库中间件，也可以理解为是数据库代理。在架构体系中是位于数据库和应用层之间的一个组件，并且对于应用层是透明的，即数据库 感受不到mycat的存在，认为是直接连接的mysql数据库（实际上是连接的mycat,mycat实现了mysql的原生协议）</p></blockquote><p><strong>MyCat的核心功能：读写分离、分库分表</strong></p><a id="more"></a><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>​        MyCat的原理就是<strong>“拦截”</strong>，它拦截了用户发送的SQL语句，首先对SQL语句做一些特定的分析：如<strong>分片分析、路由分析、读写分离分析、缓存分析</strong>，然后将数据库发往后端的真实数据库，并将返回结果做适当的处理，最终返回给用户。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li><p>到官网 <a href="http://www.mycat.io/" target="_blank" rel="noopener">http://www.mycat.io/</a> 下载合适的安装包</p></li><li><p>解压安装包，并把解压后文件拷贝到/usr/local下</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz</span><br><span class="line">mv mycat /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>三个重要的配置文件</p><ol><li><p>schema.xml 定义了逻辑库、逻辑表、分片节点等内容</p><p><img src="https://s1.ax1x.com/2020/03/14/8l2xC6.png" alt="imgae"></p></li><li><p>rule.xml 定义了分片规则</p></li><li><p>server.xml 定义用户以及系统相关变量，如端口</p><p><img src="https://s1.ax1x.com/2020/03/14/8lcQbR.png" alt="image"></p></li></ol></li></ol><h1 id="启动与登陆"><a href="#启动与登陆" class="headerlink" title="启动与登陆"></a>启动与登陆</h1><ol><li><p>在启动前确保远程数据库可以正常访问</p></li><li><p>启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mycat/bin</span><br><span class="line"></span><br><span class="line"><span class="comment">#控制台启动</span></span><br><span class="line">./mycat console</span><br><span class="line"></span><br><span class="line"><span class="comment">#后台启动</span></span><br><span class="line">./mycat start</span><br></pre></td></tr></table></figure></li><li><p>登陆</p><ol><li><p>登陆后台管理窗口（用于运维）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -umycat -p123456 -P9066 -h ip地址</span><br></pre></td></tr></table></figure></li><li><p>登陆数据窗口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -umycat -p123456 -P8066 -h ip地址</span><br></pre></td></tr></table></figure></li></ol></li></ol><h1 id="搭建读写分离"><a href="#搭建读写分离" class="headerlink" title="搭建读写分离"></a>搭建读写分离</h1><p>​        <strong>我们通过Mycat的读写分离配置MySQL的主从复制，实现MySQL的高可用性。</strong></p><h2 id="读写分离架构"><a href="#读写分离架构" class="headerlink" title="读写分离架构"></a>读写分离架构</h2><p><img src="https://s1.ax1x.com/2020/03/14/8l5sg0.png" alt="image"></p><h2 id="MySQL主从复制原理图"><a href="#MySQL主从复制原理图" class="headerlink" title="MySQL主从复制原理图"></a>MySQL主从复制原理图</h2><p><img src="https://s1.ax1x.com/2020/03/15/81pHf0.png" alt="image"></p><h2 id="单主单从模式"><a href="#单主单从模式" class="headerlink" title="单主单从模式"></a>单主单从模式</h2><h3 id="搭建主从复制"><a href="#搭建主从复制" class="headerlink" title="搭建主从复制"></a>搭建主从复制</h3><ol><li>修改配置文件</li></ol><ul><li>修改主服务器配置文件（/etc/my.cnf）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#主服务器唯一ID</span><br><span class="line">server-id&#x3D;1</span><br><span class="line">#启用二进制文件</span><br><span class="line">log-bin&#x3D;mysql-bin</span><br><span class="line">#设置不用复制的数据库(可设置多个)</span><br><span class="line">binlog-ignore-db&#x3D;mysql</span><br><span class="line">#设置需要复制的数据库(可设置多个)</span><br><span class="line">binlog-do-db&#x3D;</span><br><span class="line">#设置logbin格式</span><br><span class="line">binlog_format&#x3D;STATEMENT</span><br></pre></td></tr></table></figure><ul><li>修改从服务器配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#从服务器唯一ID</span><br><span class="line">server-id&#x3D;2</span><br><span class="line">#启用中继日志</span><br><span class="line">relay-log&#x3D;mysql-relay</span><br></pre></td></tr></table></figure><ol start="2"><li><p>重启两台机器的mysql服务</p></li><li><p>在主机上授权slave权限给远程主机 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#39;slave&#39;@&#39;%&#39; IDENTIFIED BY &#39;密码&#39;</span><br></pre></td></tr></table></figure></li><li><p>查询主机的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/03/15/88DXKH.png" alt="image"></p></li><li><p>在从机上配置需要复制的主机信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">#停止复制功能、重置主从语句，如果已经启动复制功能的话</span></span><br><span class="line">  stop slave;</span><br><span class="line">  reset master;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#在从机执行以下命令</span></span><br><span class="line">  CHANGE MASTER TO MASTER_HOST=<span class="string">'主机的ip地址'</span>,</span><br><span class="line">  MASTER_USER=<span class="string">'salve'</span>,</span><br><span class="line">  MASTER_PASSWORD=<span class="string">'密码'</span>,</span><br><span class="line">  MASTER_LOG_FILE=<span class="string">'mysql-bin.具体数字'</span>,</span><br><span class="line">  MASTER_LOG_POS=<span class="string">'接入点'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#启动从服务器的复制功能</span></span><br><span class="line">  start slave;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#查看从服务器的状态</span></span><br><span class="line">  show slave status\G;</span><br><span class="line">  <span class="comment">#出现以下两个参数都是yes，代表主从配置成功</span></span><br><span class="line">Slave_IO_Running:Yes</span><br><span class="line">  Slave_SQL_Running:Yes</span><br></pre></td></tr></table></figure></li></ol><h3 id="搭建读写分离-1"><a href="#搭建读写分离-1" class="headerlink" title="搭建读写分离"></a>搭建读写分离</h3><ol><li><p>修改MyCat的配置文件server.xml</p><p><img src="https://s1.ax1x.com/2020/03/14/8lcQbR.png" alt="image"></p></li><li><p>修改MyCat的配置文件schema.xml</p><p><img src="https://s1.ax1x.com/2020/03/14/8l2xC6.png" alt="imgae"></p></li><li><p>设置读写分离的类型，在<dataHost>的balance属性进行设置</p><table><thead><tr><th align="center">balance值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">不开启读写分离机制，所有读操作都发送到当前可用的writeHost上</td></tr><tr><td align="center">1</td><td align="center">全部的readHost和stand by writeHost参与select语句的负载均衡。也就是说在双主双从模式下(M1-&gt;S1,M2-&gt;S2并且M1、M2互为主备)，正常情况下M2、S1、S2都参加select语句的负载。</td></tr><tr><td align="center">2</td><td align="center">所有的读请求都随机在writeHost和readHost上分发</td></tr><tr><td align="center">3</td><td align="center">所有的读请求随机在readHost上执行，writteHost不承担读压力</td></tr></tbody></table><p>PS：在多主多从模式下也只能有一个写主机负载写操作</p><p><strong>推荐在双主双从模式下设置成1，在单主单从模式下设置成3</strong></p></li><li><p>开启MyCat</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/usr/local/mycat/bin</span></span><br><span class="line"></span><br><span class="line"><span class="string">./mycat</span> console</span><br></pre></td></tr></table></figure></li><li><p>验证读写分离</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">1</span>. 在主机插入<span class="selector-tag">insert</span> <span class="selector-tag">into</span> <span class="selector-tag">user</span> <span class="selector-tag">values</span>(<span class="number">1</span>,<span class="variable">@@hostname</span>);  <span class="comment">//主从机器的数据不一样了</span></span><br><span class="line"><span class="selector-tag">2</span>. 在<span class="selector-tag">mycat</span>进行查询 <span class="selector-tag">select</span> * <span class="selector-tag">from</span> <span class="selector-tag">user</span>; <span class="comment">//可以判断读写分离是否成功</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="双主双从模式"><a href="#双主双从模式" class="headerlink" title="双主双从模式"></a>双主双从模式</h2><p>​        相较于单主但从的读写分离模式，双主双从模式的可用性更高。一个主机m1负责处理所有的写请求，它的从机s1和另一台主机m2和从机s2负责所有的读请求。当m1宕机后，m2负责写请求，m1、m2互为备机。</p><p><img src="https://s1.ax1x.com/2020/03/18/8DP23q.png" alt="image"></p><h3 id="搭建主从复制-1"><a href="#搭建主从复制-1" class="headerlink" title="搭建主从复制"></a>搭建主从复制</h3><ol><li><p>双主机配置</p><ol><li>Master1配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#主服务器唯一ID</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="comment">#启用二进制文件</span></span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br><span class="line"><span class="comment">#设置不用复制的数据库(可设置多个)</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line"><span class="comment">#设置需要复制的数据库(可设置多个)</span></span><br><span class="line">binlog-do-db=</span><br><span class="line"><span class="comment">#设置logbin格式</span></span><br><span class="line">binlog_format=STATEMENT</span><br><span class="line"><span class="comment">#在作为从数据库的时候，有写入操作也要更新二进制文件</span></span><br><span class="line"><span class="built_in">log</span>-slave-updates</span><br><span class="line"><span class="comment">#表示自增长字段每次递增的量，默认值是1取值范围是1~65535</span></span><br><span class="line">auto-increment-increment=2</span><br><span class="line"><span class="comment">#表示自增长字段从哪个数开始,取值范围是1~65535</span></span><br><span class="line">auto-increment-offset=1</span><br></pre></td></tr></table></figure><ol start="2"><li><p>Master2配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#主服务器唯一ID</span></span><br><span class="line">server-id=3</span><br><span class="line"><span class="comment">#启用二进制文件</span></span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br><span class="line"><span class="comment">#设置不用复制的数据库(可设置多个)</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line"><span class="comment">#设置需要复制的数据库(可设置多个)</span></span><br><span class="line">binlog-do-db=</span><br><span class="line"><span class="comment">#设置logbin格式</span></span><br><span class="line">binlog_format=STATEMENT</span><br><span class="line"><span class="comment">#在作为从数据库的时候，有写入操作也要更新二进制文件</span></span><br><span class="line"><span class="built_in">log</span>-slave-updates</span><br><span class="line"><span class="comment">#表示自增长字段每次递增的量，默认值是1取值范围是1~65535</span></span><br><span class="line">auto-increment-increment=2</span><br><span class="line"><span class="comment">#表示自增长字段从哪个数开始,取值范围是1~65535</span></span><br><span class="line">auto-increment-offset=2</span><br></pre></td></tr></table></figure></li></ol></li></ol><ol start="2"><li><p>双从机配置</p><ol><li><p>slave1配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从服务器唯一ID</span></span><br><span class="line">server-id=2</span><br><span class="line"><span class="comment">#启用中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure></li><li><p>slave2配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从服务器唯一ID</span></span><br><span class="line">server-id=4</span><br><span class="line"><span class="comment">#启用中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure></li></ol></li></ol><ol start="3"><li><p>双主机授权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#39;slave&#39;@&#39;%&#39; IDENTIFIED BY &#39;密码&#39;</span><br></pre></td></tr></table></figure></li><li><p>查询双主机的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure></li><li><p>在双从机上配置需要复制的主机信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#停止复制功能、重置主从语句，如果已经启动复制功能的话</span><br><span class="line">stop slave;</span><br><span class="line">reset master;</span><br><span class="line"></span><br><span class="line">#在从机执行以下命令</span><br><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;主机的ip地址&#39;,</span><br><span class="line">MASTER_USER&#x3D;&#39;salve&#39;,</span><br><span class="line">MASTER_PASSWORD&#x3D;&#39;密码&#39;,</span><br><span class="line">MASTER_LOG_FILE&#x3D;&#39;mysql-bin.具体数字&#39;,</span><br><span class="line">MASTER_LOG_POS&#x3D;&#39;接入点&#39;;</span><br><span class="line"></span><br><span class="line">#启动从服务器的复制功能</span><br><span class="line">start slave;</span><br><span class="line"></span><br><span class="line">#查看从服务器的状态</span><br><span class="line">show slave status\G;</span><br><span class="line">#出现以下两个参数都是yes，代表主从配置成功</span><br><span class="line">Slave_IO_Running:Yes</span><br><span class="line">Slave_SQL_Running:Yes</span><br></pre></td></tr></table></figure></li><li><p>两个主机相互复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#在两台主机下执行以下命令</span><br><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;另一台主机的ip地址&#39;,</span><br><span class="line">MASTER_USER&#x3D;&#39;salve&#39;,</span><br><span class="line">MASTER_PASSWORD&#x3D;&#39;密码&#39;,</span><br><span class="line">MASTER_LOG_FILE&#x3D;&#39;mysql-bin.具体数字&#39;,</span><br><span class="line">MASTER_LOG_POS&#x3D;&#39;接入点&#39;;</span><br><span class="line"></span><br><span class="line">#启动从服务器的复制功能</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>​                                                                                                                        </p></li></ol><h3 id="搭建读写分离-2"><a href="#搭建读写分离-2" class="headerlink" title="搭建读写分离"></a>搭建读写分离</h3><ol><li><p>修改MyCat的配置文件schema.xml</p><p><img src="https://s1.ax1x.com/2020/03/19/8yzQMV.png" alt="image"></p></li></ol><ul><li>配置项说明<ul><li>balance=1 两台读主机和写主机的备机负责读操作</li><li>writeType=0  所有写操作发布到第一个writeHost，第一个挂了还能切换到第二个</li><li>switchType=1<ul><li>1   默认值，自动切换</li><li>-1  不自动切换</li><li>2  基于MySql的主从同步状态决定是否切换</li></ul></li></ul></li></ul><ol start="2"><li><p>启动MyCat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mycat/bin</span><br><span class="line"></span><br><span class="line"><span class="comment">#控制台启动</span></span><br><span class="line">./mycat console</span><br></pre></td></tr></table></figure></li><li><p>验证读写分离 </p></li></ol><h1 id="垂直划分"><a href="#垂直划分" class="headerlink" title="垂直划分"></a>垂直划分</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​        一个数据库有很多张表，每张表分别处理不同的业务。垂直划分就是根据业务的耦合性将关联度低的表存在不同的数据库上。</p><p>​        垂直划分可以分为<strong>垂直分表</strong>和 <strong>垂直分库</strong>。垂直分库是指按照业务将表进行分类，分布到不同的数据库上面。垂直分表是基于数据库中的”列”进行，某个表字段较多，可以新建一张扩展表，将不经常用或字段长度较大的字段拆分出去到扩展表中。</p><p><img src="https://s1.ax1x.com/2020/03/21/8h0MZT.png" alt="image"></p><p><strong>垂直划分的优点</strong></p><ul><li>解决业务系统层面的耦合，业务清晰</li><li>与微服务的治理类似，也能对不同业务的数据进行分级管理、维护、监控、扩展等</li><li>高并发场景下，垂直切分一定程度的提升IO、数据库连接数、单机硬件资源的瓶颈</li></ul><p><strong>垂直划分的缺点</strong></p><ul><li>部分表无法join，只能通过接口聚合方式解决，提升了开发的复杂度</li><li>分布式事务处理复杂</li><li>依然存在单表数据量过大的问题（需要水平化分）</li></ul><h2 id="搭建垂直分库"><a href="#搭建垂直分库" class="headerlink" title="搭建垂直分库"></a>搭建垂直分库</h2><p>​        <strong>需求：</strong>现在有客户表、订单表、订单详情表、数据字典表。考虑到表的数据量过大，现在准备进行垂直分库操作。按照业务的划分，决定将客户表单独划分到一个数据库，其他三张表存到一个数据库。</p><p>​        <strong>PS：</strong>垂直分库的数据库可以放在同一个主机实例上，也可以放在不同的主机实例上，具体通过配置文件进行配置。</p><ol><li>修改schema.xml 配置文件</li></ol><p><img src="https://s1.ax1x.com/2020/03/20/8gzggA.png" alt="image"></p><ol start="2"><li><p>启动MyCat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mycat/bin</span><br><span class="line">./mycat console</span><br></pre></td></tr></table></figure><p>​        垂直分库完成后，程序连接MyCat只能看到TESTDB这个逻辑库，逻辑库中有客户表、订单表、订单详情表、数据字典表四张表。这四张表分别在两个数据库中，但是程序可以无感知地操作TESTDB一个数据库来操作四张表。</p><p>​                                                                                                                                        </p></li></ol><h1 id="水平划分"><a href="#水平划分" class="headerlink" title="水平划分"></a>水平划分</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>​        MySql单表存储数据数量是有瓶颈的，单表达到1000万条数据就达到了瓶颈，会影响查询效率，这时可以进行水平划分进行优化。</p><p>​        水平划分又分为<strong>水平分库</strong>和<strong>水平分表</strong>。水平分表（库内分表）只解决单表数据过大的问题，对于数据库压力的缓解帮助不是很大，最好还是采用水平分库，将表分布到不同数据库中。</p><p><img src="https://s1.ax1x.com/2020/03/21/8hw1gI.png" alt="image"></p><p><strong>水平划分的优点</strong></p><ul><li>解决单库数据量过大、高并发的性能瓶颈，提升系统稳定性和负载能力</li><li>应用端改造较小，不需要拆分业务模块</li></ul><p><strong>水平划分的缺点</strong></p><ul><li>对于分片事务难以保证一致性</li><li>跨库join连接查询性能差</li></ul><h2 id="搭建水平分库"><a href="#搭建水平分库" class="headerlink" title="搭建水平分库"></a>搭建水平分库</h2><p><strong>需求</strong>：现在数据库有一张订单表数据量已经达到了600万数据，现在准备进行水平分库优化。经过考虑后准备根据客户id进行划分，使得同一个客户的订单在同一张表上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;表结构如下</span><br><span class="line">CREATE TABLE orders(</span><br><span class="line">id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    order_type INT,</span><br><span class="line">    customer_id INT,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li><p>修改schema.xml文件</p><p><code>将orders表通过mod_rule规则划分到dn1、dn2两个分片上</code></p><p><img src="https://s1.ax1x.com/2020/03/22/84e8US.png" alt="image"></p></li><li><p>修改rule.xml文件修改分片规则</p><p><img src="https://s1.ax1x.com/2020/03/22/84XCSe.png" alt="image"></p></li></ol><ul><li><p>分片算法mod-log</p><p>对指定字段进行节点取模运算，根据结果进行分片</p></li></ul><p><img src="https://s1.ax1x.com/2020/03/22/84jd4f.png" alt="image"></p><ol start="3"><li>启动MyCat</li></ol><h2 id="MyCat分片的“Join”"><a href="#MyCat分片的“Join”" class="headerlink" title="MyCat分片的“Join”"></a>MyCat分片的“Join”</h2><p>​        Orders订单表现在已经被分到dn1、dn2两个分片上，那么和它关联的订单详情表order_detail如何进行关联呢?。答案是同时要对订单详情表进行分片操作,可以采用基于E-R表的分片策略进行解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;订单详情表</span><br><span class="line">CREATE TABLE orders_detail(</span><br><span class="line">id INT AUTO_INCREMENT,</span><br><span class="line">    detail VARCHAR(2000),</span><br><span class="line">    order_id INT,</span><br><span class="line">    PRIMARY KEY(id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>​        除了订单详情表还有一张字典表dict_order_type，不管是订单表还是订单详情表都需要数据字典表的数据，可以说这是一张全局表，那全局表应该怎么解决。考虑到字典表有几个特征：</p><ul><li><p>变动不频繁</p></li><li><p>数据量不大</p><p>鉴于此，MyCat定义了“全局表”来进行解决。</p></li></ul><p><img src="https://s1.ax1x.com/2020/03/22/8592VJ.png" alt="image"></p><h3 id="ER表"><a href="#ER表" class="headerlink" title="ER表"></a>ER表</h3><p>​        <strong>MyCat提出了基于E-R关系的数据分片策略，子表的记录与关联的父表记录存储在同一个数据分片上，彻底解决JOIN的的效率和性能问题。</strong></p><p><img src="https://s1.ax1x.com/2020/03/22/857VUS.png" alt="image"></p><p>​                                                                                                                                    </p><h3 id="全局表"><a href="#全局表" class="headerlink" title="全局表"></a>全局表</h3><p>​        <strong>全局表具有以下特征</strong></p><ul><li>全局表的插入、更新会在所有节点上执行，保证分片数据的一致性</li><li>全局表的查询操作只能在一个节点获取</li><li>全局表可以和任何一个表进行Join操作</li></ul><p><img src="https://s1.ax1x.com/2020/03/22/8IEYgs.png" alt="image"></p><h2 id="常用的分片操作"><a href="#常用的分片操作" class="headerlink" title="常用的分片操作"></a>常用的分片操作</h2><h3 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h3><p>​        对分片的指定字段求模运算，对结果进行分片，是一种常用的分片规则。具体参考上面搭建水平分库的过程。</p><h3 id="分片枚举"><a href="#分片枚举" class="headerlink" title="分片枚举"></a>分片枚举</h3><p>​        通过在配置文件中配置可能的枚举id，自己配置分片，本规则适用于特定场景。比如有些业务需要按照省份或区县进行保存，此类业务使用于本条规则。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#修改schema.xml文件</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"order_info"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"store_by_intfile"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#修改rule.xml文件</span><br><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"store_by_intfile"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">columns</span>&gt;</span>areacode<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>hash-int<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"hash-int"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByFileMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>partition-hash-int.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"type"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultNode"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>columns : 分片字段</li><li>alogrithm：分片函数</li><li>mapFile：标识配置文件名称</li><li>type：0为int型，非0为String型（这里的类型指的是分片字段的类型）</li><li>defaultNode：默认节点，小于0表示不设置默认节点，大于等于0表示设置默认节点。设置默认节点如果碰到不能识别的枚举值，就路由到默认节点。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#修改partition-hash-int.txt文件</span><br><span class="line">110=0 //areacode为110路由到0分片</span><br><span class="line">120=1 //areacode为120路由到1分片</span><br></pre></td></tr></table></figure><h3 id="范围约定"><a href="#范围约定" class="headerlink" title="范围约定"></a>范围约定</h3><p>​        此分片适用于提前规划好分片字段属于哪个分片。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#修改schema.xml文件</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"pay_info"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"auto_sharding_long"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#修改rule.xml文件</span><br><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"auto_sharding_long"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">columns</span>&gt;</span>order_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>rang-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"rang-long"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">"io.mycat.route.function.AutoPartitionByLong"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>autopartition-long.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultNode"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>columns : 分片字段</li><li>alogrithm：分片函数</li><li>mapFile：标识配置文件名称</li><li>defaultNode：默认节点，小于0表示不设置默认节点，大于等于0表示设置默认节点。设置默认节点如果碰到不能识别的枚举值，就路由到默认节点。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#修改autopartition-long.txt文件</span><br><span class="line">0-200=0 //order_id在0~200路由到0分片</span><br><span class="line">201-400=1 //order_id在201~400路由到1分片</span><br></pre></td></tr></table></figure><h3 id="日期划分"><a href="#日期划分" class="headerlink" title="日期划分"></a>日期划分</h3><p>​        此规则为按天分片，设定时间格式、范围。</p><p>例如：按照登陆日期分片存放数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#修改schema.xml文件</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"login_info"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"sharding_by_date"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#修改rule.xml文件</span><br><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding_by_date"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">columns</span>&gt;</span>login_date<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>shardingByDate<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"shardingByDate"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByDate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateFormat"</span>&gt;</span>yyyy-MM-dd<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sBeginDate"</span>&gt;</span>2020-01-01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sEndDate"</span>&gt;</span>2020-01-04<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sPartionDate"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>columns : 分片字段</li><li>alogrithm：分片函数</li><li>dateFormat：日期格式</li><li>sBeginDate：开始日期</li><li>sEndDate：结束日期，数据达到这个日期的分片后开始循环分片插入</li><li>sPartionDate：分区天数，即默认从开始日期算起，分隔2天一个分区</li></ul><h1 id="全局序列"><a href="#全局序列" class="headerlink" title="全局序列"></a>全局序列</h1><p>​        <strong>在实现分库分表的情况下，数据库自增主键已无法保证自增主键的唯一性，为此MyCat提供了全局序列(sequence),并且包含本地配置和数据库配置等多种实现。</strong></p><h2 id="本地文件"><a href="#本地文件" class="headerlink" title="本地文件"></a>本地文件</h2><p>​        此方法MyCat将sequence配置到文件中，当使用到sequence中的配置后，Mycat会更新classpath中的sequence_conf.properties文件中sequence当前值。<strong>(不推荐)</strong></p><p>优点：本地加载，读取速度快</p><p>缺点：抗风险能力差，MyCat主机宕机后，无法读取本地文件</p><h2 id="时间戳方式"><a href="#时间戳方式" class="headerlink" title="时间戳方式"></a>时间戳方式</h2><p>​        全局序列 ID=64位二进制（42毫秒+5位机器码+5位业务编码+12位重复累加）换算成18位十进制long类型，每毫秒可以并发12位二进制累加。<strong>(不推荐)</strong></p><p>优点：配置简单</p><p>缺点：18位ID过长</p><h2 id="数据库方式"><a href="#数据库方式" class="headerlink" title="数据库方式"></a>数据库方式</h2><p>​        利用数据库一张表（存放 sequence 名称(name)，sequence 当前值(current_value)，步长(increment int 类型每次读取多少个 sequence，假设为 K)等信息）来进行计数累加，MyCat会预加载一部分号段到Mycat内存中，如果内存中的序列号用完或者MyCat宕机重启再向数据库要一次。<strong>（推荐）</strong></p><p><strong>原理步骤：</strong></p><p>​        当初次使用该 sequence 时，根据传入的 sequence 名称，从数据库这张表中读取 current_value，和 increment 到 MyCat 中，并将数据库中的 current_value 设置为原 current_value 值+increment 值； .</p><p>​        MyCat 将读取到 current_value+increment 作为本次要使用的 sequence 值，下次使用时，自动加 1，当 使用 increment 次后，执行步骤 1)相同的操作. MyCat 负责维护这张表，用到哪些 sequence，只需要在这张表中插入一条记录即可。若某次读取的 sequence 没有用完，系统就停掉了，则这次读取的 sequence 剩余值不会再使用。</p><ol><li><p>修改server.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//全局序列类型 0-本地文件 1-数据库方式 2-时间戳方式</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sequnceHandlerType"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改Mycat 配置文件 sequence_db_conf.properties</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GLOBAL=dn1</span><br><span class="line">COMPANY=dn1</span><br><span class="line">CUSTOMER=dn1</span><br><span class="line">ORDERS=dn1 //ORDERS这张表的序列在dn1上</span><br></pre></td></tr></table></figure></li><li><p>建立序列脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#在dn1上创建全局序列表</span><br><span class="line">CREATE TABLE mycat_source(</span><br><span class="line">    name VARCHAR(50) NOT NULL,</span><br><span class="line">current_value INT NOT NULL,</span><br><span class="line">increment INT NOT NULL DEFALUT 100,</span><br><span class="line">PRIMARY KEY(name)</span><br><span class="line">)ENGINE&#x3D;INNODB;</span><br><span class="line"></span><br><span class="line">#获取当前sequence值的存储过程</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE FUNCTION mycat_seq_currval(seq_name VARCHAR(50)) RETURNS varchar(64)     CHARSET utf8</span><br><span class="line">DETERMINISTIC</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE retval VARCHAR(64);</span><br><span class="line">SET retval&#x3D;&quot;-999999999,null&quot;;</span><br><span class="line">SELECT concat(CAST(current_value AS CHAR),&quot;,&quot;,CAST(increment AS CHAR)) INTO retval FROM MYCAT_SEQUENCE WHERE name &#x3D; seq_name;</span><br><span class="line">RETURN retval;</span><br><span class="line">END $</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#设置sequence值的存储过程</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE FUNCTION mycat_seq_setval(seq_name VARCHAR(50),value INTEGER) RETURNS     varchar(64) CHARSET utf8</span><br><span class="line">DETERMINISTIC</span><br><span class="line">BEGIN</span><br><span class="line">UPDATE MYCAT_SEQUENCE</span><br><span class="line">SET current_value &#x3D; value</span><br><span class="line">WHERE name &#x3D; seq_name;</span><br><span class="line">RETURN mycat_seq_currval(seq_name);</span><br><span class="line">END $</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#获取下一个sequence值的存储过程</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE FUNCTION mycat_seq_nextval(seq_name VARCHAR(50)) RETURNS varchar(64)     CHARSET utf8</span><br><span class="line">DETERMINISTIC</span><br><span class="line">BEGIN</span><br><span class="line">UPDATE MYCAT_SEQUENCE</span><br><span class="line">SET current_value &#x3D; current_value + increment WHERE name &#x3D; seq_name;</span><br><span class="line">RETURN mycat_seq_currval(seq_name);</span><br><span class="line">END $</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><ol start="4"><li>插入orders表的sequence信息</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO mycat_source VALUES(&#39;ORDERS&#39;,10000,100);</span><br></pre></td></tr></table></figure></li></ol><h2 id="自主生成"><a href="#自主生成" class="headerlink" title="自主生成"></a>自主生成</h2><p>   ​        直接在项目里根据业务逻辑生成全局序列</p><h1 id="MyCat安全设置"><a href="#MyCat安全设置" class="headerlink" title="MyCat安全设置"></a>MyCat安全设置</h1><h2 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a>权限配置</h2><ol><li><p><strong>user标签权限控制</strong></p><p>​        目签MyCat对于中间件的连接控制只做了中间件逻辑库级别的读写权限控制，通过server.xml的user标签进行配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"mycat"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>user<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"readOnly"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">标签属性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">name</td><td align="center">应用连接MyCat逻辑库的用户名</td></tr><tr><td align="center">password</td><td align="center">用户对应的密码</td></tr><tr><td align="center">TESTDB</td><td align="center">应用当前连接逻辑库，schemas可以配置多个</td></tr><tr><td align="center">readOnly</td><td align="center">应用连接中间件逻辑库所具有的权限，默认为false代表读写，true代表只读</td></tr></tbody></table><ol start="2"><li><p><strong>privileges标签权限控制</strong></p><p>​        在user标签下的privileges标签可以对逻辑库(schema)、表(table)进行精细化的DML权限控制。</p><p>​        privileges标签下的check属性，如ture为开启权限检查，默认为false。</p><p>​        MyCat一个用户的schemas属性可以配置多个逻辑库(schema),所以privileges的下级节点schema节点可以配置多个，对多库多表进行DML细粒度控制。</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"mycat"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 表级 DML 权限设置 --&gt;</span>           </span><br><span class="line">                <span class="tag">&lt;<span class="name">privileges</span> <span class="attr">check</span>=<span class="string">"ture"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"TESTDB"</span> <span class="attr">dml</span>=<span class="string">"0110"</span> &gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"tb01"</span> <span class="attr">dml</span>=<span class="string">"0000"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"tb02"</span> <span class="attr">dml</span>=<span class="string">"1111"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">privileges</span>&gt;</span>                            </span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        <strong>dml的四位数字代表DML四个权限 。从左到右为insert、update、select、delete，1代表开启，0代表禁止</strong></p></li></ol><h2 id="SQL拦截"><a href="#SQL拦截" class="headerlink" title="SQL拦截"></a>SQL拦截</h2><p>​                <strong>MyCat使用server.xml的firewall标签来定义防火墙。firewall下的whitehost标签来定义IP白名单，blacklist定义SQL黑名单。</strong></p><ol><li><p>白名单</p><p>​    可以通过设置白名单实现某主机某用户可以访问MyCat，其他主机用户禁止访问。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//在sever.xml添加firewall标签</span><br><span class="line"><span class="tag">&lt;<span class="name">firewall</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">whitehost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">host</span> <span class="attr">host</span>=<span class="string">"192.168.140.120"</span> <span class="attr">user</span>=<span class="string">"mycat"</span>&gt;</span><span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">whitehost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">firewall</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>黑名单</p><p>​    可以通过黑名单，实现MyCat对具体SQL操作的拦截，如增删改查等操作的拦截。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//在sever.xml添加firewall标签</span><br><span class="line"><span class="tag">&lt;<span class="name">firewall</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">whitehost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">host</span> <span class="attr">host</span>=<span class="string">"192.168.140.120"</span> <span class="attr">user</span>=<span class="string">"mycat"</span>&gt;</span><span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">whitehost</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--禁止mycat用户的删除操作--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">blacklist</span> <span class="attr">check</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"deleteAllow"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">blacklist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">firewall</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        </p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;​        MyCat 是一个开源的分布式数据库系统，但是由于真正的数据库需要存储引擎，而 Mycat 并没有存 储引擎，所以并不是完全意义的分布式数据库系统&lt;br&gt; ​        MyCat是一个数据库中间件，也可以理解为是数据库代理。在架构体系中是位于数据库和应用层之间的一个组件，并且对于应用层是透明的，即数据库 感受不到mycat的存在，认为是直接连接的mysql数据库（实际上是连接的mycat,mycat实现了mysql的原生协议）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;MyCat的核心功能：读写分离、分库分表&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="数据库" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MyCat" scheme="http://liuyoubin.top/tags/MyCat/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议</title>
    <link href="http://liuyoubin.top/2020/03/02/netWork/TCP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://liuyoubin.top/2020/03/02/netWork/TCP%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-03-02T13:42:14.000Z</published>
    <updated>2020-03-03T15:47:23.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tcp协议特点"><a href="#Tcp协议特点" class="headerlink" title="Tcp协议特点"></a>Tcp协议特点</h1><ul><li>面向连接的传输层协议</li><li>点对点</li><li>提供可靠交付的服务、无差错、不重复、不丢失</li><li>提供全双工通信</li><li>面向字节流（tcp把应用程序交下来的数据看成仅仅是一连串的无结构字节流）</li></ul><a id="more"></a><h1 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h1><p><img src="https://s2.ax1x.com/2020/03/02/3fAlB6.png" alt="image"></p><ul><li><p>序号：在一个tcp连接中传输的字节流中每一个字节都按顺序编号，本字段表示本报文段所发送的<strong>第一个字节的序号</strong></p></li><li><p>六个控制位</p><ul><li><strong>URG</strong> - 紧急位，URG=1时表明此报文段的数据有紧急数据，应尽快传送，不用再缓存队列排队，配合紧急指针使用</li><li><strong>ACK</strong> - 确认位，ACK=1时确认号有效，在连接建立后都必须把ACK置为1</li><li><strong>PSH</strong> - 推送位，PSH=1时接收方应尽快交付应用程序，不用等接收缓存填满再向上交付</li><li><strong>RST</strong> - 复位，RST=1表明连接中出现严重差错，必须释放连接，重新建立连接</li><li><strong>SYN</strong> - 同步位，SYN=1表明是一个连接请求/连接接受报文</li><li><strong>FIN</strong> - 终止位，FIN=1表明要求释放连接</li></ul></li><li><p>窗口： 指定是本方的接收窗口大小，表明允许对方发送的数据量</p></li><li><p>检验和：检验首部+数据</p></li><li><p>紧急指针：配合URG=1，指出本报文段中紧急数据的字节数</p></li><li><p>选项：最大报文段长度MSS，窗口扩大、时间戳、选择确认</p></li></ul><h1 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="https://s2.ax1x.com/2020/03/02/3fn8Et.png" alt="image"></p><ul><li><p>ROUND1</p><p>客户端发送连接请求报文段，没有携带应用层数据</p><p>SYN=1 seq=x(随机)</p></li><li><p>ROUND2</p><p>服务端为该TCP连接分配缓存和变量，并向客户端返回确认报文的，允许连接，没有携带应用层数据</p><p>SYN=1，ACK=1，seq=y(随机)，ack=x+1</p></li><li><p>ROUND3</p><p>客户端为该TCP连接分配缓存和变量，并向服务器返回确认的确认，<strong>可以携带数据</strong></p></li></ul><p><strong>为什么是三次握手</strong></p><ol><li>为了防止已经失效的请求到达服务端而产生错误</li><li>为了实现可靠传输，tcp双方都必须维护一个序列号，而三次握手的过程就是互相告知双方的序列号起始值，并确认对方已经收到了序列号起始值</li></ol><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="https://s2.ax1x.com/2020/03/03/3fJaFJ.png" alt="image"></p><ul><li><p>ROUND1</p><p>客户端发送连接释放报文段，停止发送数据，主动关闭tcp连接</p><p>FIN=1，seq=u</p></li><li><p>ROUND2</p><p>服务器端发送确认报文端—-半关闭状态</p><p>ACK=1，ack=u+1，seq=v</p></li><li><p>ROUND3</p><p>服务端发送完数据，发送连接释放报文段，主动关闭tcp连接</p><p>FIN=1，seq=w，ACK=1，ack=u+1</p></li><li><p>ROUND4</p><p>客户端回复确认报文段，再等待计时器设置为<strong>2MSL（最长报文段寿命）</strong>，彻底关闭连接</p></li></ul><p><strong>为什么需要等待2MSL</strong></p><p>​        防止客户端的确认报文段没有到达服务器端</p><h1 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h1><blockquote><p>保证接收方从缓存区中读取的字节流和发送方发出的字节流是完全一致的</p></blockquote><p><strong>TCP采用了校验、序列号机制、和确认重传机制来保证可靠传输服务</strong></p><p><strong>确认重传机制包括累计确认、超时重传、快速重传等几方面</strong></p><h2 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h2><blockquote><p>累计确认就是TCP协议的确认方法，TCP使用可变长度报文段来发送数据，重传时，报文段数据可能会比原报文段数据包含更多的数据，因此对数据报和报文段无法进行简单的确认。TCP使用流序号对流中的一个位置进行确认，即序号和确认号一一对应，接收方使用序号将报文段重新排序，且 <strong>以正确接收到的流的最长连续前缀进行确认</strong> 。</p></blockquote><p><img src="https://s2.ax1x.com/2020/03/03/3fUWHf.png" alt="image"></p><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><blockquote><p>超时时间计算是开启定时器的设定时间，从而保证网络资源利用率，避免因定时器的时间（RTO）不确定而影响 <strong>网络传输</strong> 效率。</p><p>重传时间是动态改变的，tcp采用自适应算法（加权平均往返时间）</p></blockquote><p><img src="https://s2.ax1x.com/2020/03/03/3fUoCQ.png" alt="image"></p><p>​        如上图所示，第二个数据包丢失没有到达服务器，服务器无法对其进行ack确认，在定时器时间到达后客户端还没收到ack确认，就会确定重传。</p><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>​        超时重传虽然能解决可靠性问题，但是超时重传往往会带来许多问题，比如说：</p><ul><li>当一个报文段丢失时，会等待一定的超时周期然后才重传分组，增加了端到端的时延。</li><li>当一个报文段丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。</li></ul><p>所以tcp还有一种<strong>快速重传机制</strong></p><p>​        当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余ACK（duplicate ACK）。</p><p>​        这样，如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK（其实是收到4个同样的ACK，第一个是正常的，后三个才是冗余的），发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出，大大提高了效率。这便是快速重传机制。</p><h1 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h1><blockquote><p>为了让接收方能够来得及接收数据，不会因发送端发送速率过快而导致来不及接收。Tcp利用滑动窗口机制来实现流量控制</p></blockquote><p>​        在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送端口，即<strong>接收窗口rwnd</strong>（接收方通过确认报文的窗口字段来将rwnd通知给发送方），发送方的<strong>发送窗口</strong>取<strong>接收窗口rwnd</strong>和<strong>拥塞窗口cwnd</strong>的最小值。</p><p>​        当接收方的接收缓存已经满了，那么接收方会发送一个<strong>零窗口通知</strong>。发送方接收到<strong>零窗口通知</strong>，就会启动一个计时器，计时器持续时间到就会发送一个<strong>零窗口探测报文</strong>，接收方收到探测报文会给出现在的窗口值。</p><h1 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h1><blockquote><p>防止过多的数据注入到网络中，与流量控制相比拥塞控制具有全局性</p></blockquote><p><strong>为了解决拥塞问题，TCP提供了四种算法</strong></p><p>注意：下面的算法讨论有以下几个前提</p><ol><li>数据单向发送，接收方只发送确认报文</li><li>假定接收方的接收缓存总是充足的，即发送窗口=拥塞窗口cwnd</li></ol><h2 id="慢开始-拥塞避免"><a href="#慢开始-拥塞避免" class="headerlink" title="慢开始/拥塞避免"></a>慢开始/拥塞避免</h2><p><img src="https://s2.ax1x.com/2020/03/03/35ifw6.png" alt="image"></p><h2 id="快重传-快恢复"><a href="#快重传-快恢复" class="headerlink" title="快重传/快恢复"></a>快重传/快恢复</h2><p><img src="https://s2.ax1x.com/2020/03/03/35F29g.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Tcp协议特点&quot;&gt;&lt;a href=&quot;#Tcp协议特点&quot; class=&quot;headerlink&quot; title=&quot;Tcp协议特点&quot;&gt;&lt;/a&gt;Tcp协议特点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;面向连接的传输层协议&lt;/li&gt;
&lt;li&gt;点对点&lt;/li&gt;
&lt;li&gt;提供可靠交付的服务、无差错、不重复、不丢失&lt;/li&gt;
&lt;li&gt;提供全双工通信&lt;/li&gt;
&lt;li&gt;面向字节流（tcp把应用程序交下来的数据看成仅仅是一连串的无结构字节流）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机网络" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Tcp" scheme="http://liuyoubin.top/tags/Tcp/"/>
    
  </entry>
  
  <entry>
    <title>NIO与Netty</title>
    <link href="http://liuyoubin.top/2020/02/29/backEnd/framework/NIO%E4%B8%8ENetty/"/>
    <id>http://liuyoubin.top/2020/02/29/backEnd/framework/NIO%E4%B8%8ENetty/</id>
    <published>2020-02-29T11:52:59.000Z</published>
    <updated>2020-03-20T14:38:08.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><ol><li>理解</li></ol><p>​        IO模型就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序的通信性能。</p><ol start="2"><li><p>Java支持三种IO模型：BIO、NIO、AIO</p><ul><li>BIO - 同步并阻塞，服务器实现模式为一个线程一个连接，即客户端有连接请求时服务端就必须启动一个线程进行处理，如果连接不做任何事就会造成不必要的线程开销</li><li>NIO - 同步非阻塞，服务器实现一个线程处理多个请求，即客户端发送的连接请求会注册的多路服务器上，多路轮询到连接有IO请求就进行处理</li><li>AIO - 异步非阻塞，AIO引入异步通信通道的概念，采用了Proactor模式。简化了程序的编写，有效的请求才启动线程，它的特点是先有操作系统完成后才通知服务端程序去处理，一般用于连接数较多且连接时间较长的应用。</li></ul><a id="more"></a><p><img src="https://s2.ax1x.com/2020/02/29/3yjrOx.png" alt="image"></p></li><li><p>BIO客户端编写例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//线程池</span></span><br><span class="line">        ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">"服务器启动"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//监听等待客户端连接</span></span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">"连接到一个客户端"</span>);</span><br><span class="line"></span><br><span class="line">            threadPool.execute(()-&gt;&#123;</span><br><span class="line">                handler(socket);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法和客户端通信</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//获取连接的输入流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((len=inputStream.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(buffer, <span class="number">0</span>, len));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"关闭socket连接"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h2 id="NIO三大核心部分"><a href="#NIO三大核心部分" class="headerlink" title="NIO三大核心部分"></a>NIO三大核心部分</h2><ul><li><strong>Channel - 通道</strong></li><li><strong>Buffer - 缓冲区</strong></li><li><strong>Selector - 选择器</strong></li></ul><p><img src="https://s2.ax1x.com/2020/02/29/36CJgg.png" alt="image"></p><p><strong>说明：</strong></p><ol><li>每个Channel都会对应一个Buffer</li><li>每个Selector对应一个线程</li><li>每一个Channel注册到Selector上，程序切换到哪个Channel上由事件（Event）决定</li><li>Buufer则是一个内存块，底层是一个数组</li><li>数据的读写通过Buffer,既可以读也可以写通过filp方法切换</li><li>Channel是双向的</li></ol><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><blockquote><p>非阻塞模式下，一个选择器可检测多个SelectableChannel，获取为读写等操作准备好的通道，不用我们循环去判断</p></blockquote><blockquote><p>通过Selector，一个线程可以处理多个Channel，可极大减少线程数。用cpu核心数的线程，充分利用cpu资源，又减少线程切换</p></blockquote><h4 id="Selector的使用"><a href="#Selector的使用" class="headerlink" title="Selector的使用"></a>Selector的使用</h4><ol><li><p><strong>Selector创建/注册通道</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开一个选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"><span class="comment">//将通道设置为非阻塞模式</span></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//将通道注册到选择器中</span></span><br><span class="line">SelectionKey key= channel.register(selector,SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><p>register方法参数说明:指定监听的就绪事件</p><ul><li>SelectionKey.OP_CONNECT 有新的网络连接可以accept ，值为16</li></ul></li></ol><ul><li><p>SelectionKey.OP_ACCEPT      代表连接已建立，值为8</p></li><li><p>SelectionKey.OP_READ          代表读操作，值为1</p><ul><li>SelectionKey.OP_WRITE         代表写操作，值为4</li></ul></li></ul><ol start="2"><li><p><strong>Selector选择就绪的Channel</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = selector.select();</span><br></pre></td></tr></table></figure><p>方法选择：返回就绪的Channel数量</p><ul><li><p>int select() 阻塞到有就绪的Channel</p></li><li><p>int select(long timeout) 阻塞最长多久</p></li><li><p>int selectNow 不阻塞</p></li></ul></li><li><p><strong>获得就绪的SelectionKey集合（当有就绪的Channel时）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure></li><li><p><strong>迭达处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line">   </span><br><span class="line">      Set&lt;SelectionKey&gt; keySet = selector.selectedKeys();</span><br><span class="line">   </span><br><span class="line">      Iterator&lt;SelectionKey&gt; keyIterator = keySet.iterator();</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">while</span> (keyIterator.hasNext())&#123;</span><br><span class="line">   </span><br><span class="line">          SelectionKey key = keyIterator.next();</span><br><span class="line">          <span class="comment">//将处理的key移除</span></span><br><span class="line">          keyIterator.remove();</span><br><span class="line">          <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">              <span class="comment">//相应的处理</span></span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isConnectable())&#123;</span><br><span class="line">              <span class="comment">//相应的处理</span></span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">              <span class="comment">//相应的处理</span></span><br><span class="line">          &#125;<span class="keyword">else</span>  <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">              <span class="comment">//相应的处理</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p><strong>Channel的四种实现</strong></p><ul><li>FileChannel //只能用于阻塞情况</li><li>DatagramChannel //数据报通道，用于udp协议</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p><strong>Channel的API</strong></p><ul><li>open() 创建通道</li><li>read(Buufer) 从通道中读取数据到Buffer中</li><li>write(Buufer) 将Buffer中的数据写通道中</li></ul><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><blockquote><p>缓冲区：数据的临时存放区</p></blockquote><p><strong>Buffer的基本使用步骤</strong></p><ol><li>XXXBuffer.allocate(int)创建Buffer</li><li>调用put方法往Buufer中写数据</li><li>调用buffer.flip()将buffer转为读模式</li><li>读取buffer中的数据</li><li>Call buffer.clear() or buffer.compact()</li></ol><p><strong>Buffer的三个重要属性 capacity position limit</strong></p><ul><li>Capacity - 容量，即可以容纳的最大数据量，创建Buufer时指定且不能改变</li><li>Limit - 表示缓冲区的当前终点，不能对缓冲区超过极限的位置进行读写</li><li>Position - 下一个要被读写的位置 </li></ul><p><img src="https://s2.ax1x.com/2020/02/29/36QIiD.png" alt="image"></p><h2 id="NIO通信案例"><a href="#NIO通信案例" class="headerlink" title="NIO通信案例"></a>NIO通信案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ServerSocketChannel</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//得到一个Selector对象</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//绑定端口</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//把ServerSocketChannel注册到Selector</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;<span class="comment">//等待客户端连接</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(selector.select(<span class="number">1000</span>)==<span class="number">0</span>)&#123;<span class="comment">//等待一秒</span></span><br><span class="line">                System.out.println(<span class="string">"服务器等待1秒,无连接"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取相关的selectorKey</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeySet = selector.selectedKeys();</span><br><span class="line">            <span class="comment">//使用迭达器遍历</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeySet.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line"></span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="comment">//移除key</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="comment">//根据就绪事件做不同的处理</span></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable())&#123;<span class="comment">//有客户端连接</span></span><br><span class="line">                    <span class="comment">//获取客户端连接</span></span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    <span class="comment">//设置为非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//将连接通道注册到Selector中,就绪事件为OP_READ,同时分配一个Buffer</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ,ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (key.isReadable())&#123;<span class="comment">//可读</span></span><br><span class="line">                    <span class="comment">//通过key获取通道</span></span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">//获取该channel的Buffer</span></span><br><span class="line">                    ByteBuffer byteBuffer = (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="comment">//将Buffer中的数据读到Channel中</span></span><br><span class="line">                    socketChannel.read(byteBuffer);</span><br><span class="line">                    System.out.println(<span class="string">"客户端："</span>+<span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个网络通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//提供服务端的ip和端口</span></span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="keyword">if</span>(!socketChannel.connect(inetSocketAddress))&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">                System.out.println(<span class="string">"连接不成功，客户端不会阻塞"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        String str = <span class="string">"hello,world"</span>;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.wrap(str.getBytes());</span><br><span class="line"></span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><blockquote><p>零拷贝是网络编程的关键，很多性能优化都离不开</p><p>Java常用的零拷贝有mmap(内存映射)和sendFile</p></blockquote><p>先看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      File file = <span class="keyword">new</span> File(<span class="string">"a.html"</span>);</span><br><span class="line">      RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</span><br><span class="line"><span class="keyword">int</span> len = file.length();</span><br><span class="line">      <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">      raf.read(arr);</span><br><span class="line"></span><br><span class="line">      Socket socket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>).accept();</span><br><span class="line">      socket.getOutputStream().write(arr);</span><br></pre></td></tr></table></figure><p>当执行这段代码的时候OS底层发生了什么呢? </p><h2 id="传统IO"><a href="#传统IO" class="headerlink" title="传统IO"></a>传统IO</h2><p><img src="https://s2.ax1x.com/2020/03/01/3gvWkV.png" alt="image"></p><ul><li>read方法导致用户态到内核态的切换，同时通过DMA（直接内存读取）方式将数据从硬盘读到内核缓冲区</li><li>接下来将数据从内核态通过CPU拷贝到用户缓冲区，发生了第二次上下文切换</li><li>数据从用户缓冲区通过CPU拷贝到Socket缓冲区，发生了第三次上下文切换</li><li>数据从Socket缓冲区通过DMA方式传输到网络协议引擎</li></ul><p><strong>总共发生了3次上下文切换和4次拷贝</strong></p><h2 id="MMAP优化"><a href="#MMAP优化" class="headerlink" title="MMAP优化"></a>MMAP优化</h2><p><img src="https://s2.ax1x.com/2020/03/01/3gxBAx.png" alt="image"></p><p>如图所示</p><p>user buffer 和 kernel buffer 共享数据文件。如果你想把硬盘的文件传输到网络中，再也不用拷贝到用户空间，再从用户空间拷贝到 Socket 缓冲区。通过MMAP，你只需要从内核缓冲区拷贝到 Socket 缓冲区即可，这将减少一次内存拷贝（从 4 次变成了 3 次），但不减少上下文切换次数。</p><p><strong>总共发生了3次上下文切换和3次拷贝</strong></p><h2 id="SendFile优化"><a href="#SendFile优化" class="headerlink" title="SendFile优化"></a>SendFile优化</h2><p><img src="https://s2.ax1x.com/2020/03/01/32Smes.png" alt="image"></p><p>​        Linux 2.1 版本 提供了 sendFile 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 Socket Buffer，同时，由于和用户态完全无关，就减少了一次上下文切换。</p><p><strong>总共发生了2次上下文切换和3次拷贝</strong></p><h2 id="SendFile进阶优化"><a href="#SendFile进阶优化" class="headerlink" title="SendFile进阶优化"></a>SendFile进阶优化</h2><p><img src="https://s2.ax1x.com/2020/03/01/32SjhV.png" alt="image"></p><p>​        Linux 在 2.4 版本中，做了一些修改，避免了从内核缓冲区拷贝到 Socket buffer 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。</p><p><strong>总共发生了2次上下文切换和2次拷贝</strong></p><blockquote><p>说明：零拷贝不是指没有发生拷贝。而是指没有CPU拷贝。</p><p>​            零拷贝不仅减少了CPU拷贝也减少了上下文切换    </p><p>​            在Java中的transferTo 和 transferFrom 方法底层就是用用到了零拷贝技术</p></blockquote><h1 id="Netty概述"><a href="#Netty概述" class="headerlink" title="Netty概述"></a>Netty概述</h1><p>​    <strong>Netty是一个异步的，基于事件的网络应用框架</strong></p><p>​    <a href="https://netty.io/" target="_blank" rel="noopener">Netty官网</a></p><h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><h2 id="单Reacto单线程"><a href="#单Reacto单线程" class="headerlink" title="单Reacto单线程"></a>单Reacto单线程</h2><p><img src="https://s2.ax1x.com/2020/03/01/32D3dK.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IO模型&quot;&gt;&lt;a href=&quot;#IO模型&quot; class=&quot;headerlink&quot; title=&quot;IO模型&quot;&gt;&lt;/a&gt;IO模型&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;理解&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​        IO模型就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序的通信性能。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;p&gt;Java支持三种IO模型：BIO、NIO、AIO&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BIO - 同步并阻塞，服务器实现模式为一个线程一个连接，即客户端有连接请求时服务端就必须启动一个线程进行处理，如果连接不做任何事就会造成不必要的线程开销&lt;/li&gt;
&lt;li&gt;NIO - 同步非阻塞，服务器实现一个线程处理多个请求，即客户端发送的连接请求会注册的多路服务器上，多路轮询到连接有IO请求就进行处理&lt;/li&gt;
&lt;li&gt;AIO - 异步非阻塞，AIO引入异步通信通道的概念，采用了Proactor模式。简化了程序的编写，有效的请求才启动线程，它的特点是先有操作系统完成后才通知服务端程序去处理，一般用于连接数较多且连接时间较长的应用。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="框架" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java" scheme="http://liuyoubin.top/tags/Java/"/>
    
      <category term="Netty" scheme="http://liuyoubin.top/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>设计模式整理</title>
    <link href="http://liuyoubin.top/2020/02/19/backEnd/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%B4%E7%90%86/"/>
    <id>http://liuyoubin.top/2020/02/19/backEnd/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%B4%E7%90%86/</id>
    <published>2020-02-19T15:01:31.000Z</published>
    <updated>2020-03-26T14:05:02.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h1><ol><li><strong>单一职责原则</strong><ul><li>降低类的负责度，一个类只负责一项职责</li><li>提高类的可读性，可维护性</li><li>降低变更引起的风险</li><li>通常情况下，应该遵守单一职责原则。只有逻辑足够简单才可以在代码级违反单一职责原则。只有类中方法足够少，可以在方法级别保持单一职责原则</li></ul></li><li><strong>接口隔离原则</strong><ul><li>一个类不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</li></ul></li><li><strong>依赖倒转原则</strong><ul><li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好</li><li>变量的声明类型尽量是抽象类或者接口，利于程序的扩展和优化</li><li>抽象不应该依赖细节，细节应该依赖抽象</li><li>中心思想就是面向接口编程</li></ul></li><li><strong>里氏替换原则</strong><ul><li>所有引用基类的地方必须能透明地使用其子类对象</li><li>使用继承时，尽量不要重写父类的方法</li><li>继承实际上让两个类耦合性增强了，在适当情况下可以使用组合、聚合、依赖来解决问题</li></ul></li><li><strong>开闭原则</strong><ul><li>一个软件实体比如类，模块和函数应该对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节</li><li>当软件需求变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化</li></ul></li><li><strong>迪米特法则</strong><ul><li>一个对象应该对其他对象保持最少的了解</li><li>类与类关系越密切，耦合度越大</li><li>一个类对自己依赖的类了解的越少越好，不管依赖的类有多么复杂，都尽量将逻辑封装在类的内部，除对外提供public方法，不对外泄露任何信息</li></ul></li><li><strong>合成复用原则</strong><ul><li>尽量使用合成/聚合的方式，而不是继承</li></ul></li></ol><a id="more"></a><h1 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h1><p>​        <strong>设计模式不是代码，而是某类问题的通用解决方案。设计模式的本质是提高软件的可维护性、通用性和扩展性，并降低软件的复杂度。</strong></p><p>​        <code>设计模式分为三种类型，共23种</code></p><ol><li><strong>创建型模式</strong>：<code>单例模式</code>、抽象工厂模式、原型模式、建造者模式、<code>工厂模式</code></li><li><strong>结构型模式</strong>：设配器模式、桥接模式、<code>装饰模式</code>、组合模式、外观模式、享元模式、<code>代理模式</code></li><li><strong>行为型模式</strong>：模板方法模式、命令模式、访问者模式、迭达器模式、<code>观察者模式</code>、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式</li></ol><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>​        单例模式就是采取一定的方法保证在整个软件系统中，对某个类只能有一个对象实例，并且该类只提供一个取得其对象实例的方法。</p><h2 id="八种单例模式的写法"><a href="#八种单例模式的写法" class="headerlink" title="八种单例模式的写法"></a><strong>八种单例模式的写法</strong></h2><ol><li><p><strong>饿汉式(静态常量)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类加载的时候,立即创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：写法简单，类加载的时候完成实例化，没有线程安全问题</p><p>缺点：没有懒加载效果，容易造成内存浪费</p></li></ol><ol start="2"><li><p><strong>饿汉式(静态代码块)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行静态代码块的时候,创建对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>​        优缺点和<strong>饿汉式(静态常量)</strong>一样</p><ol start="3"><li><p><strong>懒汉式(线程不安全)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当使用该方法时才创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：能够实现懒加载</p><p>缺点：线程不安全，有可能产生多个实例，多线程环境下不能使用</p></li></ol><ol start="4"><li><p><strong>懒汉式(线程安全，同步方法)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当使用该方法时才创建对象,由于加了synchronized解决了线程安全问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：能够实现懒加载，线程安全</p><p>缺点：每个线程在获取实例的时候都要进行同步，效率低下</p></li></ol><ol start="5"><li><p><strong>懒汉式(线程安全，同步代码块)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当使用该方法时才创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这种方式本质上是对上一种方法的改进，但是这种方法并不能起到线程同步的作用。因为有可能有多个线程都判断到instance==null，从而产生多个实例。</p></li></ol><ol start="6"><li><p><strong>双重检查</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意这里需要加volatile关键字，否则会有线程安全问题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当使用该方法时才创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能够实现懒加载，又解决线程安全问题，同时效率较高。推荐使用这种方法。</p></li></ol><ol start="7"><li><p><strong>静态内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当使用该方法时,静态内部类SingletonInstance才会被加载，Singleton实例才会被创建。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用类加载机制来保证单例，同时保证线程安全以及懒加载。</p></li></ol><ol start="8"><li><p><strong>枚举</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  Singleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以实现懒加载，效率高。同时可以避免序列化、反序列化和反射破坏单例。</p></li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h2><p>​        在频繁进行创建销毁导致消耗资源过多，但系统中只需要存在一个的对象。比如工具类对象，工厂对象，数据源等，可以使用单例模式进行改造。</p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ol><li><p>简单工厂模式是工厂模式中最简单实用的一种。<strong>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例</strong></p></li><li><p>定义一个创建对象的类，由这个类来封装实例化对象的行为</p></li><li><p><strong>不属于23种设计模式之一</strong></p></li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalSimpleFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">getAnimalByType</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        Animal animal = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"猫"</span>))&#123;</span><br><span class="line">        animal =  <span class="keyword">new</span> Cat();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"狗"</span>))&#123;</span><br><span class="line">        animal =  <span class="keyword">new</span> Dog();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"鸟"</span>))&#123;</span><br><span class="line">        animal =  <span class="keyword">new</span> Bird();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> animal;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>定义一个创建对象的抽象方法，由子类决定要实例化的类。将对象的实例化推迟到子类</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Animal <span class="title">getAnimal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogFactory</span> <span class="keyword">extends</span> <span class="title">AnimalFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Animal <span class="title">getAnimal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatFactory</span> <span class="keyword">extends</span> <span class="title">AnimalFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Animal <span class="title">getAnimal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>​        定义一个接口用于创建相关的对象簇，而无需指定具体的类。从抽象层面看，抽象工厂模式就是对简单工厂模式的进一步抽象。将工厂抽象成抽象工厂和具体实现的工厂子类，将简单工厂变成工厂簇。</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Phone <span class="title">createPhone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Router <span class="title">createRouter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂的具体实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaWeiFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaWeiPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Router <span class="title">createRouter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaweiRouter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂的具体实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaomiFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaomoPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Router <span class="title">createRouter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaomiRouter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=====================================================</span><br><span class="line"><span class="comment">//抽象产品-手机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象产品-路由器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">router</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象产品的具体实现就不写了</span></span><br></pre></td></tr></table></figure><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p>​        我们直接new一个对象的时候需要比较长的时间，当我们需要大量创建对象的时候可以采用克隆模式。</p><p>​        克隆可以分为浅克隆和深克隆</p><h2 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原型模式（克隆模式）</span></span><br><span class="line"><span class="comment"> * 实现Cloneable接口</span></span><br><span class="line"><span class="comment"> * 重写Object方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>,<span class="title">Serializable</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String sname;</span><br><span class="line">  <span class="keyword">private</span> Date birthday;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String sname, Date birthday)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.sname = sname;</span><br><span class="line">    <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getSname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sname;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSname</span><span class="params">(String sname)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sname = sname;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> birthday;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 重写方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Object obj =  <span class="keyword">super</span>.clone();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">测试类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//浅克隆 </span></span><br><span class="line">    Date date = <span class="keyword">new</span> Date(<span class="number">1243564634124L</span>);</span><br><span class="line">    Sheep s1 = <span class="keyword">new</span> Sheep(<span class="string">"小白羊"</span>,date);</span><br><span class="line">    System.out.println(s1.getSname()+<span class="string">"---&gt;"</span>+s1.getBirthday());</span><br><span class="line">    <span class="comment">//进行克隆</span></span><br><span class="line">    Sheep s2 = (Sheep)s1.clone();</span><br><span class="line">    s2.setSname(<span class="string">"小黑羊"</span>);</span><br><span class="line">    System.out.println(s2.getSname()+<span class="string">"---&gt;"</span>+s2.getBirthday());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当修改s1对象指向的Date对象时，s2对象的Date对象也随之改变（因为两者指向 同一个对象 ，浅克隆）</span></span><br><span class="line">    date.setTime(<span class="number">2232345643213L</span>);</span><br><span class="line">    System.out.println(s1.getSname()+<span class="string">"---&gt;"</span>+s1.getBirthday());</span><br><span class="line">    System.out.println(s2.getSname()+<span class="string">"---&gt;"</span>+s2.getBirthday());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原型模式（克隆模式）</span></span><br><span class="line"><span class="comment"> * 实现Cloneable接口</span></span><br><span class="line"><span class="comment"> * 重写Object方法</span></span><br><span class="line"><span class="comment"> * 深克隆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep2</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String sname;</span><br><span class="line">  <span class="keyword">private</span> Date birthday;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sheep2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sheep2</span><span class="params">(String sname, Date birthday)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.sname = sname;</span><br><span class="line">    <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getSname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sname;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSname</span><span class="params">(String sname)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sname = sname;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> birthday;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 重写方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Object obj =  <span class="keyword">super</span>.clone();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加如下代码实现深克隆</span></span><br><span class="line">    Sheep2 s = (Sheep2)obj;</span><br><span class="line">    s.birthday = (Date) <span class="keyword">this</span>.birthday.clone();<span class="comment">//把属性也进行拷贝</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">测试类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过序列化和反序列化实现深克隆</span></span><br><span class="line"><span class="comment"> * 要实现序列化原来类必须记得实现Serializable接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text2</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Date date  = <span class="keyword">new</span> Date(<span class="number">123142556765L</span>); </span><br><span class="line">    Sheep s1 = <span class="keyword">new</span> Sheep(<span class="string">"小白羊"</span>,date);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//序列化</span></span><br><span class="line">    ByteArrayOutputStream bas = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bas);</span><br><span class="line">    oos.writeObject(s1);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = bas.toByteArray();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//反序列化</span></span><br><span class="line">    ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">    Sheep s2 = (Sheep)ois.readObject();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//由此实现了深克隆</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><p>​        将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。用户可以在不知道对象建造细节和过程的情况下直接创建复杂对象。</p><h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体的产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"><span class="comment">//默认产品实现</span></span><br><span class="line">    <span class="keyword">private</span> String A = <span class="string">"aaa"</span>;</span><br><span class="line">    <span class="keyword">private</span> String B = <span class="string">"bbb"</span>;</span><br><span class="line">    <span class="keyword">private</span> String C = <span class="string">"ccc"</span>;</span><br><span class="line">    <span class="keyword">private</span> String D = <span class="string">"ddd"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Builder <span class="title">setA</span><span class="params">(String msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Builder <span class="title">setB</span><span class="params">(String msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Builder <span class="title">setC</span><span class="params">(String msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Builder <span class="title">setD</span><span class="params">(String msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Product <span class="title">getProduct</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Builder <span class="title">setA</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        product.setA(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Builder <span class="title">setB</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        product.setA(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Builder <span class="title">setC</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        product.setA(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Builder <span class="title">setD</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        product.setA(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Product <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Builder worker = <span class="keyword">new</span> Worker();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端可以自由指定进行装配，而具体的实现细节由建造者实现</span></span><br><span class="line">        Product product = worker.setA(<span class="string">"AAA"</span>).getProduct();</span><br><span class="line"></span><br><span class="line">        System.out.println(product);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点<ul><li>产品的建造和表示分离，实现解耦。客户端不必知道产品内部的细节</li><li>将复杂产品的创建步骤分解在不同方法中，使得创建过程更加清晰</li><li>具体的建造者之间是互相独立的，有利于系统扩展，符合“开闭原则”</li></ul></li><li>缺点<ul><li>建造者的产品一般具有较多共同点，如果产品差异较大，则不适合使用建造者模式</li><li>如果产品内部变化复杂，则需要较多的不同建造者，这将导致系统变得庞大</li></ul></li></ul><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><p>​        观察者模式是解决一对多依赖的一种解决方案。比如说一个对象的变化会引起其他多个对象的变化，这时就可以考虑观察者模式</p><ul><li>优点：<ol><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li><li>目标与观察者之间建立了一套触发机制。</li></ol></li><li>缺点<ol><li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li><li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li></ol></li></ul><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://s2.ax1x.com/2020/02/29/3r5Dtf.png" alt="image"></p><h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature,<span class="keyword">float</span> pressure,<span class="keyword">float</span> humidity)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditions</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"气温："</span>+<span class="keyword">this</span>.temperature);</span><br><span class="line">        System.out.println(<span class="string">"气压："</span>+<span class="keyword">this</span>.pressure);</span><br><span class="line">        System.out.println(<span class="string">"湿度："</span>+<span class="keyword">this</span>.humidity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观察者集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注册观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移除观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历通知观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers.forEach(n-&gt; n.update(<span class="keyword">this</span>.temperature, <span class="keyword">this</span>.pressure, <span class="keyword">this</span>.humidity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新数据时通知观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateData</span><span class="params">(<span class="keyword">float</span> temperature,<span class="keyword">float</span> pressure,<span class="keyword">float</span> humidity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设配器模式"><a href="#设配器模式" class="headerlink" title="设配器模式"></a>设配器模式</h1><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设计模式七大原则&quot;&gt;&lt;a href=&quot;#设计模式七大原则&quot; class=&quot;headerlink&quot; title=&quot;设计模式七大原则&quot;&gt;&lt;/a&gt;设计模式七大原则&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;单一职责原则&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;降低类的负责度，一个类只负责一项职责&lt;/li&gt;
&lt;li&gt;提高类的可读性，可维护性&lt;/li&gt;
&lt;li&gt;降低变更引起的风险&lt;/li&gt;
&lt;li&gt;通常情况下，应该遵守单一职责原则。只有逻辑足够简单才可以在代码级违反单一职责原则。只有类中方法足够少，可以在方法级别保持单一职责原则&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接口隔离原则&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;一个类不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;依赖倒转原则&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好&lt;/li&gt;
&lt;li&gt;变量的声明类型尽量是抽象类或者接口，利于程序的扩展和优化&lt;/li&gt;
&lt;li&gt;抽象不应该依赖细节，细节应该依赖抽象&lt;/li&gt;
&lt;li&gt;中心思想就是面向接口编程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;里氏替换原则&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;所有引用基类的地方必须能透明地使用其子类对象&lt;/li&gt;
&lt;li&gt;使用继承时，尽量不要重写父类的方法&lt;/li&gt;
&lt;li&gt;继承实际上让两个类耦合性增强了，在适当情况下可以使用组合、聚合、依赖来解决问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开闭原则&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;一个软件实体比如类，模块和函数应该对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节&lt;/li&gt;
&lt;li&gt;当软件需求变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;迪米特法则&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;一个对象应该对其他对象保持最少的了解&lt;/li&gt;
&lt;li&gt;类与类关系越密切，耦合度越大&lt;/li&gt;
&lt;li&gt;一个类对自己依赖的类了解的越少越好，不管依赖的类有多么复杂，都尽量将逻辑封装在类的内部，除对外提供public方法，不对外泄露任何信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合成复用原则&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;尽量使用合成/聚合的方式，而不是继承&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://liuyoubin.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis笔记整理</title>
    <link href="http://liuyoubin.top/2020/02/18/backEnd/Redis%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    <id>http://liuyoubin.top/2020/02/18/backEnd/Redis%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</id>
    <published>2020-02-18T03:55:37.000Z</published>
    <updated>2020-04-02T16:18:30.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p>​        <code>Redis是一个基于内存、支持持久化、的高性能NoSql的key-value数据库。</code></p><p><strong>Redis的特点</strong></p><ul><li>支持数据持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次进行加载。</li><li>数据结构丰富，支持string、list、set、zset、hash…….</li><li>支持数据备份、集群等高可用功能</li><li>性能高 （读速度：110000次/s，写速度：8100次/s）</li><li>原子性，Redis所有操作都是原子性的</li><li>特性丰富，Redis还支持发布/订阅、通知…..</li></ul><a id="more"></a><blockquote><p>Redis是单线程，Redis是基于内存操作的，CPU不是Redsi的瓶颈，Redis的瓶颈是内存大小和网络带宽。</p></blockquote><h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h1><p>​        Redis有Windows版本，也有Linux版本，这里记录Linux版本的安装。（如果会Docker也可以采用Docker进行安装）</p><ol><li><p>安装gcc环镜</p><p>​    查看是否安装过gcc，如果没有则需安装gcc,因为Redis是C语言编写的</p></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看是否安装gcc</span></span><br><span class="line"><span class="attr">gcc</span> <span class="string">--version</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装gcc</span></span><br><span class="line"><span class="attr">yum</span> <span class="string">-y install gcc automake autoconf libtool make</span></span><br></pre></td></tr></table></figure><ol start="2"><li>安装Redis</li></ol><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#下载安装包</span></span><br><span class="line">wget http:<span class="comment">//download.redis.io/releases/redis-4.0.1.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#解压缩</span></span><br><span class="line">tar -zxvf redis<span class="number">-4.0</span><span class="number">.1</span>.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#切换到redis目录下</span></span><br><span class="line">cd redis<span class="number">-4.0</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#编译</span></span><br><span class="line">make MALLOC=libc</span><br><span class="line"></span><br><span class="line"><span class="meta">#安装编译后的文件到指定目录</span></span><br><span class="line">make PREFIX=/usr/local/redis install</span><br></pre></td></tr></table></figure><h1 id="Redis启动与关闭"><a href="#Redis启动与关闭" class="headerlink" title="Redis启动与关闭"></a>Redis启动与关闭</h1><h2 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h2><p>进入安装目录,执行命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/usr/local/redis/bin</span></span><br><span class="line"></span><br><span class="line"><span class="string">./redis-server</span> [redis配置文件位置]</span><br></pre></td></tr></table></figure><h2 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/usr/local/redis/bin</span></span><br><span class="line"></span><br><span class="line"><span class="string">./server-cli</span> [-h IP地址 -p 端口号 -a 密码]</span><br></pre></td></tr></table></figure><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><ol><li>非正常关闭（杀进程、断电）</li></ol><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询PID</span></span><br><span class="line">ps -ef | <span class="keyword">grep</span> redis</span><br><span class="line"></span><br><span class="line"><span class="keyword">kill</span> -<span class="number">9</span> PID</span><br></pre></td></tr></table></figure><ol start="2"><li>通过客户端正常关闭</li></ol><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./bin/redis-cli</span> <span class="keyword">shutdown</span></span><br></pre></td></tr></table></figure><h1 id="Redis配置文件"><a href="#Redis配置文件" class="headerlink" title="Redis配置文件"></a>Redis配置文件</h1><p>​        <code>Redis配置文件位于Redis安装包下(注意：不是安装后的目录下)，名字叫redis.conf</code></p><p>​        在实际中我们会手动配置redis，所以要把redis配置文件复制到redis安装目录下</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#切换到redis安装包下</span></span><br><span class="line"><span class="keyword">cd</span> <span class="string">/usr/src/redis-4.0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#复制配置文件到安装目录下</span></span><br><span class="line">cp redis.conf <span class="string">/usr/local/redis</span></span><br></pre></td></tr></table></figure><h2 id="Redis配置项详解"><a href="#Redis配置项详解" class="headerlink" title="Redis配置项详解"></a>Redis配置项详解</h2><ul><li><p>daemonize no</p><p>​        redis默认不是以守护进程方式启动，可以通过修改成yes启动守护进程</p></li></ul><ul><li><p>pidfile</p><p>​        当redis以守护进程启动时，默认将pid写入/var/run/redis.pid,可以通过pidfile指定</p></li></ul><ul><li>port</li></ul><p>​                指定redis监听端口</p><ul><li><p>bind 127.0.0.1</p><p>​        绑定主机地址，默认只能本机访问，可以通过注释解除访问限制</p></li></ul><ul><li><p>timeout</p><p>​        当客户端闲置多长时间后关闭连接，如果指定为0则关闭该功能</p></li></ul><ul><li><p>loglevel</p><p>​        指定日志级别，Redis支持debug、verbose(默认)、notice、warning四个级别</p></li></ul><ul><li><p>logfile stdout</p><p>​        日志记录方式，如果Reids以守护进程方式进行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</p></li></ul><ul><li><p>databases</p><p>​    设置数据库数量,默认为16</p></li></ul><ul><li><p>save <seconds> <change></p><p>​    指定在多次时间内有多少次更新操作，就将数据同步到数据文件中，可以多条件配合</p><p>​    save 900 1                900秒内有1个更改</p><p>​    save 300  10             300秒内有10个更改</p><p>​    save  60    10000      60秒内有10000个更改</p></li></ul><ul><li><p>rdbcompression </p><p>​    指定存储至本地数据库的时候是否采用LZF压缩，默认为true。如果设置成no可以节省cpu时间，但数据库文件会变大。</p></li></ul><ul><li><p>dbfilename</p><p>​    指定数据库文件名，默认为dump.rdb</p></li></ul><ul><li><p>dir ./</p><p>​    指定数据库文件存放位置</p></li></ul><ul><li><p>slaveof <masterip> <masterport></p><p>​    设置本机为slave服务时，指定master的ip和port，用于同步数据</p></li></ul><ul><li><p>masterauth <master-password></p><p>​    当master服务设置密码时，slave服务连接master的密码</p></li></ul><ul><li><p>requirepass</p><p>​    设置redis密码，如果设置了redis密码，客户端连接redis时需要通过 AUTH <password> 命令提供密码。redis3.0之后如果想要远程连接必须提供密码。</p></li></ul><ul><li><p>maxclients</p><p>​    设置同一时间最大的客户端连接数，默认无限制</p></li></ul><ul><li><p>maxclients <bytes></p><p>​    指定redis最大的内存限制。Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会尝试清除已到期或即将到期的Key,当此方法后任然达到最大内存限制，将无法再进行写操作，但仍然可以读。Redis最新的vm机制，会把key放在内存，value放在swap区。</p></li></ul><ul><li><p>appendonly on</p><p>​    指定是否每次在更新后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断点时导致一段时间的数据丢失。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会有一段时间内只存在于内存中。默认为no</p></li></ul><ul><li><p>appendfilename appendonly.aof</p><p>​    指定更新日志文件名</p></li></ul><ul><li><p>appendfsync</p><p>​    指定更新日志条件：</p><ul><li>no  表示等操作系统进行数据缓存同步到磁盘</li><li>always  表示每次更新后手动调用fsync()将数据写到磁盘 (慢，安全)</li><li>everysec   表示每秒同步一次</li></ul></li></ul><ul><li><p>vm-enabled  no</p><p>​    指定是否启用虚拟机内存机制，默认为no。VM机制将数据分页存放，由Redis将访问较少的页存到swap中。</p></li></ul><ul><li><p>vm-swap-file  </p><p>​    虚拟内存文件路径，默认为/tmp/redis.swap</p></li></ul><ul><li><p>vm-max-memory 0</p><p>​    将所有大于vm-max-memory的数据存入虚拟内存，无论cm-max-memory设置多小，所有所有数据都是存储在内存的。也就是说当设置为0，所有value都存在swap区。</p></li></ul><ul><li><p>vm-page-size 32</p><p>​        Redis swap文件分成了许多的page，一个对象可以保存多个page上，但一个page上不能被多个对象共享。建议如果存储很多小对象，page大小设置为32或者64bytes;如果设置很多大对象，page可以设置更大。</p></li></ul><h1 id="Redis内存维护策略"><a href="#Redis内存维护策略" class="headerlink" title="Redis内存维护策略"></a>Redis内存维护策略</h1><p>​        redis作为优秀的内存中间件，内存消耗是一个不可忽视问题，所以需要整理内存，维护系统性能。有两种解决方案</p><ol><li>为数据设置超时时间</li></ol><ol start="2"><li>采用LRU算法将不用的数据删除</li></ol><ul><li>volatile-lru  设定超时时间的数据中，删除最不常用的数据</li><li>allkeys-lru   所有key中最近最不常使用的数据进行删除</li><li>volatile-random   在设定超时的数据中随机删除</li><li>allkeys-random     所有key中随机删除</li><li>volatile-tll     全部设定超时时间的数据，之后排序，将马上要过期的数据进行删除</li><li>Noeviction 如果设置成该属性，则不会删除操作，如果内存溢出则报错返回</li><li>volatile-lfu   设定超时时间的数据中删除使用频率最少的键</li><li>allkeys-lfu    所有key中删除使用频率最少的键</li></ul><h1 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h1><h2 id="键命令"><a href="#键命令" class="headerlink" title="键命令"></a>键命令</h2><ul><li><p>DEL key</p><p>​    用于key存在时删除 key</p></li><li><p>DUMP  key</p><p>​    序列化给定key,并返回被序列化的值</p></li><li><p>EXISTS key</p><p>​    检查给定key是否存在</p></li><li><p>EXPIRE key seconds</p><p>​    为给定的key设置过期时间（秒）</p></li><li><p>TTL key</p><p>​    返回给定key的剩余存活时间，-1代表永久有效，-2代表过期无效</p></li><li><p>PEXPIRE key milliseconds (毫秒)</p><p>​    为给定的key设置过期时间（豪秒）</p></li><li><p>PTTL key</p><p>​    返回给定key的剩余存活时间,毫秒计算</p></li><li><p>PERSIST key</p><p>​    移除key的过期时间，设置持久</p></li><li><p>KEYS pattern</p><p>​    查找所有符合给定模式的key 。*代表所有  ?代表一个规范</p></li><li><p>RENAME key newkey</p><p>​    重命名key</p></li><li><p>MOVE key db</p><p>​    移动当前数据库的key到指定数据库</p></li><li><p>TYPE key</p><p>返回key所存储value的值</p></li></ul><h2 id="数据库命令"><a href="#数据库命令" class="headerlink" title="数据库命令"></a>数据库命令</h2><p>​    Redis默认16个数据库，通过整数索引标识，默认情况连接到数据库0</p><ul><li><p>select 数据库索引  </p><p>​    数据库切换</p></li><li><p>move key  数据库索引  </p><p>​    将单前key移动到另外的数据库</p></li><li><p>flushdb</p><p>​    清除当前数据的所有key</p></li><li><p>flushall</p><p>​    清除所有数据库的key</p></li></ul><h1 id="Redis常用数据类型"><a href="#Redis常用数据类型" class="headerlink" title="Redis常用数据类型"></a>Redis常用数据类型</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>介绍</strong></p><p>​        String是redis最基本的数据类型，是二进制安全的，意味着redis的string可以包含任何数据，比如jpg图片或者序列化对象。</p><p><strong>String命令</strong></p><ul><li><p>SET key value</p><p>​    设置给定的value值，如果key存在则覆盖旧值</p></li><li><p>SETNX  key value</p><p>​    只有key不存在时才进行设置</p></li><li><p>GET key</p><p>​    获取指定的key值，如果key不存在返回nil，如果key存储的不是string类型，返回一个错误</p></li><li><p>GETRANGE key start end</p><p>​    用于获取存储在key中字符串的子字符串，字符串的截取范围由start和end决定（包括start和end）</p></li><li><p>GETBIT key offset</p><p>​    对key所存储的字符串，获取指定偏移量上的位</p></li><li><p>MGET key1 key2….</p><p>​    获取多个key的值</p></li><li><p>GETSET  key  value</p><p>​    用于设置指定key的值并返回旧值，如果key之前不存在则返回nil</p></li><li><p>STRLEN  key</p><p>​    返回key对应字符串的长度</p></li><li><p>DEL key</p><p>​    删除指定的key</p></li><li><p>INCRBY key [增量值]</p><p>​    将存储数字自增（默认1），如果key不存在则初始化位0再进行自增</p></li><li><p>DECR key [减值]</p></li><li><p>APPEND key value</p><p>将指定value追加到存储值末尾</p></li></ul><p><strong>应用场景</strong></p><ol><li>string通常用于保存单个字符或者json字符串数据</li><li>因为string的二进制安全的，所以可以保存图片文件的内容当作字符串来存储</li><li>计数器 （例如：粉丝数、登陆错误次数记录）</li></ol><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p><strong>介绍</strong></p><p>​        hash是一个string类型的field和value的映射表，hash特别适合存储对象，Redis每个hash可以存储2^32^-1键值对</p><p><strong>Hash命令</strong></p><ul><li><p>HSET key  field value [field value field value……]</p><p>​    设置一对或多对键值到key中</p></li><li><p>HGET key field</p><p>​    获取key中field对应的值</p></li><li><p>HMGET key filed filed…. </p><p>​    获取key中多个field的值</p></li><li><p>HGETALL key </p><p>​    返回key中所有的字段和值</p></li><li><p>HKEYS key</p><p>​    获取key中所有的字段</p></li><li><p>HLEN key  </p><p>​    获取哈希表中的字段数量</p></li><li><p>HDEL key field [field….]</p><p>​    删除一个或多个HASH表字段</p></li></ul><p><strong>应用场景</strong></p><p>​        基于hash的特性，我们可以用hash类型来存储java bean对象</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><strong>介绍</strong></p><p>​        Redis中的List是简单的字符串列表，按照插入的顺序排序，可以添加一个元素到列表的左边或右边。一个列表最多可以包含2^32-1个元素。</p><p><strong>List命令</strong></p><ul><li><p>LPUSH key value [value…….]</p><p>将一个或多个值插入列表左侧</p></li><li><p>RPUSH key value [value…….]</p><p>​    将一个或多个值插入列表右侧</p></li><li><p>LPUSHX key value </p><p>​    将一个值插入列表左侧，如果列表不存在则无效</p></li><li><p>RPUSHX key value </p><p>​    将一个值插入列表右侧，如果列表不存在则无效</p></li><li><p>LLEN key</p><p>​    获取列表长度</p></li><li><p>LINDEX key index</p><p>​    获取列表指定下标的的元素</p></li><li><p>LRANGE key start end</p><p>​    获取列表指定范围内的值（0表示第一个元素，1表示第二个元素，-1代表最后一个元素，-2代表倒数第二个元素）</p></li><li><p>LPOP </p><p>​    从左侧获取并移除第一个元素</p></li><li><p>RPOP </p><p>​    从右侧获取并移除第一个元素</p></li><li><p>BLPOP key [key2…] timeout(秒)</p><p>​    阻塞地移除并获取第一个元素,直到超时或者发现可弹出数据</p></li><li><p>BRPOP key [key2…] timeout(秒)</p><p>​    阻塞地移除并获取右侧第一个元素,直到超时或者发现可弹出数据</p></li><li><p>LTRIM key start end</p><p>​    对列表进行修剪，不在区间内的元素将被删除</p></li><li><p>LSET key index value</p><p>​    对指定索引的元素进行设置</p></li><li><p>LINSERT key BEFORE | AFTER word value</p><p>​    将value插入列表中，位于值world之前或之后</p></li><li><p>RPOPLPUSH  source destination</p><p>​    移除列表的最后一个元素并添加到另一个列表返回</p></li><li><p>BRPOPLPUSH  source destination timeout</p><p>​    阻塞地进行</p></li></ul><p><strong>应用场景</strong></p><ol><li><p>对数据量大的集合进行数据删减</p><p>​    数据列表显示、关注列表、粉丝列表‘、留言评价、热点新闻</p></li><li><p>任务队列</p><p>​    list可以用来实现一个消息队列，而且可以确保先后顺序</p></li></ol><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><strong>介绍</strong></p><p>​        Redis的set是String类型的无序集合。集合的成员是唯一的。Redis中的集合是通过哈希来实现的，所以添加，删除，查找的复杂的都是O(1)。集合中最大成员数为2^32^-1。</p><p><strong>Set命令</strong></p><ul><li><p>SADD key value [value]</p><p>​    往集合中存储一个或多个成员</p></li><li><p>SCARD key</p><p>​    获取集合成员个数</p></li><li><p>SMEMBERS key</p><p>​    获取集合中所以成员</p></li><li><p>SISMEMBER key value</p><p>​    判断集合中是否存在某个value</p></li><li><p>SRANDMEMBER key [count]</p><p>​    随机返回集合中一个或多个成员</p></li><li><p>SREM key value [value…]</p><p>​    移除集合中一个或多个成员</p></li><li><p>SPOP key [count]</p><p>​    随机移除并返回集合中的一个元素</p></li><li><p>SMOVE source destination value</p><p>​    将value从source集合移到destination集合</p></li><li><p>SDIFF key1 [key2]</p><p>​    返回所有给定集合的差集</p></li><li><p>SDIFF destination key1 [key2]</p><p>​    返回所有给定集合的差集,并存放在destination 中</p></li><li><p>SINTER key1 [key2]</p><p>​    返回所有给定集合的交集</p></li><li><p>SINTER destination key1 [key2]</p><p>​    返回所有给定集合的交集,并存放在destination 中</p></li><li><p>SUNION key1 [key2]</p><p>​    返回所有给定集合的并集</p></li><li><p>SUNION destination key1 [key2]</p><p>​    返回所有给定集合的并集,并存放在destination 中</p></li></ul><p><strong>应用场景</strong></p><p>​        常用于两个集合数据之间的交叉并运算</p><ol><li>方便实现如共同关注、共同喜好、二度好友功能</li><li>利用唯一性可以统计网站的独立ip</li></ol><h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><p><strong>介绍</strong></p><p>​        不同于set，zset中每个元素都会关联一个double类型的分数，redis通过分数为元素中的成员进行排序，分数（score）可以重复。</p><p><strong>Zset命令</strong></p><ul><li><p>ZADD key score1 value1 [score2 value2]</p><p>​    向有序集合添加一个或多个成员，或者更新分数</p></li><li><p>ZCARD key</p><p>​    获取有序集合成员个数</p></li><li><p>ZCOUNT key min max</p><p>​    计算在有序集合中指定区间分数的成员数</p></li><li><p>ZRANK key value</p><p>​    返回有序集合中指定成员的索引</p></li><li><p>ZRANGE key start stop [WITHSCORES] </p></li></ul><p>​           返回有序集合中指定区间的成员(从低到高)</p><ul><li><p>ZREVRANGE key start stop [WITHSCORES] </p><p>​    返回有序集合中指定区间的成员(从高到低)</p></li><li><p>ZREM key value [value]</p><p>​    移除一个或多个元素</p></li><li><p>ZREMRANGEBYRANK key start stop</p><p>​    移除排名区间的元素（第一个为0）</p></li><li><p>ZREMRANGEBYSCORE key min max</p></li></ul><p>​            移除分数区间的元素</p><p><strong>应用场景</strong></p><ol><li>存储学生的成绩 value可以是学号，score为分数，这样就可以做到动态排序</li><li>还可以用zset来做带权重的队列，通过score来排序</li></ol><hr><h1 id="Java整合Redis"><a href="#Java整合Redis" class="headerlink" title="Java整合Redis"></a>Java整合Redis</h1><p><strong>通过Jedis访问Redis</strong></p><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试连接</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@org.junit.Test</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//连接远程redis</span></span><br><span class="line">       Jedis jedis = <span class="keyword">new</span> Jedis(ip地址,端口号);</span><br><span class="line">       <span class="comment">//权限验证</span></span><br><span class="line">       jedis.auth(密码);</span><br><span class="line">   </span><br><span class="line">       System.out.<span class="built_in">println</span>(jedis.ping());</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>使用SpringData提供的RedisTemplate</strong></p><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置RedisTemplate（采用注解）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Redis数据源配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisPoolConfig <span class="title">jedisPoolConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">100</span>);<span class="comment">//最大连接数</span></span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">20</span>);<span class="comment">//最大空闲数</span></span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);<span class="comment">//最大连接等待时间</span></span><br><span class="line">        poolConfig.setTestOnBorrow(<span class="keyword">true</span>);<span class="comment">//是否在取出连接前进行检验，如果检验失败则重新获取</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> poolConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring-Redis连接池工厂配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisConnectionFactory <span class="title">jedisConnectionFactory</span><span class="params">(JedisPoolConfig jedisPoolConfig)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        JedisConnectionFactory jedisConnectionFactory = <span class="keyword">new</span> JedisConnectionFactory(jedisPoolConfig);</span><br><span class="line">        jedisConnectionFactory.setHostName(ip地址);</span><br><span class="line">        jedisConnectionFactory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        jedisConnectionFactory.setPort(<span class="number">6379</span>);</span><br><span class="line">        <span class="keyword">return</span> jedisConnectionFactory;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取RedisTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate <span class="title">redisTemplate</span><span class="params">(JedisConnectionFactory jedisConnectionFactory)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">        RedisTemplate&lt;String, String&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">        redisTemplate.setConnectionFactory(jedisConnectionFactory);</span><br><span class="line">     redisTemplate.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        redisTemplate.setValueSerializer(stringRedisSerializer);</span><br><span class="line">        redisTemplate.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(stringRedisSerializer);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>  redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Redis分布订阅"><a href="#Redis分布订阅" class="headerlink" title="Redis分布订阅"></a>Redis分布订阅</h1><p>​        Redis分布订阅（pub/sub）是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。Redis客户端可以订阅任意数量的频道</p><p><img src="https://s2.ax1x.com/2020/02/20/3Z4Jkq.png" alt="image"></p><p><strong>订阅频道</strong></p><ul><li>SUBSCRIBE channel [channel..] 订阅一个或多个频道</li><li>PSUBSCRIBE pattern [pattern..] 订阅一个或多个给定模式的频道</li></ul><p><strong>发布频道</strong></p><ul><li>PUBLISH channel message 将消息发布到指定的频道</li></ul><p><strong>退订频道</strong></p><ul><li><p>UNSUBSCRIBE  channel [channel..]   退订一个或多个频道</p></li><li><p>PUNSUBSCRIBE pattern [pattern..] 退订一个或多个给定模式的频道</p></li></ul><p><strong>应用场景</strong></p><p>这一个功能可以用于各种实时消息系统，比如即时聊天，群聊等功能</p><h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><p><strong>事务介绍</strong></p><p>​        Redis的事务可以一次执行多个命令(允许在一次单独的步骤中执行一组命令)，批量操作在exec命令前被放入队列缓存，收到exec命令后进入事务执行，事务中的任意命令失败，其余命令依然被执行。并且具有以下两个特性。</p><ol><li>Redis会将一个事务的所有命令序列化，然后按顺序执行。</li><li>执行中不会被其他命令插入</li></ol><p>​        一个事务从开始到执行会经历以下三个阶段：开始事务&gt;命令入列&gt;执行事务</p><p><strong>事务命令</strong></p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">DISCARD</td><td align="center">取消事务，放弃执行事务块内的所有命令</td></tr><tr><td align="center">EXEC</td><td align="center">执行所有事务块内的命令</td></tr><tr><td align="center">MUTL</td><td align="center">标记一个事务块的开始</td></tr><tr><td align="center">UNWATCH</td><td align="center">取消watch命令对所有key的监视</td></tr><tr><td align="center">WATCH key [key..]</td><td align="center">监视一个或多个key，如果在事务执行前这些key被其他命令所改动，那么事务将被打断</td></tr></tbody></table><p><strong>事务错误处理</strong></p><p>​        Redis只有对报告错误进行事务回滚，什么叫报告错误？就是比如我在事务里写了 setww a 1这样一条命令，这条命令是无法执行成功的因为命令本身就不合法，所引发的错误。</p><p>​        Redis对于逻辑的错误，只会取消逻辑错误的语句，而不会进行事务回滚。比如 set a bb ； incrby a  。这样的命令就是逻辑错误。</p><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>​    <code>Redis有两种持久化机制：RDB、AOF</code></p><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>​        RDB是redis默认的持久化机制，相当于快照。这种方式就是将内存中的数据以快照的方式写入二进制文件中。默认文件名：dump.rdb</p><p><strong>快照条件</strong></p><ol><li>服务器正常关闭  ./bin/redis-cli shutdown</li><li>执行save(阻塞 保存快照) ；执行bgsave (异步保存)</li><li>flushall命令</li><li>满足redis.conf中save配置条件</li></ol><p><strong>相关配置</strong></p><ul><li><p>save <seconds> <change></p><p>​    指定在多次时间内有多少次更新操作，就将数据同步到数据文件中，可以多条件配合</p><p>​    save 900 1                900秒内有1个更改</p><p>​    save 300  10             300秒内有10个更改</p><p>​    save  60    10000      60秒内有10000个更改</p></li><li><p>rdbcompression </p><p>​    指定存储至本地数据库的时候是否采用LZF压缩，默认为true。如果设置成no可以节省cpu时间，但数据库文件会变大。</p></li><li><p>dbfilename</p><p>​    指定数据库文件名，默认为dump.rdb</p></li><li><p>dir ./</p><p>​    指定数据库文件存放位置</p></li></ul><p><strong>优点</strong></p><ul><li>快照保存数据极快，还原数据极快，适用于灾难备份</li><li>如果对数据完整性一致性要求不高，RDB是很好的选择</li></ul><p><strong>缺点</strong></p><ul><li>小内存机器不适合使用，因为执行rdb快照的时候redis会fork一个进程进行保存工作。</li><li>数据完整性一致性不高，因为RDB最后一次备份有可能宕机</li></ul><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>​        不同于RDB的快照方式，采用AOF可以更好地保证数据的完整性。redis会将每一个收到的写命令通过write函数追加到文件中（默认是appendonly.aof）。当redis重启时，会通过执行文件中的写命令来重建数据库的内容。</p><p><strong>触发条件</strong></p><p>​        根据appendfsync配置策略进行触发</p><p><strong>相关配置</strong></p><ul><li><p>appendonly on</p><p>​    指定是否每次在更新后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断点时导致一段时间的数据丢失。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会有一段时间内只存在于内存中。默认为no</p></li><li><p>appendfilename appendonly.aof</p><p>​    指定更新日志文件名</p></li><li><p>appendfsync</p><p>​    指定更新日志条件：</p><ul><li>no  表示等操作系统进行数据缓存同步到磁盘</li><li>always  表示每次更新后手动调用fsync()将数据写到磁盘 (慢，安全)</li><li>everysec   表示每秒同步一次</li></ul><table><thead><tr><th align="center">参数</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">always</td><td align="center">不丢失数据</td><td align="center">IO开销大</td></tr><tr><td align="center">everysec</td><td align="center">每秒进行与fsync，最多丢失1秒数据</td><td align="center">可能丢失1秒数据</td></tr><tr><td align="center">no</td><td align="center">不需要redis管控</td><td align="center">不可控</td></tr></tbody></table></li></ul><p><strong>AOF重写</strong></p><p>​        由于AOF的追加命令特点，文件一般会比RDB大而且很多是无用的命令。所以redis支持AOF重写优化存储文件。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto</span>-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line"><span class="built_in">auto</span>-aof-rewrite-min-size <span class="number">64</span>mb</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>数据完整性和一致性更高</li></ul><p><strong>缺点</strong></p><ul><li>因为AOF记录的内容多，文件会越来越大，数据恢复也会越来越慢。</li></ul><h1 id="RDB和AOF对比"><a href="#RDB和AOF对比" class="headerlink" title="RDB和AOF对比"></a>RDB和AOF对比</h1><table><thead><tr><th></th><th align="center">RDB</th><th align="center">AOF</th></tr></thead><tbody><tr><td>启动优先级</td><td align="center">低</td><td align="center">高</td></tr><tr><td>文件体积</td><td align="center">小</td><td align="center">大</td></tr><tr><td>恢复速度</td><td align="center">快</td><td align="center">慢</td></tr><tr><td>数据安全性</td><td align="center">不太高有可能丢失数据</td><td align="center">根据策略决定</td></tr></tbody></table><h1 id="Redis缓存与数据库一致性"><a href="#Redis缓存与数据库一致性" class="headerlink" title="Redis缓存与数据库一致性"></a>Redis缓存与数据库一致性</h1><h2 id="实时同步"><a href="#实时同步" class="headerlink" title="实时同步"></a>实时同步</h2><p>​        对一致性比较高的，应采用实时同步方案。即查询缓存查询不到直接查询数据库，保存缓存。更新缓存时，先更新数据库，再设置缓存过期（建议不要更新缓存内容）。</p><p>​        </p><h2 id="异步队列"><a href="#异步队列" class="headerlink" title="异步队列"></a>异步队列</h2><p>​        对于并发程度较高的，可以采用异步队列的方式同步，采用消息中间件来处理消息。</p><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><p>​        Redis要实现主从复制架构非常简单，主服务器不需要做任何修改，只需要对从服务器做相应的配置就可以了。</p><p>创建一个从服务器</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/redis-server ./redis.conf -port <span class="number">6380</span> -slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><p>主服务器负责写操作，从服务器只负责读，同步主服务器的更新数据。</p><p><strong>主从复制的作用</strong></p><ul><li>数据备份：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务实现故障转移；实际上是一种服务冗余</li><li>负载均衡：在主从复制的基础上实现读写分离，由主节点提供写服务，从节点提供读服务，提高Redis的并发能力</li><li>高可用基石：主从复制的哨兵模式和集群实现的基础</li></ul><h1 id="Redis-Cluster集群"><a href="#Redis-Cluster集群" class="headerlink" title="Redis Cluster集群"></a>Redis Cluster集群</h1><p>​        Redis3.0之后支持redis-cluster,至少<strong>3(master)+3(slave)</strong>才能建立集群。Redis-Cluster采用无中心化结构，每个节点保存数据和整个集群状态，每个节点都和其他节点连接。</p><p><strong>搭建流程</strong></p><ol><li><p>创建Redis节点安装目录</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /usr/<span class="built_in">local</span>/redis_cluster</span><br></pre></td></tr></table></figure></li><li><p>在redis_cluster目录下创建6个安装文件夹</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="number">7001</span> <span class="number">7002.</span>...<span class="number">.7006</span></span><br></pre></td></tr></table></figure></li><li><p>将redis-conf分别拷贝到安装文件夹下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp  <span class="regexp">/usr/</span>src<span class="regexp">/redis-4.0.1/</span>redis.conf <span class="regexp">/usr/</span>local<span class="regexp">/redis-cluster/</span><span class="number">7001</span></span><br></pre></td></tr></table></figure></li><li><p>分别修改配置文件</p><p><strong>protected-mode</strong>是为了禁用公网外部访问redis cache。启用条件有两个</p><ol><li>没有bind IP</li><li>没有设置访问密码</li></ol><p>如果希望外部访问需要将protected-mode设置为no</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bind 192.168.127.130 <span class="comment">//绑定服务器ip地址</span></span><br><span class="line">port 7001 <span class="comment">//绑定端口号，区分redis实例</span></span><br><span class="line">daemonize yes <span class="comment">//后台运行</span></span><br><span class="line">pidfile /<span class="keyword">var</span>/<span class="keyword">run</span>/redis-7001.pid <span class="comment">//修改pid进程文件</span></span><br><span class="line">logfile /root/application/<span class="keyword">program</span>/redis-<span class="keyword">cluster</span>/7001/redis.<span class="keyword">log</span> <span class="comment">//日志文件位置</span></span><br><span class="line"><span class="keyword">dir</span> /root/application/<span class="keyword">program</span>/redis-<span class="keyword">cluster</span>/7001/  <span class="comment">//数据文件存放地址</span></span><br><span class="line"><span class="keyword">cluster</span>-enabled yes <span class="comment">//启用集群</span></span><br><span class="line"><span class="keyword">cluster</span>-config-<span class="keyword">file</span> nodes-7001.<span class="keyword">conf</span> <span class="comment">//配置每个节点的配置文件</span></span><br><span class="line"><span class="keyword">cluster</span>-node-timeout 15000 <span class="comment">//节点超时时间</span></span><br><span class="line">appendonly yes <span class="comment">//启用AOF持久化策略</span></span><br><span class="line">appendfsync always <span class="comment">//AOF追加策略</span></span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>启动各个redis节点</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">#将redis-4.0.1安装目录下的src复制到7001-7006目录下</span></span><br><span class="line">   <span class="keyword">cd</span>  <span class="string">/usr/src/redis-4.0.1/</span></span><br><span class="line">   cp -r <span class="string">./src</span> <span class="string">/usr/loca/redis_cluster/7001</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">#进入各个目录启动redis</span></span><br><span class="line">   <span class="keyword">cd</span> <span class="string">/usr/local/redis_cluster/</span></span><br><span class="line"><span class="string">./7001/src/redis-server</span> <span class="string">./7001/redis.conf</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>创建集群</strong></p><p>​        Redis官方提供了redis-trib.rb来创建集群，就在解压目录src下。我们可以将这个命令复制到/usr/local/bin下方便我们以后使用</p><p>​        然后直接在命令使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">redis-trib</span><span class="selector-class">.rb</span> <span class="selector-tag">create</span> <span class="selector-tag">--replicas</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:7001</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:7002</span> ....</span><br></pre></td></tr></table></figure><p>​        如果出现了<code>ruby :没有那个文件或目录</code>则需要安装ruby</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y <span class="keyword">install </span>ruby ruby-devel rubygems rpm-<span class="keyword">build</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">gem </span><span class="keyword">install </span>redis</span><br></pre></td></tr></table></figure><p>​        如果还出现错误，则是因为Centos默认支持的ruby版本过低，需要安装rvm，再把ruby提升到2.2.2以上</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">gpg --keyserver hkp:<span class="comment">//keys.gnupg.net --recv-keys</span></span><br><span class="line"><span class="number">409</span>B6B1796C275462A1703113804BB82D39DC0E3</span><br><span class="line"><span class="number">7</span>D2BAF1CF37B13E2069D6956105BD0E739499BDB</span><br><span class="line"></span><br><span class="line">curl -sSL http:<span class="comment">//get.rvm.io | bash -s stable</span></span><br><span class="line"></span><br><span class="line">find / -name rvm-print</span><br><span class="line"></span><br><span class="line">source /usr/local/rvm/scripts/rvm</span><br><span class="line"></span><br><span class="line">rvm list known <span class="comment">//查看ruby版本</span></span><br><span class="line"></span><br><span class="line">rvm install <span class="number">2.4</span><span class="number">.4</span></span><br><span class="line"></span><br><span class="line">rvm use <span class="number">2.4</span><span class="number">.4</span> <span class="comment">//使用版本</span></span><br><span class="line"></span><br><span class="line">rvm use <span class="number">2.4</span><span class="number">.4</span> --dafault <span class="comment">//设置默认版本</span></span><br><span class="line"></span><br><span class="line">ruby --version</span><br><span class="line"></span><br><span class="line">gem install redis</span><br></pre></td></tr></table></figure><p><strong>测试集群</strong></p><ol><li><p>启动上面配置的6个redis，使用redis-trib.rb进行搭建</p></li><li><p>连接集群</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">redis-cli</span> <span class="string">-h</span> <span class="number">127.0</span><span class="number">.01</span> <span class="string">-c</span> <span class="string">-p</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -c 连接集群</span></span><br><span class="line"><span class="comment"># -h 由于绑定了ip地址，所有-h不可省略</span></span><br><span class="line"></span><br><span class="line"><span class="string">cluster</span> <span class="string">nodes</span> <span class="comment">#查看集群状态</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>开放端口权限</strong></p><ol><li><p>一次开放端口权限</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --list-ports <span class="comment">#查看已开放端口</span></span></span><br><span class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --zone=public --add-port=7001/tcp --permanent</span></span><br><span class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --reload</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis简介&quot;&gt;&lt;a href=&quot;#Redis简介&quot; class=&quot;headerlink&quot; title=&quot;Redis简介&quot;&gt;&lt;/a&gt;Redis简介&lt;/h1&gt;&lt;p&gt;​        &lt;code&gt;Redis是一个基于内存、支持持久化、的高性能NoSql的key-value数据库。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Redis的特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持数据持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次进行加载。&lt;/li&gt;
&lt;li&gt;数据结构丰富，支持string、list、set、zset、hash…….&lt;/li&gt;
&lt;li&gt;支持数据备份、集群等高可用功能&lt;/li&gt;
&lt;li&gt;性能高 （读速度：110000次/s，写速度：8100次/s）&lt;/li&gt;
&lt;li&gt;原子性，Redis所有操作都是原子性的&lt;/li&gt;
&lt;li&gt;特性丰富，Redis还支持发布/订阅、通知…..&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Redis" scheme="http://liuyoubin.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>JUC笔记</title>
    <link href="http://liuyoubin.top/2020/02/12/backEnd/java/JUC%E7%AC%94%E8%AE%B0/"/>
    <id>http://liuyoubin.top/2020/02/12/backEnd/java/JUC%E7%AC%94%E8%AE%B0/</id>
    <published>2020-02-12T10:00:47.000Z</published>
    <updated>2020-03-06T10:32:27.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC简介"><a href="#JUC简介" class="headerlink" title="JUC简介"></a>JUC简介</h1><p>​        java.util.concurrent包的简称，目的就是为了更好的支持高并发任务，让开发者利用这个包进行的多线程编程时可以有效的减少竞争条件和死锁线程。</p><a id="more"></a><h1 id="Volatile关键字与内存可见性"><a href="#Volatile关键字与内存可见性" class="headerlink" title="Volatile关键字与内存可见性"></a>Volatile关键字与内存可见性</h1><p>　　对于volatile关键字，不少人应该都用过。这个关键字是用于保证共享变量的<strong>“可见性”，禁止指令进行重排序</strong>。</p><p>　　<strong>“可见性”</strong>：可见性是指当多个线程访问同一个共享变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p>　　“<strong>指令重排序”：</strong>对于没有依赖关系的代码，编译器可能会进行指令重排序，优化计算。</p><p>一、可见性</p><p>1.1 为什么需要保证“可见性”</p><p>　　我们知道所有的指令都需要在cpu中执行，而程序数据在运行过程中都是存放在主存中。在这个过程中就会涉及数据的写入与读出。然而cpu与主存的执行速度相差很大，如何cpu与内存之间直接进行数据交换，那么cpu的运行效率将大大降低为此cpu引入了<strong>高速缓存</strong>的概念。在程序运行过程中会将需要交与cpu处理的数据从主存中复制一份放到高速缓存中，而cpu将从高速缓存中读取写入数据，然后将高速缓存中的数据刷新到主存中。正是由于这这个原因才需要确保共享变量的“可见性”。</p><p>　　看下面的这段代码</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">i</span>=i+<span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>　　当程序运行到这段代码时，首先会将从主存中获取到 i 的值然后写到高速缓存中，cpu在高速缓存中读取数据后进行+1操作再写到高速缓存中。最后再从高速缓存将新值刷新到主存中。</p><p>　　这段代码在单线程中运行是没有问题的，然而在多线程线程环境下就可能会出现问题。</p><p>　　例如现在有两个线程1、2同时执行上面这一段代码，i 的初始值为0。预期的结果是i进行了两次+1操作后，值变成2。但是也可能出现另一种情况。</p><p>线程1和线程2将 i 的值写入自己的高速缓存中，线程1进行+1操作后将值写回主存，此时线程2高速缓存中的值还是0，进行+1操作后写回主存。最终 i 的值是1。 这就出现了<strong>缓存一致性</strong>的问题。此时就需要<strong>volatile</strong>来保证可见性。</p><p>1.2 ”volalite“保证一致性的原理</p><p>　　在有”volatile”修饰的共享变量在进行写操作的时候会，出现在汇编代码后面生成一条<strong>Lock</strong>前缀的指令。这条指令会在多核处理器下引发两件事。</p><p>　　<strong>1）Lock前缀指令会引起处理器缓存写回内存</strong></p><p>　　　　 从上面我们知道，内存中的需要运算的数据会被线程复制一份到高速缓存中，再由cup进行运算写回高速缓存，但是何时写回主存就无法得知。如果变量声明了volatile关键字进行了写操作，那么<strong>JVM就会向处理器发送一条Lock前缀的指令</strong>，此时这个变量所在的缓存的数据就会被写进系统内存。但是这样还无法解决缓存一致因为共享变量的其他缓存的值还是旧的，所有就有了第二条。</p><p>　　<strong>2）一个处理器的缓存写回内存会导致其他处理器的缓存无效</strong></p><p>　　　　为了保证各个处理器的缓存是一样的，每个处理器会通过嗅探在总线上传播数据来检查自己的缓存是不是过期了，当处理器发现自己的缓存对应的内存地址被修改，就会将当前处理器的缓存设置为无效状态，当处理器对数据进行操作的时候会重新从主存中读取数据。</p><p>　　</p><p>　　<strong>通过这两件事，volatile实现了变量的可见性。</strong> </p><hr><p>二 、 禁止指令重排序</p><p>2.1 什么是指令重排序</p><p>　　所谓指令重排序就是编译器和处理器为了代码的执行效率会对指令进行重新排序,我们称之为重排序。但是虽然编译器和处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同。</p><p>　　比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;<span class="comment">//语句1</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">20</span>;<span class="comment">//语句2</span></span><br><span class="line"><span class="keyword">int</span> k = i + j; <span class="comment">//语句3</span></span><br></pre></td></tr></table></figure><p>　　上面这段代码，的执行顺序有可能是语句1-&gt;语句2-&gt;语句3，也有可能是语句2-&gt;语句1-&gt;语句3(指令重排)，但是有没有可能是语句3-&gt;语句2-&gt;语句1？</p><p>答案肯定是不。因为语句三的执行依赖 i 和 j 。指令在重排的时候会考虑数据的依赖性。</p><p> 2.1 为什么要禁止指令重排序</p><p>　　指令重排序在单线程的情况下不会影响程序的正确性，那么多线程的情况下呢? 看以下的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();<span class="comment">//语句1</span></span><br><span class="line"><span class="keyword">boolean</span> isTrue= <span class="keyword">true</span>;<span class="comment">//语句2 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isTrue)&#123;<span class="comment">//语句3 </span></span><br><span class="line"></span><br><span class="line">　　a.<span class="keyword">do</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　假设现在有两个线程1、2.线程。由于语句1和语句2没有依赖性，所以线程1有可能先执行语句2，此时线程2判断到isTrue==true认为可以执行语句3，而此时a并没有初始化，所以程序抛出空指针异常。</p><p>　　由此看出指令重排序在单线程下不会有问题，但是在多线程下还是存在问题。</p><p>　　如果我们将isTrue声明为volatile就能禁止处理器指令重排序按照语句1-&gt;语句2的顺序执行。也就是说<strong>在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</strong></p><p>三、注意</p><ul><li>Volatile不保证变量的原子 性</li><li>Volatile不具有互斥性</li></ul><h1 id="原子变量与CAS算法"><a href="#原子变量与CAS算法" class="headerlink" title="原子变量与CAS算法"></a>原子变量与CAS算法</h1><p>一、 原子性问题        </p><p>​        上面说到Volatile不能保证变量的原子性，下面给一个例子说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAtomicDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AtomicDemo demo = <span class="keyword">new</span> AtomicDemo();</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threadPool.submit(demo);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//获取num的数值，然后执行自增操作</span></span><br><span class="line">        System.out.print(getNum()+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        通过测试可以发现存在原子性问题。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>​        为什么呢？因为自增操作其实是三部分组成</p><ul><li><p>从主存中读取数组 int temp = num</p></li><li><p>执行+1操作  temp = temp +1</p></li><li><p>将更新后的值刷回内存  num = temp</p><p>​        Volailte只保证变量的可见性，也就是对变量的修改其他线程可以立即感知，但是在自增操作中+1操作其实是对临时变量执行的，所以无法保证原子性。</p></li></ul><p>二、原子变量</p><p>​        对于原子变量的问题可以使用<strong>java.util.concurrent.atomic</strong> 包下提供的原子变量进行解决。</p><p>对于原子变量而言：</p><ul><li><p>通过Volatile保证可见性</p></li><li><p>通过CAS（Compare-And-Swap）算法保证原子性</p><p><code>CAS是硬件对于并发操作共享数据的支持,包含了内存值V、预估值A、更新值B。当V==A时V=B</code></p></li></ul><h1 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h1><blockquote><p>JUC提供了一套线程安全的集合类，解决以前的集合类在多线程情况下不安全的问题</p></blockquote><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>​        ConcurrentHashMap是jdk5增加的一个线程安全的哈希表，对于多线程操作性能介于HashMap和HashTable之间，内部采用分段锁代替独占锁提高性能。</p><p>​        当期望多线程访问一个容器时：</p><ul><li>ConcurrentHashMap由于同步HashMap</li><li>ConcurrentSkipListMap优于同步TreeMap</li><li>当查询操作多于更新操作时，CopyOnWriteArrayList由于同步ArrayList</li></ul><h1 id="并发辅助类"><a href="#并发辅助类" class="headerlink" title="并发辅助类"></a>并发辅助类</h1><h2 id="同步计数器CountDownLatch"><a href="#同步计数器CountDownLatch" class="headerlink" title="同步计数器CountDownLatch"></a>同步计数器CountDownLatch</h2><p>​        CountDownLatch是一个同步辅助类，它可以在一组线程完成操作之前，让一个或多个线程一直等待。</p><p>​        形象的说CountDownLath就像一个计数发令枪，这样等到计数完成才发令通知线程继续执行。</p><p>​        下面给一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCountDownLatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计数器</span></span><br><span class="line">            CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                threadPool.submit(<span class="keyword">new</span> Demo(countDownLatch));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计数完毕,主线程才继续执行</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"主线程执行"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    Demo(CountDownLatch countDownLatch)&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//执行完毕计数器减1</span></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pool<span class="number">-1</span>-thread<span class="number">-2</span>执行完毕</span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-1</span>执行完毕</span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-5</span>执行完毕</span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-3</span>执行完毕</span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-4</span>执行完毕</span><br><span class="line">主线程执行</span><br></pre></td></tr></table></figure><h2 id="循环屏障CyclicBarrier"><a href="#循环屏障CyclicBarrier" class="headerlink" title="循环屏障CyclicBarrier"></a>循环屏障CyclicBarrier</h2><p>​        CyclicBarrier允许一组线程全部等待彼此到达共同屏障点的同步辅助类。之所以称为循环，是因为它可以在所以线程释放之后，重新使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"召唤神龙成功！"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">7</span> ; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"收集到第："</span>+temp+<span class="string">"颗龙珠"</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h2><p>​        计数信号量，一个信号量维护一组许可证。信号量通常用于限制线程数，而不是访问某种资源。</p><ul><li>acquire() 获得执行，如果已满则等待直到释放</li><li>release()  会将当前信号量+1，唤醒等待的线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//限制线程数量：停车位</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();<span class="comment">//得到</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"抢到车位"</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"离开车位"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();<span class="comment">//释放</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h1><p>​        相较于实现Runnable方法：</p><ul><li>实现Callable接口的call方法可以有返回值以及可以抛出异常</li><li>执行Callable需要FutureTask实现类的支持，用于接受返回结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//采用线程池方式执行</span></span><br><span class="line">        ExecutorService threadPool = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threadPool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">            CallableDemo callableDemo = <span class="keyword">new</span> CallableDemo();</span><br><span class="line">            Future&lt;Integer&gt; future = threadPool.submit(callableDemo);</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//采用直接创建线程方式执行</span></span><br><span class="line">            FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CallableDemo());</span><br><span class="line">            <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">            Integer result = futureTask.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            result += i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="同步锁Lock"><a href="#同步锁Lock" class="headerlink" title="同步锁Lock"></a>同步锁Lock</h1><p>​        这是一种相比于同步代码块和同步方法更加灵活的同步机制。同步锁Lock是一个显示锁，通过lock()和unlock()进行加锁/解锁。</p><p>​        不同于Synchronized隐式锁，Lock要求我们手动释放锁，这一点至关重要，通常我们在finally块中释放，保证锁的释放完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">"1号窗口"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">"2号窗口"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">"3号窗口"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">                lock.lock();<span class="comment">//加锁</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" 售票成功,余票:"</span> + --ticket);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Synchronized和Lock的区别"><a href="#Synchronized和Lock的区别" class="headerlink" title="Synchronized和Lock的区别"></a>Synchronized和Lock的区别</h2><ul><li>Synchronized 内置关键字，Lock是一个接口</li><li>Synchronized 无法判断获取锁的状态，Lock可以获取锁的一个状态</li><li>Synchronized 会自动释放锁（隐式锁），Lock需要手动去释放锁（显式锁）</li><li>Synchronized 会导致线程的阻塞，Lock可以通过设置使得线程超时等待</li><li>Synchronized 是可重入锁，不可终断，非公平锁，Lock可重入锁，可判断，可设置公平</li><li>Synchronized 适合少量代码同步问题，Lock适合代码量多的同步问题</li></ul><h1 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h1><p><strong>通过synchronized关键字实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Clerk clerk = <span class="keyword">new</span> Clerk();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(clerk),<span class="string">"生产者"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(clerk),<span class="string">"消费者"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> product = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(product&gt;=<span class="number">10</span>)&#123; <span class="comment">//为了避免虚假唤醒，wait()方法应该在循环中</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"货物已满！"</span>);</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+ ++product);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(product&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"缺货中！"</span>);</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+ --product);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    Producer(Clerk clerk)&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            clerk.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    Consumer(Clerk clerk)&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            clerk.sale();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>通过Lock同步锁+Condition实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Clerk clerk = <span class="keyword">new</span> Clerk();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(clerk),<span class="string">"生产者"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(clerk),<span class="string">"消费者"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> product = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (product&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"货物已满！"</span>);</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ ++product);</span><br><span class="line">            condition.signalAll();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (product&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"缺货中！"</span>);</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ --product);</span><br><span class="line">            condition.signalAll();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    Producer(Clerk clerk)&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            clerk.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    Consumer(Clerk clerk)&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            clerk.sale();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程按序交替"><a href="#线程按序交替" class="headerlink" title="线程按序交替"></a>线程按序交替</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 实现ABC三个线程交替打印</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadLoop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        LoopDemo loopDemo = <span class="keyword">new</span> LoopDemo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">                loopDemo.loopA(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A线程"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">                loopDemo.loopB(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B线程"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">                loopDemo.loopC(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C线程"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoopDemo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示轮到第几个线程执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loopA</span><span class="params">(<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">1</span>)&#123;<span class="comment">//判断</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"第"</span>+col+<span class="string">"轮 第"</span>+i+<span class="string">"次"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            number=<span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loopB</span><span class="params">(<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">2</span>)&#123;<span class="comment">//判断</span></span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"第"</span>+col+<span class="string">"轮 第"</span>+i+<span class="string">"次"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            number=<span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loopC</span><span class="params">(<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">3</span>)&#123;<span class="comment">//判断</span></span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"第"</span>+col+<span class="string">"轮 第"</span>+i+<span class="string">"次"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            number=<span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="读写锁ReadWriteLock"><a href="#读写锁ReadWriteLock" class="headerlink" title="读写锁ReadWriteLock"></a>读写锁ReadWriteLock</h1><p>​        读写锁维护了一对锁，一个叫读锁一个叫写锁。读锁允许多个线程同时持有，而写锁是独占的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读写锁</span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//加读锁</span></span><br><span class="line">        lock.readLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+num);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加写锁</span></span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自旋锁-SpinLock"><a href="#自旋锁-SpinLock" class="headerlink" title="自旋锁 SpinLock"></a>自旋锁 SpinLock</h1><p>​        是指尝试获取锁失败的线程不会立即阻塞，而是采用<strong>循环的方式去尝试获取锁</strong>，这样的好处是减少线程上下文切换，缺点是会消耗CPU。</p><h2 id="手写自旋锁"><a href="#手写自旋锁" class="headerlink" title="手写自旋锁"></a>手写自旋锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Object&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>, thread));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span> );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="阻塞队列-BlockingQueue"><a href="#阻塞队列-BlockingQueue" class="headerlink" title="阻塞队列 BlockingQueue"></a>阻塞队列 BlockingQueue</h1><p><img src="https://s2.ax1x.com/2020/02/25/3Jx1df.png" alt="image"></p><h2 id="四组API"><a href="#四组API" class="headerlink" title="四组API"></a><strong>四组API</strong></h2><table><thead><tr><th align="center">操作方式</th><th align="center">抛出异常</th><th align="center">返回值，不抛出异常</th><th align="center">阻塞 等待</th><th align="center">超时 等待</th></tr></thead><tbody><tr><td align="center">添加</td><td align="center">add</td><td align="center">offer</td><td align="center">put</td><td align="center">offer(E,timeout,unit)</td></tr><tr><td align="center">移除</td><td align="center">remove</td><td align="center">poll</td><td align="center">take</td><td align="center">poll(timeout,unit)</td></tr><tr><td align="center">判断队列首元素</td><td align="center">element</td><td align="center">peek</td><td align="center"></td><td align="center"></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 抛出异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Object&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="number">1</span>));<span class="comment">//添加成功返回true</span></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="number">2</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="number">3</span>));</span><br><span class="line">        <span class="comment">//队列满,抛出IllegalStateException: Queue full</span></span><br><span class="line">        <span class="comment">//System.out.println(blockingQueue.add(4));</span></span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.remove());<span class="comment">//移除成功返回元素</span></span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        <span class="comment">//队列空,抛出NoSuchElementException</span></span><br><span class="line">        <span class="comment">//System.out.println(blockingQueue.remove());</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 有返回值，不抛出异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tes2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Object&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="number">1</span>));<span class="comment">//添加成功返回true</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="number">2</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="number">3</span>));</span><br><span class="line">        <span class="comment">//队列满,返回false,不抛出异常</span></span><br><span class="line">        <span class="comment">//System.out.println(blockingQueue.offer(4));</span></span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.poll());<span class="comment">//移除成功返回元素</span></span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        <span class="comment">//队列空,返回null,不抛出异常</span></span><br><span class="line">        <span class="comment">//System.out.println(blockingQueue.poll());</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 阻塞等待</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Object&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        blockingQueue.put(<span class="number">1</span>);</span><br><span class="line">        blockingQueue.put(<span class="number">2</span>);</span><br><span class="line">        blockingQueue.put(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//队列满,阻塞等待</span></span><br><span class="line">        <span class="comment">//System.out.println(blockingQueue.put(4));</span></span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.take());<span class="comment">//移除成功返回元素</span></span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        <span class="comment">//队列空,阻塞等待</span></span><br><span class="line">        <span class="comment">//System.out.println(blockingQueue.take());</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Object&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        blockingQueue.offer(<span class="number">1</span>);</span><br><span class="line">        blockingQueue.offer(<span class="number">2</span>);</span><br><span class="line">        blockingQueue.offer(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//队列满,超时等待  时间到后依然无法插入则返回false</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="number">4</span>,<span class="number">5</span>,TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.take());<span class="comment">//移除成功返回元素</span></span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        <span class="comment">//队列空,超时等待   时间到后依然无法取出则返回null</span></span><br><span class="line">        System.out.println(blockingQueue.poll(<span class="number">5</span>, TimeUnit.SECONDS));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>扩展</strong></p><p>​        同步队列<strong>SynchronousQueue</strong>,同步队列与其他队列不同。它不存储元素，每put一个元素后，就必须等待take元素后才能继续put。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>一、 线程池提供了一个线程队列，队列中保存着所有等待的线程, 避免了创建与销毁的额外开销，提高了性能。</p><p>二、 线程池体系结构</p><p><img src="https://s2.ax1x.com/2020/02/13/1O1vC9.png" alt="image"></p><h2 id="三大方法"><a href="#三大方法" class="headerlink" title="三大方法"></a>三大方法</h2><ul><li><p>*<em>ExecutorService   Executors.newFixedThreadPool() *</em> 创建固定大小的线程池</p></li><li><p>*<em>ExecutorService   Executors.newCachedThreadPool() *</em> 创建缓存线程池，大小根据需求自动更改</p></li><li><p>*<em>ExecutorService   Executors.newSingleThreadExecutor() *</em>创建单个线程池，只要一个线程</p></li></ul><p>  除了这三个还有一个是调度线程池</p><p><strong>ScheduledExecutorService   Executors.newScheduledThreadPool</strong>   创建固定大小线程池，可以延迟或定时的执行任务</p><h2 id="七大参数"><a href="#七大参数" class="headerlink" title="七大参数"></a>七大参数</h2><p>​        先看看上面三大创建线程池的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        可以看出本质上都是实例化了ThreadPoolExecutor，只是方法参数不同</p><p>而阿里巴巴开发手册有一点要求就是：</p><blockquote><p>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样 的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 </p><p>说明：Executors 返回的线程池对象的弊端如下： </p><p>1）FixedThreadPool 和 SingleThreadPool: 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 </p><p>2）CachedThreadPool 和 ScheduledThreadPool: 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p></blockquote><p>看看ThreadPoolExecutor的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, //核心线程池大小</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,//最大线程池大小</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,//超时时间，时间过了没人使用就会释放</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,//超时单位</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,//阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,//线程工厂，一般不用改动</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler//拒绝策略)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="四种拒绝策略"><a href="#四种拒绝策略" class="headerlink" title="四种拒绝策略"></a>四种拒绝策略</h2><p><img src="https://s2.ax1x.com/2020/02/25/3tFG6O.png" alt="image"></p><ol><li><p>什么时候会触发拒绝策略呢？</p><p>​    当线程池达到最大承载，还有任务提交到线程池的时候。最大承载: <strong>阻塞队列大小+最大线程数</strong>    </p><p>​    就像下面这段代码，自定义了一个线程池。此线程池的最大承载=<strong>阻塞队列大小+最大线程数</strong>=3+5=8，现在我提交了9个任务，线程池就会触发拒绝策略AbortPolicy，抛出异常。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>,<span class="comment">//核心线程池大小</span></span><br><span class="line">            <span class="number">5</span>,<span class="comment">//最大线程池大小</span></span><br><span class="line">            <span class="number">3</span>,<span class="comment">//超时时间，时间过了没人使用就会释放</span></span><br><span class="line">            TimeUnit.SECONDS,<span class="comment">//超时单位</span></span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),<span class="comment">//阻塞队列</span></span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());<span class="comment">//阻塞队列满了，还有任务添加就抛异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">        threadPool.execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" ok"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>四大拒绝策略的定义</li></ol><table><thead><tr><th align="center">拒绝策略</th><th align="center">执行行为</th></tr></thead><tbody><tr><td align="center">AbortPolicy</td><td align="center">抛出异常</td></tr><tr><td align="center">CallerRunsPolicy</td><td align="center">线程池拒绝处理，由提交的线程自行处理</td></tr><tr><td align="center">DiscardPolicy</td><td align="center">丢掉任务，不会抛出异常</td></tr><tr><td align="center">DiscardOldestPolicy</td><td align="center">尝试和最早的任务竞争线程，失败则丢掉任务，不会抛出异常</td></tr></tbody></table><h2 id="小结与拓展"><a href="#小结与拓展" class="headerlink" title="小结与拓展"></a>小结与拓展</h2><ol><li>最大线程数应该定义多少<ul><li>CPU密集型  一般服务器有多少核心线程数就定义多少；可以通过Runtime.getRuntime().availableProcessors()获取</li><li>IO密集型 （ io十分占用资源） 判断程序中十分耗费io的线程数，使得最大线程数&gt;该数目</li></ul></li></ol><h1 id="手写线程池"><a href="#手写线程池" class="headerlink" title="手写线程池"></a>手写线程池</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedSizeThreadPool</span> </span>&#123;</span><br><span class="line"><span class="comment">//1.需要有一个仓库来存放提交的任务</span></span><br><span class="line"><span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; blockingQueue;</span><br><span class="line"><span class="comment">//2.需要有一个线程的集合</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Thread&gt; workers;</span><br><span class="line">    <span class="comment">//3.标志线程池的工作状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isWorking = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//4.需要有一个人来干活</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> FixedSizeThreadPool pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(FixedSizeThreadPool pool)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.pool = pool;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//希望它能够不断地向仓库拿东西</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">this</span>.pool.isWorking||<span class="keyword">this</span>.pool.blockingQueue.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">Runnable task = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.pool.isWorking) &#123;</span><br><span class="line">                        <span class="comment">//阻塞地从队列拿取任务</span></span><br><span class="line">task = <span class="keyword">this</span>.pool.blockingQueue.take();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//非阻塞地拿取任务，队列为空则返回null</span></span><br><span class="line">task = <span class="keyword">this</span>.pool.blockingQueue.poll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(task!=<span class="keyword">null</span>) &#123;</span><br><span class="line">task.run();</span><br><span class="line">System.out.println(<span class="string">"线程："</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.需要进行线程池初始化---规定仓库的大小和集合的大小，同时把线程准备好</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FixedSizeThreadPool</span><span class="params">(<span class="keyword">int</span> poolSize,<span class="keyword">int</span> taskSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(poolSize&lt;=<span class="number">0</span>||taskSize&lt;=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"非法参数"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.blockingQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(taskSize);</span><br><span class="line"><span class="keyword">this</span>.workers = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;poolSize;i++) &#123;</span><br><span class="line">Worker worker = <span class="keyword">new</span> Worker(<span class="keyword">this</span>);</span><br><span class="line">worker.start();</span><br><span class="line">workers.add(worker);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6，向仓库存放任务(非阻塞)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">submit</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.isWorking) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.blockingQueue.offer(task);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//7，向仓库存放任务(阻塞)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.blockingQueue.put(task);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//8.关闭线程池</span></span><br><span class="line"><span class="comment">//关闭前，不能让新线程进来</span></span><br><span class="line"><span class="comment">//关闭前，要让仓库中的东西执行完</span></span><br><span class="line"><span class="comment">//关闭的时候，如果再去仓库拿东西，就不能再阻塞了</span></span><br><span class="line"><span class="comment">//关闭的时候，如果线程已经阻塞，那么就全部中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.isWorking = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//到线程集合里面，判断线程状态</span></span><br><span class="line"><span class="keyword">for</span>(Thread thread:workers) &#123;</span><br><span class="line"><span class="keyword">if</span>(thread.getState().equals(Thread.State.WAITING)||thread.getState().equals(Thread.State.BLOCKED)) &#123;</span><br><span class="line">thread.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h1><blockquote><p>集合和数据库是负责存储的</p><p>计算应该交给流来处理</p></blockquote><p><strong>流式计算</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 看一道题,必须使用一行代码实现</span></span><br><span class="line"><span class="comment">    * 现在有五个用户,筛选</span></span><br><span class="line"><span class="comment">    * 1. ID必须是偶数</span></span><br><span class="line"><span class="comment">    * 2. 年龄必须大于23岁</span></span><br><span class="line"><span class="comment">    * 3. 用户名转成大写字母</span></span><br><span class="line"><span class="comment">    * 4. 用户名字母倒着排序</span></span><br><span class="line"><span class="comment">    * 5. 只输出一个用户</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       User u1 = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"a"</span>,<span class="number">21</span>);</span><br><span class="line">       User u2 = <span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">"b"</span>,<span class="number">24</span>);</span><br><span class="line">       User u3 = <span class="keyword">new</span> User(<span class="number">3</span>,<span class="string">"c"</span>,<span class="number">23</span>);</span><br><span class="line">       User u4 = <span class="keyword">new</span> User(<span class="number">4</span>,<span class="string">"d"</span>,<span class="number">24</span>);</span><br><span class="line">       User u5 = <span class="keyword">new</span> User(<span class="number">5</span>,<span class="string">"e"</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">       List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//lambda表达式、链式编程、函数式接口、Stream流计算</span></span><br><span class="line">       list.stream()</span><br><span class="line">               .filter(u-&gt;&#123; <span class="keyword">return</span> (u.getId()&amp;<span class="number">1</span>)==<span class="number">0</span>; &#125;)</span><br><span class="line">               .filter(u-&gt;&#123;<span class="keyword">return</span> u.getAge()&gt;<span class="number">23</span>;&#125;)</span><br><span class="line">               .map(u-&gt;&#123;<span class="keyword">return</span> u.getName().toUpperCase();&#125;)</span><br><span class="line">               .sorted((uu1,uu2)-&gt;&#123;<span class="keyword">return</span> uu2.compareTo(uu1);&#125;)</span><br><span class="line">               .limit(<span class="number">1</span>)</span><br><span class="line">               .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h1><p>​        ==分支合并框架，把大任务拆成小任务！并发执行任务提高效率！==</p><p><img src="https://s2.ax1x.com/2020/02/25/3tfF1O.png" alt="image"></p><p><strong>例子与对比</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long start;</span><br><span class="line">    <span class="keyword">private</span> Long end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//临界值</span></span><br><span class="line">    <span class="keyword">private</span> Long temp = <span class="number">10000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinDemo</span><span class="params">(Long start, Long end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((end-start)&lt;temp)&#123;<span class="comment">//正常计算</span></span><br><span class="line">            Long sum = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (Long i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//forkjoin</span></span><br><span class="line">            Long middle = (end+start)/<span class="number">2</span>;<span class="comment">//中间值</span></span><br><span class="line">            ForkJoinDemo task1 = <span class="keyword">new</span> ForkJoinDemo(start, middle);</span><br><span class="line">            task1.fork();<span class="comment">//拆分任务，把任务压入线程队列</span></span><br><span class="line">            ForkJoinDemo task2 =<span class="keyword">new</span> ForkJoinDemo(middle+<span class="number">1</span>, end);</span><br><span class="line">            task2.fork();<span class="comment">//拆分任务，把任务压入线程队列</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> task1.join()+task2.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===============================测试对比===============================</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Long sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (Long i = <span class="number">1L</span>; i &lt;= <span class="number">100000000L</span>; i++) &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"sum:"</span>+sum+<span class="string">" 耗费时间："</span>+(end-start));<span class="comment">//1091ms</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ForkJoin计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinDemo forkJoinDemo = <span class="keyword">new</span> ForkJoinDemo(<span class="number">1L</span>, <span class="number">100000000L</span>);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(forkJoinDemo);</span><br><span class="line">        Long sum = submit.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"sum:"</span>+sum+<span class="string">" 耗费时间："</span>+(end-start));<span class="comment">//772ms</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并行流计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//这个方法是左开区间，右闭区间</span></span><br><span class="line">        <span class="keyword">long</span> sum = LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">100000000L</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"sum:"</span>+sum+<span class="string">" 耗费时间："</span>+(end-start));<span class="comment">//144ms</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h1><blockquote><p>Future的设计初衷：对将来的某个事件的结果进行建模</p></blockquote><p><img src="https://s2.ax1x.com/2020/02/26/3txny9.png" alt="image"></p><blockquote><p>CompletableFuture是对Future的增强，可以使用来完成异步任务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有返回值的runAsync异步回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//开启一个异步任务</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" runAsync"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"runMain"</span>);</span><br><span class="line"></span><br><span class="line">        completableFuture.get();<span class="comment">//阻塞获取执行结果</span></span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有返回值的supplyAsync异步回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">       CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" supplyAsync"</span>);</span><br><span class="line">            <span class="comment">//int s = 10/0;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Integer integer = completableFuture2.whenComplete((u, t) -&gt; &#123;<span class="comment">//编译时回调</span></span><br><span class="line">            System.out.println(u);<span class="comment">//编译正确返回的结果</span></span><br><span class="line">            System.out.println(t);<span class="comment">//编译失败返回的结果</span></span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;<span class="comment">//编译失败时回调</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">        &#125;).get();</span><br><span class="line"></span><br><span class="line">        System.out.println(integer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><blockquote><p>​        JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。</p><p>​        JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p></blockquote><p><img src="https://s2.ax1x.com/2020/02/26/3UIlid.png" alt="image"></p><p>​        <strong>内存交互操作有八种，虚拟机实现保证每一个操作都是原子性的，不可分的。(对于double、long类型来说load、read、store、write操作在某些平台上允许例外)。</strong></p><ul><li><p>lock（锁定）：作用于主存上的变量，把一个变量表标识为线程独享</p></li><li><p>unlock（解锁）：作用于主存上的变量， 把一个处于锁定的变量释放出来</p></li><li><p>read（读取）：作用于主存上的变量，读取主存上的变量</p></li><li><p>load（载入）：作用于工作内存的变量，将read读取的变量放入工作内存</p></li><li><p>use（使用）：作用于工作内存的变量，把工作内存中的变量传输给执行引擎，每当虚拟机需要使用变量时，使用这个命令</p></li><li><p>assign（赋值）：作用于工作内存的变量，把执行引擎的值放入工作内存的对应变量中</p></li><li><p>store（存储）：作用于主存上的变量，将工作内存的值传到主存</p></li><li><p>write（写入）：将store传输的值存储到主存变量中</p></li></ul><p><strong>JMM对这八种指令，制定了如下操作</strong></p><ul><li><p>不允许read和load、store和write操作之一单独出现。即使用了read必须执行load，使用了store必须执行write</p></li><li><p>不允许线程丢弃它最近的assign操作，即工作内存变量的数据发生变化，必须告知主存</p></li><li><p>不允许一个线程将没有assign的数据同步回主存</p></li><li><p>一个新的变量必须在主存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作前，必须经过assign和load操作</p></li><li><p>一个变量同一时间只有一个变量进行lock操作，多次lock后必须执行相同次数的unlock才能解锁</p></li><li><p>如果对一个变量进行lock操作，回清空所有工作内存中此变量的值，在执行引擎使用该变量时，必须重新load或assign操作初始化变量的值</p></li><li><p>如果一个变量没有被lock，则不能unlock，也不能unlock一个被其他线程锁住的变量</p></li><li><p>对一个变量unlock之前，必须将变量同步回主存</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JUC简介&quot;&gt;&lt;a href=&quot;#JUC简介&quot; class=&quot;headerlink&quot; title=&quot;JUC简介&quot;&gt;&lt;/a&gt;JUC简介&lt;/h1&gt;&lt;p&gt;​        java.util.concurrent包的简称，目的就是为了更好的支持高并发任务，让开发者利用这个包进行的多线程编程时可以有效的减少竞争条件和死锁线程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="Java" scheme="http://liuyoubin.top/tags/Java/"/>
    
      <category term="多线程" scheme="http://liuyoubin.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="http://liuyoubin.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB与MYISAM</title>
    <link href="http://liuyoubin.top/2020/02/10/backEnd/database/InnoDB%E4%B8%8EMYISAM/"/>
    <id>http://liuyoubin.top/2020/02/10/backEnd/database/InnoDB%E4%B8%8EMYISAM/</id>
    <published>2020-02-09T16:31:14.000Z</published>
    <updated>2020-03-18T13:06:07.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a><strong>事务</strong></h2><p><strong>InnoDB支持事务，MyISAM不支持事务</strong></p><p>InnoDB默认将每一条sql语句都封装成事务，在实际开发中最后用具体的事务进行管理</p><a id="more"></a><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a><strong>外键</strong></h2><p><strong>InnoDB支持外键，MyISAM不支持外键</strong></p><h2 id="行级锁与表级锁"><a href="#行级锁与表级锁" class="headerlink" title="行级锁与表级锁"></a><strong>行级锁与表级锁</strong></h2><p><strong>InnoDB支持行级锁和表级锁，MyISAM只支持表级锁</strong></p><p>​        MyISAM的表级锁有两种模式：读锁（共享锁），写锁（排它锁）。所谓读锁就是在对表进行读操作的时候允许其他用户对表进行读操作，而阻塞其他用户对表进行写操作。而写锁就是在对表进行写操作的时候，阻塞其他用户的读操作和写操作。</p><p>​        InnoDB是通过对索引进行加锁实现行级锁的。所以如果不是通过索引条件来进行检索数据会导致行锁失效。在InnoDB两个事务发生死锁的时候，会计算出每个事务影响的行数，然后回滚行数少的那个事务。</p><p>​        比较：</p><ul><li>表锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突概率高，并发度最低</li><li>行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a><strong>索引</strong></h2><p><strong>InnoDB和MYISAM的索引结构都是B+树，不同的是InnoDB是聚集索引而MYISAM非聚集索引</strong></p><h3 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a><strong>B树和B+树</strong></h3><p><img src="https://s2.ax1x.com/2020/02/10/15umVO.png" alt="image"></p><p><img src="https://s2.ax1x.com/2020/02/10/15U3tI.png" alt="image"></p><p><strong>在结构上：</strong>B树的数据都是分布存在整棵树中，而B+树的数据只存放在叶子节点中，非叶子节点只存放数据的索引。</p><p><strong>B+树的优势</strong></p><ul><li><strong>B+树的磁盘读写代价更低</strong>：由于B+的数据都存在叶子节点中，所以每个非叶子节点就可以存放更多的索引信息，树就更加矮胖，IO读写次数也会更少。</li><li><strong>B+树的查询效率更稳定：</strong>由于B+的数据都存在叶子节点中，所以每一次查询的路径长度相同，效率稳定。</li><li><strong>B+树的区间查询更高效</strong>：B树的数据分布存储在整棵树中，所以区间查询效率低。而B+树的所有数据都在叶子节点且叶子节点还指向相邻的叶子节点，这样区间的查找效率就比较高。</li></ul><h3 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a><strong>聚集索引与非聚集索引</strong></h3><p><strong>非聚集索引</strong></p><p>​        所谓的非聚集索引就是指索引文件和数据文件是分离的，索引文件仅保存数据所在的物理地址。索引示例如下：</p><p><img src="https://s2.ax1x.com/2020/02/10/15d8Qf.png" alt="image"></p><p>​        </p><p><strong>聚集索引</strong></p><p>​        所谓聚集，就是指实际数据和主键索引存储在一起。</p><p>对于InnoDB来说：</p><ul><li>主键索引文件既存储索引又存储实际数据</li><li>如果没有指定主键，MySql会指定UniqueKey做主键</li><li>如果没有主键，则生成一个内部列作为主键</li><li>而对于辅助索引，实际存储的是主键值，也就是说会进行两次索引查询</li></ul><p><img src="https://s2.ax1x.com/2020/02/10/15y1AO.png" alt="image"></p><p>​                                                                                                                                                            </p><h2 id="具体行数的保存"><a href="#具体行数的保存" class="headerlink" title="具体行数的保存"></a>具体行数的保存</h2><p>​        InnoDB不保存表的具体行数，也就是说执行<code>select count(*) from  table</code>的时候InnoDB需要遍历整张表来计算，而MyISAM可以直接读出保存的行数</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>对于有事务要求的选择InnoDB，如果不需要可以考虑MyISAM</li><li>对于查询比较多的业务，考虑MyISAM。对于修改、插入操作比较频繁的可以选择InnoDB</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h1&gt;&lt;h2 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;&lt;strong&gt;事务&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;InnoDB支持事务，MyISAM不支持事务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;InnoDB默认将每一条sql语句都封装成事务，在实际开发中最后用具体的事务进行管理&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="数据库" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySql" scheme="http://liuyoubin.top/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>JVM探究</title>
    <link href="http://liuyoubin.top/2020/02/08/backEnd/java/JVM%E6%8E%A2%E7%A9%B6/"/>
    <id>http://liuyoubin.top/2020/02/08/backEnd/java/JVM%E6%8E%A2%E7%A9%B6/</id>
    <published>2020-02-08T09:45:26.000Z</published>
    <updated>2020-03-07T15:39:26.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM位置"><a href="#JVM位置" class="headerlink" title="JVM位置"></a>JVM位置</h1><p><img src="https://s2.ax1x.com/2020/02/28/3Dqzng.png" alt="image"></p><a id="more"></a><h1 id="JVM体系"><a href="#JVM体系" class="headerlink" title="JVM体系"></a>JVM体系</h1><p><img src="https://s2.ax1x.com/2020/02/28/3DXT74.png" alt="image"></p><h1 id="类加载器及双亲委派机制"><a href="#类加载器及双亲委派机制" class="headerlink" title="类加载器及双亲委派机制"></a>类加载器及双亲委派机制</h1><blockquote><p>通过类限定名将类动态地的字节码二进制流加载进JVM</p></blockquote><h2 id="类加载器体系"><a href="#类加载器体系" class="headerlink" title="类加载器体系"></a>类加载器体系</h2><p><img src="https://s2.ax1x.com/2020/02/28/3Djrgx.png" alt="image"></p><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><ol><li>类加载器收到类加载的请求</li><li>自己首先检查是否已经加载过这个类，如果以及加载过则不会加载。否则转到第3步</li><li>先将请求委派给父加载器，一直到启动类加载器</li><li>启动类加载器检查是否可以加载，如果可以则加载，如果无法加载则通知子加载器加载，一直到最下的加载器</li><li>如果所有加载器都无法加载则抛ClassNotFoundException</li></ol><h1 id="GC-Root"><a href="#GC-Root" class="headerlink" title="GC Root"></a>GC Root</h1><p>*<em>JVM如何判断一个对象是不再使用的对象(垃圾)? *</em></p><p>​    使用可达性分析算法，从一系列名为<strong>GC Root</strong>的对象出发，如果待判断的对象没有被GC Root任何引用链相连时，则说明此对象是不可用对象。</p><p><strong>哪些对象可以作为GC Root？</strong></p><ul><li>虚拟机栈（栈帧中的局部变量表）中引用的对象</li><li>方法区中的静态属性引用的对象</li><li>方法区中的常量引用的对象</li><li>本地方法栈中JNI（Native方法）引用的对象</li></ul><h1 id="四大引用"><a href="#四大引用" class="headerlink" title="四大引用"></a>四大引用</h1><p><img src="https://s2.ax1x.com/2020/03/07/3OnaRg.png" alt="image"></p><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>​        当内存不足时，JVM开始回收垃圾，对于强引用的对象，就算是出现OOM也不会对该对象进行回收</p><p>​        强引用就是我们常见的对象引用，当一个对象赋给一个引用变量，垃圾回收器就不回收该对象，强引用是引起OOM的主要原因之一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>​        相对于强引用来说软化了一些，需要实现java.lang.SolfReference类来实现</p><p>​        对于软引用的对象，当<strong>系统内存充足时不会被回收，当系统内存不足时会被回收。</strong>软引用通常用在对内存敏感的程序中，比如高速缓存中就用的软引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> Object());</span><br></pre></td></tr></table></figure><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>​        只要垃圾回收一执行，不管内存是否足够，弱引用的对象都会被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> Object());</span><br></pre></td></tr></table></figure><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>​        形同虚设的引用，如果一个对象仅持有虚引用，那么就和没有任何引用一样，在任何时候都可能被垃圾回收，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列(ReferenceQueue)联合使用。</p><p>​        虚引用的作用主要是跟踪对象被垃圾回收的状态。仅仅是提供一种确保对象被fianlize后，做某些事的机制。PhantomReference的get方法总返回null,其意义在说明一个对象进入到finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作。</p><p>​        换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候收到一个系统通知或者后续进一步处理。在Java中允许使用finalize()方法在垃圾收集器将对象回收之前做必要的清理工作。</p><h2 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h2><p>​        引用队列的作用：当软引用、弱引用、虚引用关联了引用队列，那么当这些引用的对象在被垃圾回收前，引用会被保存在引用队列中。</p><h1 id="GC-垃圾回收"><a href="#GC-垃圾回收" class="headerlink" title="GC 垃圾回收"></a>GC 垃圾回收</h1><h2 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h2><ol><li><p><strong>复制算法</strong></p><p>​        该算法将内存平均分成两部分，然后每次只使用其中的一部分，当这部分内存满的时候，将内存中所有存活的对象复制到另一个内存中，然后将之前的内存清空，只使用这部分内存，循环下去。</p><p>​        这个算法与标记-整理算法的区别在于，该算法不是在同一个区域复制，而是将所有存活的对象复制到另一个区域内。</p></li><li><p><strong>标记-清除算法</strong></p><p>​        为每个对象存储一个标记位，记录对象的状态（活着或是死亡）。</p><p>​        分为两个阶段，一个是标记阶段，这个阶段内，为每个对象更新标记位，检查对象是否死亡；第二个阶段是清除阶段，该阶段对死亡的对象进行清除，执行 GC 操作。</p></li><li><p><strong>标记-整理算法</strong></p><p>​        标记-整理法是标记-清除法的一个改进版。同样，在标记阶段，该算法也将所有对象标记为存活和死亡两种状态；不同的是，在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是将所有存活的对象整理一下，放到另一处空间，然后把剩下的所有对象全部清除。这样就达到了标记-整理的目的。</p></li><li><p><strong>引用计数算法</strong></p><p>​        每个对象在创建的时候，就给这个对象绑定一个计数器。每当有一个引用指向该对象时，计数器加一；每当有一个指向它的引用被删除时，计数器减一。这样，当没有引用指向该对象时，该对象死亡，计数器为0，这时就应该对这个对象进行垃圾回收操作。</p></li></ol><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="https://images2015.cnblogs.com/blog/249993/201703/249993-20170308202431391-1323581863.png" alt="image"></p><ol><li><p><strong>Serial（串行垃圾收集器）</strong></p><p>​        它为单线程环境下设计且只使用一个线程进行垃圾回收，会暂停所有用户线程，不适合服务器环境。</p><p>虽然需要暂停用户线程，但是简单高效，对于单CPU环境比较合适。</p><p><strong>对应JVM参数：-XX:+UseSerialGC</strong></p><p><strong>开启后会使用：Serial+Serial Old的收集器组合</strong></p><p><img src="https://s2.ax1x.com/2020/03/07/3jajXR.png" alt="image"></p></li><li><p><strong>ParNew（并行垃圾收集器）</strong></p><p>​    ParNew是Serial的多线程版本，通常和CMS配合使用，其余行为和Serial一样。</p><p><strong>对应JVM参数：-XX:+UseParNewGC</strong></p><p><strong>开启后会使用：Serial+Serial Old的收集器组合</strong></p><p><img src="F:%5Cpicture%5Cblog_picture%5CJVM%E6%8E%A2%E7%A9%B6%5C3jwnM9-1583590582707.png" alt="image"></p></li><li><p><strong>Parallel(并行垃圾回收器)</strong></p><p>​    多个垃圾收集线程并行工作，同样会暂停用户线程，适用于科学计算/大数据处理等弱交互场景。类似ParNew，俗称吞吐量优先收集器。</p><p><strong>对应JVM参数：-XX:+UseParallerGC或-XX:+UseParallerOldGC（互相激活）</strong></p><p><img src="https://s2.ax1x.com/2020/03/07/3jToHx.png" alt="image"></p><p><img src="https://s2.ax1x.com/2020/03/07/3jwnM9.png" alt="image"></p></li><li><p><strong>Parallel Old</strong>整理</p><p>Parallel的老年代版本，jdk1.6之后提供，关注吞吐量。</p></li><li><p><strong>CMS(并发标记清除)</strong></p></li></ol><p>​        用户线程和GC线程同时执行（不一定并行，可能交替执行），不需要停止用户线程，适用于对响应时间有要求的场景</p><p><img src="https://s2.ax1x.com/2020/03/07/3jqBGT.png" alt="image"></p><ol start="6"><li><strong>G1</strong></li></ol><p>​    G1垃圾回收器将堆内存分割成不同的区域然后并发的对其进行垃圾回收</p><h1 id="JVM常用参数"><a href="#JVM常用参数" class="headerlink" title="JVM常用参数"></a>JVM常用参数</h1><h2 id="查看JVM参数命令"><a href="#查看JVM参数命令" class="headerlink" title="查看JVM参数命令"></a>查看JVM参数命令</h2><ul><li><p>jps -l </p><p>查看当前的java进程</p></li><li><p>jinfo -flag 参数 进程号</p><p>查看某个进程的指定参数开启情况</p></li><li><p>jinfo -flags 进程</p><p>查看某个进程的所以参数开启情况</p></li></ul><hr><ul><li><p>java -XX:+PrintFlagsInitial</p><p>参看初始化参数情况</p></li><li><p>java -XX:+PrintFlagsFinal</p><p>参看修改后参数情况</p></li><li><p>java -XX:+PrintCommandLineFlags -version</p></li></ul><h2 id="标配参数"><a href="#标配参数" class="headerlink" title="标配参数"></a>标配参数</h2><ul><li>-version</li><li>-help</li><li>-showversion</li></ul><h2 id="X参数"><a href="#X参数" class="headerlink" title="X参数"></a>X参数</h2><ul><li>-Xint 解释执行</li><li>-Xcomp 第一次使用就编译成本地代码</li><li>-Xmixed 混合模式</li></ul><h2 id="XX参数"><a href="#XX参数" class="headerlink" title="XX参数"></a>XX参数</h2><h3 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h3><blockquote><p>-XX:+或者-某个参数 （表示开启和关闭）</p></blockquote><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-XX:+PrintGCDetails</td><td align="center">开启打印GC收集细节</td></tr><tr><td align="center">-XX:+UseSerialGC</td><td align="center">使用串行垃圾回收器</td></tr><tr><td align="center">-XX:+HeapDumpOnOutOfMemoryError</td><td align="center">设置当首次遭遇内存溢出时导出此时堆中相关信息</td></tr></tbody></table><h3 id="KV类型"><a href="#KV类型" class="headerlink" title="KV类型"></a>KV类型</h3><blockquote><p> -XX:key=value</p></blockquote><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-XX:InitialHeapSize= (等价于-Xms)</td><td align="center">初始堆内存大小</td></tr><tr><td align="center">-XX:MaxHeapSize= (等价于-Xmx)</td><td align="center">最大堆内存大小</td></tr><tr><td align="center">-XX:ThreadStackSize=(等价于-Xss)</td><td align="center">单个线程栈的大小（默认为512K~1024K）</td></tr><tr><td align="center">-XX:HeapDumpPath=</td><td align="center">指定导出堆信息时的路径或文件名</td></tr><tr><td align="center">-XX:MetaSpace=128M</td><td align="center">设置元空间内存大小</td></tr><tr><td align="center">-XX:MaxTenuringThreshold=15</td><td align="center">设置新生代进行老年代的存活次数</td></tr><tr><td align="center">-XX:SurvivorRatio</td><td align="center">设置eden区和survivor的比例。默认值为8，也就是8:1:1</td></tr><tr><td align="center">-XX:NewRatio</td><td align="center">设置新生代和老年代在堆中的占比,默认值为2。也就是Old:New=2:1</td></tr></tbody></table><h1 id="JVM-堆"><a href="#JVM-堆" class="headerlink" title="JVM 堆"></a>JVM 堆</h1><p><img src="https://s2.ax1x.com/2020/03/06/3LghuQ.png" alt="image"></p><h2 id="MinorGC过程"><a href="#MinorGC过程" class="headerlink" title="MinorGC过程"></a>MinorGC过程</h2><ol><li><p><strong>Eden区和From区上存活的对象复制到SurvivorTo区，存活对象年龄加1</strong></p><p>首先，当Eden区满的时候会触发第一次GC，把还活着的对象拷贝到SurvivorFrom区；当Eden区再次满的时候会扫描Eden区和SurvicorTo区，将存活的对象复制到To区，存活的对象年龄加1</p></li><li><p><strong>清除Eden区和SurvivorFrom的可回收对象</strong></p></li><li><p><strong>SurvivorFrom和SurvivorTo互相交换</strong></p></li></ol><h1 id="GC-日志"><a href="#GC-日志" class="headerlink" title="GC 日志"></a>GC 日志</h1><blockquote><p>可以使用-XX:+PrintGCDetails开启GC日志打印</p></blockquote><p><strong>GC日志图解</strong></p><p><img src="https://s2.ax1x.com/2020/03/06/3L0029.png" alt="image"></p><p><strong>Full GC图解</strong></p><p><img src="https://s2.ax1x.com/2020/03/06/3Lski8.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM位置&quot;&gt;&lt;a href=&quot;#JVM位置&quot; class=&quot;headerlink&quot; title=&quot;JVM位置&quot;&gt;&lt;/a&gt;JVM位置&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/28/3Dqzng.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="Java" scheme="http://liuyoubin.top/tags/Java/"/>
    
      <category term="JVM" scheme="http://liuyoubin.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Spring扩展2-Transaction</title>
    <link href="http://liuyoubin.top/2020/02/07/backEnd/framework/Spring%E6%89%A9%E5%B1%952-Transaction/"/>
    <id>http://liuyoubin.top/2020/02/07/backEnd/framework/Spring%E6%89%A9%E5%B1%952-Transaction/</id>
    <published>2020-02-07T08:43:18.000Z</published>
    <updated>2020-02-09T04:16:01.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务-Transaction"><a href="#事务-Transaction" class="headerlink" title="事务(Transaction)"></a>事务(Transaction)</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>​        事务是一系列操作的工作单元，是数据库操作的最小工作单元，这些操作要么同时成功，要么同时失败。</p><a id="more"></a><h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><p>​        <strong>事务的四大特性:ACID</strong></p><ul><li><p>原子性  (Atomicity) </p><p>​        原子性是指一个事务是一个不可分割的整体，其中的操作要么全部成功，要么全部失败。如果其中某个操作发生错误那么所有的操作要回滚，数据库返回到事务开始前状态。</p></li></ul><ul><li><p>一致性  (Consistency)</p><p>​        一致性是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行前后都是合法的数据状态。</p></li></ul><ul><li><p>隔离性  (isolation)</p><p>​        隔离性是指不同事务之间操作是隔离的，并发执行之间不能相互干扰影响。</p></li></ul><ul><li><p>持久性  (Durability)</p><p>​        持久性是指事务一旦提交，它对数据库的改变就是永久的，不会因为宕机或其他故障而影响。</p></li></ul><h1 id="Transactional"><a href="#Transactional" class="headerlink" title="Transactional"></a>Transactional</h1><p>​        Spring提供了基于AOP的声明式事务来帮我们管理事务。Spring声明式事务可以通过 配置XML进行配置，也可以采用注解式的声明式事务。</p><p>​        下面给出两种配置的示例:</p><h2 id="XML配置声明式事务"><a href="#XML配置声明式事务" class="headerlink" title="XML配置声明式事务"></a>XML配置声明式事务</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/s_01?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf-8<span class="symbol">&amp;amp;</span>useSSL=false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"lyb980328"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 配置事务的通知 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAd"</span> <span class="attr">transaction-manager</span>=<span class="string">"txManager"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置哪些方法使用什么样的事务，以及事务的传播特性 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get"</span>  <span class="attr">read-only</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"insert"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"delete"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--通过aop将事务通知切入方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.lyb.dao.Imp.*.*(..))"</span> <span class="attr">id</span>=<span class="string">"point"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAd"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="注解方式配置声明式事务"><a href="#注解方式配置声明式事务" class="headerlink" title="注解方式配置声明式事务"></a>注解方式配置声明式事务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">//开启声明式事务</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value = &#123;<span class="string">"com.lyb.service"</span>,<span class="string">"com.lyb.dao"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> PropertyVetoException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> PropertyVetoException </span>&#123;</span><br><span class="line">        ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">        dataSource.setUser(<span class="string">"root"</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">"lyb980328"</span>);</span><br><span class="line">        dataSource.setDriverClass(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        dataSource.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/s_02?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">jdbcTemplate</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册事务管理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">//声明这个方法的事务特性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userDao.insert();</span><br><span class="line">        <span class="comment">//模拟出错</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Transaction三大接口"><a href="#Transaction三大接口" class="headerlink" title="Transaction三大接口"></a>Transaction三大接口</h1><ul><li><p>PlatformTransactionManager</p><p>​        PlatformTransactionManager根据TransactionBefination提供的事务信息进行配置，是事务管理器的基类。Mybatis/JDBC使用DataSourceTransactionManager。一共三个方法：</p><ul><li>getTransaction（TransactionDefination），在当前环境中获取一个事务，如果没有则新建</li><li>commit  提交事务</li><li>rollback  回滚事务</li></ul></li><li><p>TransactionDefination：封装了事务隔离级别，超时时间等</p></li><li><p>TransactionStatus：封装了事务具体运行的状态</p></li></ul><h1 id="Transactional的配置项"><a href="#Transactional的配置项" class="headerlink" title="Transactional的配置项"></a>Transactional的配置项</h1><table><thead><tr><th align="center">配置项目</th><th align="center">含义</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">定义事务管理器</td><td align="center">这是Spring容器中的一个Bean，这个Bean需要实现PlatformTransactionManager</td></tr><tr><td align="center">transactionManager</td><td align="center">同上</td><td align="center">同上</td></tr><tr><td align="center">isolation</td><td align="center">隔离级别</td><td align="center">定义不同事务在并发执行时的隔离级别，默认隔离级别取决于所用数据库默认的隔离级别</td></tr><tr><td align="center">propagation</td><td align="center">传播行为</td><td align="center">事务传播行为，默认值为PROPAGATION.REQUIRED</td></tr><tr><td align="center">timeout</td><td align="center">超时时间</td><td align="center">单位为秒，当超时时，会引发异常，默认回滚</td></tr><tr><td align="center">readOnly</td><td align="center">是否只读</td><td align="center">默认为false</td></tr><tr><td align="center">rollbackFor</td><td align="center">回滚事务异常类定义</td><td align="center">定义当前事务发生该异常时才发生回滚，否则提交事务</td></tr><tr><td align="center">rollbackForClassName</td><td align="center">回滚事务的异常类名定义</td><td align="center">同上，只是用类名定义</td></tr><tr><td align="center">noRollbackFor</td><td align="center">产生哪些异常不回滚事务</td><td align="center">产生该异常时，事务继续执行</td></tr><tr><td align="center">noRollbackForClassName</td><td align="center">产生哪些异常不回滚事务</td><td align="center">同上，只是用类名定义</td></tr></tbody></table><h1 id="Transactional事务生效条件"><a href="#Transactional事务生效条件" class="headerlink" title="Transactional事务生效条件"></a>Transactional事务生效条件</h1><ul><li>@Transaction只对<strong>public</strong>修饰的方法起效，如果将@Transaction注解在<strong>protected、private</strong>上，编译可以通过但是事务不起作用。</li></ul><hr><ul><li>在默认条件下，事务只对运行时异常(RuntimeException)起作用，对于检查异常(check exception)不起作用。</li></ul><p>  首先我们来看一幅图：</p><p>  <img src="https://s2.ax1x.com/2020/02/08/1WZ2Nt.png" alt="image"></p><p>  ​        我们知道在java中RuntimeException及其子类都是运行时异常，对于运行时异常我们可以不用try catch捕获，也不用throws进行声明。而其他异常一般都是检查异常，对于检查异常我们要不然就进行try catch，要不然就要通过throws进行声明。</p><p>  ​        <strong>而在Spring事务中，在默认情况下只有发生运行时异常，事务才会发生回滚。</strong></p><p>  ​        <strong>并且不管是运行时异常和检查时异常只有在抛出的时候才是触发时机，也就是说在默认情况下如果你用try catch捕获运行时异常，事务也同样不会回滚。</strong></p><p>  ​        下面看几个例子：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 发生算术异常（运行时异常），所以事务会回滚</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">       studentMapper.updateStudent(student);</span><br><span class="line">       <span class="keyword">int</span> i =  <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 虽然发生了算术异常（运行时异常），但是异常被捕获没有继续抛出，所以事务不会回滚</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      studentMapper.updateStudent(student);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="keyword">int</span> i =  <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span>(RuntimeException)&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 由于抛出的是检查时异常，所以事务不会回滚</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(Student student)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       studentMapper.updateStudent(student);</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"异常"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>  ​            </p><p>  ​        如果想让发生检查时异常也发生回滚可以通过rollbackFor/rollbackForClassName属性指定，同理也可以用noRollbackFor/noRollbackForClassName来指定发生运行时异常不回滚。注意这里的“发生异常”指的是抛出异常，被try catch的异常不会触发回滚。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">* rollbackFor指定了Exception异常，所以事务会回滚</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">   @<span class="title">Override</span></span></span><br><span class="line"><span class="class">   <span class="title">public</span> <span class="title">void</span> <span class="title">updateStudent</span>(<span class="title">Student</span> <span class="title">student</span>) <span class="title">throws</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">       studentMapper.updateStudent(student);</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"异常"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 虽然rollbackFor指定了Exception异常，但是Exception异常被捕获，所以事务不会回滚</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">   @<span class="title">Override</span></span></span><br><span class="line"><span class="class">   <span class="title">public</span> <span class="title">void</span> <span class="title">updateStudent</span>(<span class="title">Student</span> <span class="title">student</span>) </span>&#123;</span><br><span class="line">       studentMapper.updateStudent(student);</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"异常"</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="isolation事务隔离级别"><a href="#isolation事务隔离级别" class="headerlink" title="isolation事务隔离级别"></a>isolation事务隔离级别</h1><p>​        <strong>所谓隔离级别就是指不同事务在并发执行的时候，互相的影响程度。我么在进行事务操作的过程中有可能引发以下三种情况。</strong></p><ul><li><p>脏读</p><p>​        所谓脏读就是读取未提交数据。比如：A事务修改了某一条数据但是还没提交，B事务读取了A事务修改后的数据，此时如果A事务发生了回滚，那么就发生了脏读。</p></li><li><p>不可重复读</p><p>​        不可重复读，通俗的讲就是一个事务多次读取同一数据，结果却不一样。比如：A事务先读取了一条数据的值为0，B事务在A事务读取后，将这条数据的值改成1然后提交，A事务再次读取这条数据发现和这前不一样了，这就是不可重复的。</p></li><li><p>幻读</p><p>​        幻读就是同一个事务中进行多次同一查询，但由于其他事务的增加数据的行为，每次查询返回的结果级都不一样。</p></li></ul><p>​      <strong>Spring针对上面三种情况，提供了5种隔离级别来解决。</strong></p><ul><li><p>DEFAULT  默认级别</p><p>​        这个级别取决于所用数据库的默认隔离级别，MySQL默认隔离级别REPEATABLE_READ</p></li></ul><ul><li><p>READ_UNCOMMITED 未提交读级别</p><p>​        在这个级别，事务可以读到别的事务未提交的数据，可能出现脏读、不可重复读、幻读</p></li></ul><ul><li><p>READ_COMMITED  已提交读级别</p><p>​        在这个级别，一个事务只能读取其他事务已提交的修改。在这个隔离级别解决了脏读，但依然存在不可重复读和幻读。因为其他事务可能会有多次commit。</p></li></ul><ul><li><p>REPEATABLE_READ  可重复读取级别</p><p>​            在这个级别，一个事务多次执行查询同一数据将返回同一结果，不受其他事务的影响(只针对修改操作)。在这个隔离级别解决了脏读、不可重复读 ，但依然存在幻读。因为此时其他事务可以插入数据。</p></li></ul><ul><li><p>SERIALIZABLE  序列化级别</p><p>​            在这个级别，所有事务将逐个执行，这样事务之间就完全隔离。在这个隔离级别解决了脏读、不可重复读和幻读。</p></li></ul><h1 id="Propagation事务传播行为"><a href="#Propagation事务传播行为" class="headerlink" title="Propagation事务传播行为"></a>Propagation事务传播行为</h1><p>​        <strong>事务传播行为也就是多个事务方法相互调用时，事务如何在方法中传播。Spring定义了七种事务传播行为。</strong></p><ul><li><p>REQUIRED (默认)</p><p>​        如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务</p><p>​        通俗的讲：</p><p>​                A方法调用B方法</p><p>​                B方法的事务传播行为如果是REQUIRED，那么如果A方法存在事务那么B方法就加入A事务，如果A方法不存在事务，那B方法就自己创建事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">*  测试发现只要有一个方法出现异常，两个方法就都进行回滚，证明两个方法在同一个事务中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">(Student student1, Student student2)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//新增Student1</span></span><br><span class="line">       studentMapper.insertStudent(student1);</span><br><span class="line">  </span><br><span class="line">       <span class="comment">//调用事务方法修改student2</span></span><br><span class="line">       updateStudent(student2);</span><br><span class="line">  </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Transactional</span>(propadation=Propagation.REQUIRED)</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">       studentMapper.updateStudent(student);</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>SUPPORTS</p><p>​    自身不会开启事务，在事务范围内则使用相同事务，否则不使用事务。</p><p>​    通俗的讲：</p><p>​                A方法调用B方法</p><p>​                B方法的事务传播行为如果是SUPPORTS，那么如果A方法存在事务那么B方法就加入A事务，如果A方法不存在事务，那B方法就不使用事务</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">*  就像下面这个例子，由于A方法没有事务(因为A方法的调用者没有事务)，所以B方法也就不用事务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(propadation=Propagation.SUPPORTS)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">(Student student1, Student student2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新增Student1</span></span><br><span class="line">    studentMapper.insertStudent(student1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用事务方法修改student2</span></span><br><span class="line">    updateStudent(student2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(propadation=Propagation.SUPPORTS)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">    studentMapper.updateStudent(student);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>MANDATORY</p><p>​    支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p><p>​    通俗的讲：</p><p>​                A方法调用B方法</p><p>​                B方法的事务传播行为如果是MANDATORY，那么如果A方法存在事务那么B方法就加入A事务，如果A方法不存在事务，那B方法就抛出异常</p></li></ul><ul><li><p>REQUIRES_NEW</p><p>​    创建新事务，无论当前存不存在事务，都创建新事务</p><p>​    通俗的讲：</p><p>​                A方法调用B方法</p><p>​                B方法的事务传播行为如果是REQUIRES_NEW，那么如果A方法无论存不存在事务，B方法都会自己开启一个新事务。</p></li></ul><ul><li><p>NOT_SUPPORTED</p><p>​    以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</p><p>​    通俗的讲：</p><p>​                A方法调用B方法</p><p>​                B方法的事务传播行为如果是NOT_SUPPORTED，那么如果A方法存在事务，运行到B方法的时候A事务挂起，B方法会以非事务运行，B运行完毕后A事务才继续执行。</p></li></ul><ul><li><p>NEVER</p><p>​    以非事务方式执行，如果当前存在事务，则抛出异常</p><p>​    通俗的讲：</p><p>​                A方法调用B方法</p><p>​                B方法的事务传播行为如果是NEVER，那么如果A方法存在事务，那么B方法就会抛异常</p></li></ul><ul><li><p>NESTED</p><p>​        如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作</p><p>​        和REQUIRES_NEW相似，不同的是REQUIRES_NEW中的两个事务是独立的。而NESTED的事务要依赖于父事务，如果父事务回滚，那么自己事务也会回滚。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;事务-Transaction&quot;&gt;&lt;a href=&quot;#事务-Transaction&quot; class=&quot;headerlink&quot; title=&quot;事务(Transaction)&quot;&gt;&lt;/a&gt;事务(Transaction)&lt;/h1&gt;&lt;h2 id=&quot;什么是事务&quot;&gt;&lt;a href=&quot;#什么是事务&quot; class=&quot;headerlink&quot; title=&quot;什么是事务&quot;&gt;&lt;/a&gt;什么是事务&lt;/h2&gt;&lt;p&gt;​        事务是一系列操作的工作单元，是数据库操作的最小工作单元，这些操作要么同时成功，要么同时失败。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Spring" scheme="http://liuyoubin.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Linux Shell编程基础</title>
    <link href="http://liuyoubin.top/2020/02/02/backEnd/Linux-Shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://liuyoubin.top/2020/02/02/backEnd/Linux-Shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2020-02-02T15:21:24.000Z</published>
    <updated>2020-02-26T07:30:32.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell是什么"><a href="#Shell是什么" class="headerlink" title="Shell是什么"></a>Shell是什么</h1><p>​        shell是一个命令行解释器，它为用户提供了一个向内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。</p><p><img src="https://s2.ax1x.com/2020/02/03/1NYgiQ.png" alt="image"></p><a id="more"></a><h1 id="Shell快速入门"><a href="#Shell快速入门" class="headerlink" title="Shell快速入门"></a>Shell快速入门</h1><h2 id="Shell脚本的执行方式"><a href="#Shell脚本的执行方式" class="headerlink" title="Shell脚本的执行方式"></a>Shell脚本的执行方式</h2><p><strong>脚本格式要求</strong></p><ol><li><p>脚本以<code>#!/bin/bash</code>开头</p></li><li><p>脚本需要有可执行权限</p></li></ol><p><strong>编写第一个Shell脚本</strong></p><p>​        要求：编写一个脚本输出hello world!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim helloworld.sh</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello  world!"</span></span><br></pre></td></tr></table></figure><ul><li><p>执行方式1(输入脚本的绝对路径或者相对路径)</p><ul><li><p>首先要赋予脚本+x权限</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">744</span> helloworld.sh</span><br></pre></td></tr></table></figure></li><li><p>执行脚本</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">相对路径  ./helloworld.<span class="keyword">sh</span></span><br><span class="line">绝对路径  /root/<span class="keyword">shell</span>/helloworld.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>执行方式2(sh+脚本)</p><ul><li><p>不用赋予脚本+x权限，直接执行</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sh</span> helloworld.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h2><p><strong>Shell变量</strong></p><ol><li><p>Linux shell变量有 <strong>系统变量</strong>和<strong>用户自定义变量</strong></p></li><li><p>系统变量例如： $HOME、$PWD、$SHELL、￥USER</p></li><li><p>输入系统中所有系统变量: set</p></li></ol><p><strong>定义变量的规则</strong></p><ol><li>变量名称可以由字母、数组、下划线组成，但不能由下划线开头</li><li>等号两边不能有空格</li><li>变量名称一般大写</li></ol><p><strong>Shell变量的定义</strong></p><ol><li>定义变量: 变量=值</li><li>撤销变量：unset 变量</li><li>声明静态变量: readonly  变量, 注意不能unset </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">A=100</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"A=<span class="variable">$A</span>"</span></span><br><span class="line"><span class="built_in">unset</span> A</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"A=<span class="variable">$A</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">readonly</span> B=200</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"B=<span class="variable">$B</span>"</span></span><br><span class="line"><span class="built_in">unset</span> B</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">A=100</span><br><span class="line">A=</span><br><span class="line">B=200</span><br><span class="line">./helloworld.sh: line 11: <span class="built_in">unset</span>: B: cannot <span class="built_in">unset</span>: <span class="built_in">readonly</span> variable</span><br></pre></td></tr></table></figure><p><strong>将命令返回值赋给变量</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. <span class="attribute">A</span>=`ls -la`</span><br><span class="line">2. <span class="attribute">A</span>=$(ls -la)</span><br></pre></td></tr></table></figure><p><strong>设置环境变量</strong></p><ul><li>Shell可以通过export设置全局环境变量</li><li>通过source /etc/profile刷新配置</li><li>其他Shell脚本可以访问到这个环境变量</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在Shell脚本中 定义一个环境变量</span></span><br><span class="line"><span class="attribute">TOMCAT_HOME</span>=/usr/local/tomcat/bin</span><br><span class="line"><span class="builtin-name">export</span> TOMCAT_HOME</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"><span class="comment">#刷新配置</span></span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"><span class="comment">#其他Shell进行使用</span></span><br><span class="line">echo <span class="variable">$TOMCAT_HOME</span></span><br></pre></td></tr></table></figure><p><strong>位置参数变量</strong></p><p>​        当我们执行一个shell脚本时，如果希望获取命令行的参数信息，就可以使用到位置参数变量，比如： ./helloworld.sh 100 200 可以在脚本中获得到参数信息。</p><p>​        <strong>基本语法：</strong></p><ul><li><p>$n  (n为数字，$0代表命令本身，$1-9代表一到九参数，10以上的参数需要大括号包裹比如${12})</p></li><li><p>$*  (代表命令行中所有参数，把所有参数看做一个整体)</p></li><li><p>$@  (代表命令行中所有参数，但是$@把每个参数区别对待)</p></li><li><p>$#  (代表命令行中所有参数的个数)</p><p>​    <strong>示例：</strong></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取到各个参数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$0</span> <span class="variable">$1</span> <span class="variable">$2</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"$*"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"参数个数=<span class="variable">$#</span>"</span></span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">./positionPara 100 200</span><br><span class="line"> </span><br><span class="line">----</span><br><span class="line">./positionPara.sh 100 200</span><br><span class="line">100 200</span><br><span class="line">100 200</span><br><span class="line">参数个数=2</span><br></pre></td></tr></table></figure><p><strong>预定义变量</strong></p><ul><li><p>$$  (当前进程的进程号（PID）)</p></li><li><p>$!   (后台运行的最后一个进程的进程号(PID))</p></li><li><p>$？ (最后一个执行的命令的返回状态，如果这个变量为0则代表执行成功，否则执行失败)</p><p>​    <strong>示例：</strong></p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="string">echo</span> <span class="string">"当前进程号=$$"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#后台的方式运行helloworld.sh</span></span><br><span class="line"><span class="string">./helloworld.sh</span> <span class="string">&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="string">echo</span> <span class="string">"最后的进程号=$!"</span></span><br><span class="line"></span><br><span class="line"><span class="string">echo</span> <span class="string">"执行的值=$?"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">./preVAl.sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">当前进程号=30981</span></span><br><span class="line"><span class="string">最后的进程号=30982</span></span><br><span class="line"><span class="string">执行的值=0</span></span><br><span class="line"><span class="string">[root@izm5e4zm50doq1ptls492gz</span> <span class="string">shell]#</span> <span class="string">hello</span>  <span class="string">world!</span></span><br></pre></td></tr></table></figure><h2 id="Shell运算符"><a href="#Shell运算符" class="headerlink" title="Shell运算符"></a>Shell运算符</h2><p><strong>基本语法</strong></p><ul><li><p>“$((运算符))” 或 “$[运算符]”</p></li><li><p>expr m + n  //注意运算符之间要有空格</p></li><li><p>expr m - n</p></li><li><p>expr \*   //乘</p></li><li><p>expr /</p></li><li><p>%</p></li></ul><p>​    <strong>示例：</strong></p><p>​                <strong>案例1：</strong>计算 (2+3)* 8的值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第一种方式 $(())</span></span><br><span class="line"><span class="string">RESULT1=$(((2+3)*8))</span></span><br><span class="line"><span class="string">echo</span> <span class="string">"RESULT1=$RESULT1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第二种方式 $[] (推荐)</span></span><br><span class="line"><span class="string">RESULT2=$[(2+3)*8]</span></span><br><span class="line"><span class="string">echo</span> <span class="string">"RESULT2=$RESULT2"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第三种方式 expr</span></span><br><span class="line"><span class="string">TEMP=`expr</span> <span class="number">2</span> <span class="string">+</span> <span class="number">3</span><span class="string">`</span></span><br><span class="line"><span class="string">RESULT3=`expr</span> <span class="string">$TEMP</span> <span class="string">\*</span> <span class="number">8</span><span class="string">`</span></span><br><span class="line"><span class="string">echo</span> <span class="string">"RESULT3=$RESULT3"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">./demo.sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">RESULT1=40</span></span><br><span class="line"><span class="string">RESULT2=40</span></span><br><span class="line"><span class="string">RESULT3=40</span></span><br></pre></td></tr></table></figure><p>​                <strong>案例2：</strong>求出两个参数的和</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="string">RESULT=$[$1+$2]</span></span><br><span class="line"><span class="string">echo</span> <span class="string">"RESULT=$RESULT"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">./add.sh</span> <span class="number">100</span> <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">RESULT=300</span></span><br></pre></td></tr></table></figure><h2 id="Shell流程控制"><a href="#Shell流程控制" class="headerlink" title="Shell流程控制"></a>Shell流程控制</h2><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p><strong>基本语法</strong></p><ul><li><p>[ condition ] （condition前后要有空格）</p></li><li><p>[ condition ] &amp;&amp; echo OK || echo NO  （条件满足执行语句）</p></li></ul><p><strong>常用判断条件</strong></p><ul><li><p>两个整数的比较</p><ul><li>=  字符串比较</li><li>-lt    小于</li><li>-le   小于等于</li><li>-eq  等于</li><li>-gt   大于</li><li>-ge  大于等于</li><li>-ne  不等于</li></ul></li><li><p>按照文件权限进行判断</p><ul><li>-r   有读的权限</li><li>-w  有写的权限</li><li>-x   有执行的权限</li></ul></li><li><p>按照文件类型进行判断</p><ul><li>-f    文件存在且是一个常规文件</li><li>-e   文件存在</li><li>-d   文件存在且是一个目录</li></ul></li></ul><p><strong>示例</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断 “OK”是否等于“OK”</span></span><br><span class="line"></span><br><span class="line"><span class="string">if</span> <span class="string">[</span> <span class="string">"OK"</span> <span class="string">=</span> <span class="string">"OK"</span> <span class="string">]</span></span><br><span class="line"><span class="string">then</span> </span><br><span class="line">  <span class="string">echo</span> <span class="string">"equal"</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断 23是否大于22</span></span><br><span class="line"><span class="string">if</span> <span class="string">[</span> <span class="number">23</span> <span class="string">-gt</span> <span class="number">22</span> <span class="string">]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line">  <span class="string">echo</span> <span class="string">"大于"</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断/root/shell/helloworld.sh目录中的文件是否存在</span></span><br><span class="line"><span class="string">if</span> <span class="string">[</span> <span class="string">-e</span> <span class="string">/root/shell/helloworld.sh</span> <span class="string">]</span></span><br><span class="line"><span class="string">then</span> </span><br><span class="line">  <span class="string">echo</span> <span class="string">"存在"</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">./condition.sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">equal</span></span><br><span class="line"><span class="string">大于</span></span><br><span class="line"><span class="string">存在</span></span><br></pre></td></tr></table></figure><h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><p><strong>基本语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">程序</span><br><span class="line"><span class="keyword">elif</span> [ condition ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"> 程序</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$1</span> -ge 60 ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"及格"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$1</span> -lt 60 ]</span><br><span class="line">  <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"不及格"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="case语法"><a href="#case语法" class="headerlink" title="case语法"></a>case语法</h3><p><strong>基本语法</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line"><span class="string">"值1"</span>)</span><br><span class="line">程序<span class="number">1</span></span><br><span class="line">;;</span><br><span class="line"><span class="string">"值2"</span>)</span><br><span class="line">程序<span class="number">2</span></span><br><span class="line">;;</span><br><span class="line">....</span><br><span class="line">*)</span><br><span class="line"><span class="section">default</span>程序</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line"><span class="string">"1"</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"星期一"</span></span><br><span class="line">;;</span><br><span class="line"><span class="string">"2"</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"星期二"</span></span><br><span class="line">;;</span><br><span class="line"><span class="string">"3"</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"星期三"</span></span><br><span class="line">;;</span><br><span class="line"><span class="string">"4"</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"星期四"</span></span><br><span class="line">;;</span><br><span class="line"><span class="string">"5"</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"星期五"</span></span><br><span class="line">;;</span><br><span class="line"><span class="string">"6"</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"星期六"</span></span><br><span class="line">;;</span><br><span class="line"><span class="string">"7"</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"星期天"</span></span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"出错"</span></span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><strong>基本语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">语法一:</span><br><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 值1 值2 值3...</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"> 程序</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">语法二:</span><br><span class="line"><span class="keyword">for</span>((初始值;循环控制块;变量变化))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"> 程序</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><p>​    <strong>示例一：</strong>打印命令行参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"$*"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"the num is <span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">./fordemo1.sh 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">the num is 1 2 3 4 5</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"the num is <span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">./fordemo2.sh 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">the num is 1</span><br><span class="line">the num is 2</span><br><span class="line">the num is 3</span><br><span class="line">the num is 4</span><br><span class="line">the num is 5</span><br></pre></td></tr></table></figure><p><strong>示例二：</strong>打印从1加到100的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">SUM=0</span><br><span class="line"><span class="keyword">for</span>((i=1;i&lt;=100;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"> SUM=$[<span class="variable">$SUM</span>+<span class="variable">$i</span>]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"SUM=<span class="variable">$SUM</span>"</span></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">./fordemo3.sh</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">SUM=5050</span><br></pre></td></tr></table></figure><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p><strong>基本语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">程序</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><p>​        <strong>示例一：</strong>从命令行输入n,统计从1+…+n的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">SUM=0</span><br><span class="line">i=0</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -le <span class="variable">$1</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"> SUM=$[<span class="variable">$SUM</span>+<span class="variable">$i</span>]</span><br><span class="line"> i=$[<span class="variable">$i</span>+1]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"SUM=<span class="variable">$SUM</span>"</span></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">./while.sh 100</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">SUM=5050</span><br></pre></td></tr></table></figure><h2 id="Shell读取控制台输入"><a href="#Shell读取控制台输入" class="headerlink" title="Shell读取控制台输入"></a>Shell读取控制台输入</h2><p><strong>基本语法</strong></p><p>read (选项) (参数)</p><p>选项：</p><ul><li>-p 指定读取值时的提示符</li><li>-t   指定读取值时等待的时间(秒)</li></ul><p>参数：指定读取值的变量名</p><p><strong>示例：</strong>读取控制台一个num值，10秒后输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"请输入一个数num="</span> -t 10  NUM</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"你输入的值是=<span class="variable">$NUM</span>"</span></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">./read.sh</span><br><span class="line">请输入一个数num=18</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">你输入的值是=18</span><br></pre></td></tr></table></figure><h2 id="Shell中的函数"><a href="#Shell中的函数" class="headerlink" title="Shell中的函数"></a>Shell中的函数</h2><p><strong>函数介绍</strong></p><p>​        Shell编程有系统函数和自定义函数两种</p><p><strong>系统函数</strong></p><ul><li><p><strong>basename函数</strong></p><ul><li>功能 : 返回完整路径最后/的部分，常用于获取文件</li><li>basename [pathname] [suffix]<ul><li>suffix为后缀，如果suffix被指定，basename会将pathname中的suffix去掉</li></ul></li></ul></li><li><p><strong>dirname函数</strong></p><ul><li>功能 : 返回完整路径最后 / 前面的部分，常用于返回路径部分</li><li>dirname [pathname] </li></ul></li></ul><p><strong>自定义函数</strong></p><p>​        <strong>基本语法</strong></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="function"><span class="keyword">function</span></span>] funname[()]</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">Action</span>;</span><br><span class="line">[<span class="keyword">return</span> <span class="built_in">int</span>;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用直接写函数名: funname [值]</span><br></pre></td></tr></table></figure><p>​            <strong>示例：</strong>计算输入两个参数的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getSun</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">SUM=$[<span class="variable">$n1</span>+<span class="variable">$n2</span>]</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"和是=<span class="variable">$SUM</span>"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"请输入第一个数n1:"</span> n1</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"请输入第二个数n2:"</span> n2</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">getSun <span class="variable">$n1</span> <span class="variable">$n2</span></span><br></pre></td></tr></table></figure><h1 id="Shell编程综合案例"><a href="#Shell编程综合案例" class="headerlink" title="Shell编程综合案例"></a>Shell编程综合案例</h1><p><strong>需求分析</strong></p><ul><li>每天凌晨2:10备份数据库db01到/data/backup/db</li><li>备份开始和备份结束都能给出相应的提示信息</li><li>备份后的文件要求以备份时间为文件名，并打包成.tar.gz的形式，比如: 2020-02-02_020103.tar.gz</li><li>在备份的同时检查是否有10天前备份的数据库文件，如果有就将其删除</li></ul><p><strong>代码实现</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">设置备份的路径</span></span><br><span class="line">BACKUP=/data/backup/db</span><br><span class="line"><span class="meta">#</span><span class="bash">获取当前的时间作为文件名</span></span><br><span class="line">DATETIME=$(date +%Y-%m-%d_%H%M%S)</span><br><span class="line"></span><br><span class="line">echo "============================开始备份================================"</span><br><span class="line">echo "===============备份的路径是 $BACKUP/$DATETIME.tar.gz==============="</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">主机</span></span><br><span class="line">HOST=localhost</span><br><span class="line"><span class="meta">#</span><span class="bash">用户名</span></span><br><span class="line">DB_USER=root</span><br><span class="line"><span class="meta">#</span><span class="bash">密码</span></span><br><span class="line">DB_PASS=lyb980328</span><br><span class="line"><span class="meta">#</span><span class="bash">备份数据库名</span></span><br><span class="line">DATABASE=db01</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">创建备份的路径,不存在就创建</span></span><br><span class="line">[ ! -d "$BACKUP" ] &amp;&amp; mkdir -p "$BACKUP"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">执行mysql备份指令</span></span><br><span class="line">mysqldump -u$&#123;DB_USER&#125; -p$&#123;DB_PASS&#125; --host=$HOST $DATABASE | gzip &gt; $BACKUP/$DATETIME.sql.gz</span><br><span class="line"><span class="meta">#</span><span class="bash">打包备份文件</span></span><br><span class="line">cd $BACKUP</span><br><span class="line">tar -zcvf $DATETIME.tar.gz $DATETIME.sql.gz</span><br><span class="line"><span class="meta">#</span><span class="bash">删除临时文件</span></span><br><span class="line">rm -rf $DATETIME.sql.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除十天前的备份文件</span></span><br><span class="line">find $BACKUP -mtime +10 -name "*.tar.gz" -exec rm -f &#123;&#125; \;</span><br><span class="line"></span><br><span class="line">echo "===================备份成功======================="    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">crontab -e</span><br><span class="line"></span><br><span class="line">10 2 * * * ./root/shell/mysql_backup.db.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Shell是什么&quot;&gt;&lt;a href=&quot;#Shell是什么&quot; class=&quot;headerlink&quot; title=&quot;Shell是什么&quot;&gt;&lt;/a&gt;Shell是什么&lt;/h1&gt;&lt;p&gt;​        shell是一个命令行解释器，它为用户提供了一个向内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/03/1NYgiQ.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Linux" scheme="http://liuyoubin.top/tags/Linux/"/>
    
      <category term="Shell" scheme="http://liuyoubin.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习笔记</title>
    <link href="http://liuyoubin.top/2020/01/31/backEnd/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://liuyoubin.top/2020/01/31/backEnd/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-01-31T03:01:40.000Z</published>
    <updated>2020-02-25T17:18:29.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker为什么会出现"><a href="#Docker为什么会出现" class="headerlink" title="Docker为什么会出现"></a>Docker为什么会出现</h1><p>​    以前在服务器上部署一个应用，除了应用本身还要安装各种相应的软件、依赖，进行各种相应的配置。这种方式不仅费时费力还不能跨平台，不利于应用的集群部署。</p><p>​        Docker的出现提供了一个解决方案，打破了<code>程序及应用</code>的传统观念。<code>通过镜像（images）将作业系统核心除外，运作应用所需的系统环境，由下而上进行打包，达到应用程序跨平台无缝部署运行。</code></p><a id="more"></a><h1 id="Docker三要素"><a href="#Docker三要素" class="headerlink" title="Docker三要素"></a>Docker三要素</h1><ul><li><p>镜像</p><p>​        Docker镜像(Image)就是一个<code>只读</code>的模板，一个镜像可以用来创建多个Docker容器。</p></li><li><p>容器</p><p>​        Docker容器(Container)是用镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做一个简易版的Linux环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p></li><li><p>仓库</p><p>​        仓库（Repository）是<code>集中存放镜像文件</code>的场所。</p><p>​        仓库和仓库注册服务器（Registry）是有区别的，仓库注册服务器上可以存放着多个仓库，每个仓库又包含了多个镜像，每个镜像有不同的标签(tag)。</p></li></ul><h1 id="Docker的安装与启动"><a href="#Docker的安装与启动" class="headerlink" title="Docker的安装与启动"></a>Docker的安装与启动</h1><p>​        docker可以安装在windows上也可以安装在Linux上，我们学习开发的肯定是学习Linux版本的安装。</p><p>​        这里Linux的版本是<code>CentOS 7.7</code></p><p><strong>步骤：</strong></p><ol><li><p>安装所需的软件包</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">yum</span> <span class="string">install -y yum-utils \</span></span><br><span class="line">  <span class="meta">device-mapper-persistent-data</span> <span class="string">\</span></span><br><span class="line"> <span class="attr">lvm2</span></span><br></pre></td></tr></table></figure></li><li><p>设置存储库</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager \</span><br><span class="line">    --<span class="built_in">add</span>-repo \</span><br><span class="line">    http<span class="variable">s:</span>//download.docker.<span class="keyword">com</span>/linux/centos/docker-<span class="keyword">ce</span>.repo</span><br></pre></td></tr></table></figure></li><li><p>安装docker社区版</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-<span class="keyword">ce</span> docker-<span class="keyword">ce</span>-cli containerd.io</span><br></pre></td></tr></table></figure><p>具体内容参考官网的说明:<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/</a></p></li><li><p>启动docker</p> <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> docker</span><br></pre></td></tr></table></figure></li><li><p>阿里云镜像加速配置</p><p>​        由于docker hub网站在国外，镜像拉取的速度很慢。所以要配置阿里云镜像加速    </p><p>​        首先登陆阿里云平台，获取加速地址(<strong>容器镜像服务&gt;镜像加速器)</strong>)</p><p>​        按照说明新建或修改 /etc/docker/daemon.json 文件，添加以下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [<span class="string">"https://tw8jn1y0.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        systemctl daemon-reload </p><p>​        systemctl restart docker</p></li></ol><h1 id="Docker底层原理"><a href="#Docker底层原理" class="headerlink" title="Docker底层原理"></a>Docker底层原理</h1><p><strong>Docker的运行原理</strong></p><p>​        Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。</p><p><img src="https://s2.ax1x.com/2020/01/31/13cruR.png" alt="image"></p><p><strong>为什么Docker比MV快</strong></p><ul><li>docker不需要Hypervisor实现硬件资源虚拟化，运行在docker容器上的程序直接使用宿主机的硬件资源，因此在硬件利用率上比MV高。</li><li>docker利用宿主机的内核，而不需要Guest OS。因此docker在新建一个容器是不需要加载操作系统，而是直接利用宿主机的操作系统，速度比需要加载Guest OS的MV更快。</li></ul><h1 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><ul><li><p>查看docker版本</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">version</span></span><br></pre></td></tr></table></figure></li><li><p>查看docker具体信息</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> <span class="literal">info</span></span><br></pre></td></tr></table></figure></li><li><p>查看docker帮助命令</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="comment">--help</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><ul><li><p>列出本地的镜像</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> images<span class="meta"> [OPTIONS]</span></span><br></pre></td></tr></table></figure><p>OPTIONS说明:</p><ul><li>-a  列出本地所有镜像(含中间映像层)</li><li>-q   只显示镜像ID</li><li>–digests  显示镜像的摘要信息</li><li>–no-trunc  显示完整的镜像信息</li></ul><p>例子:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          <span class="keyword">TAG</span>                 <span class="title">IMAGE</span> ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              fce289e99eb9        <span class="number">13</span> months ago       <span class="number">1.84</span>kB</span><br></pre></td></tr></table></figure><p>各表项说明：</p><table><thead><tr><th align="center">REPOSITORY</th><th align="center">TAG</th><th align="center">IMAGE ID</th><th align="center">CREATED</th><th align="center">SIZE</th></tr></thead><tbody><tr><td align="center">表示镜像的仓库源</td><td align="center">镜像的标签</td><td align="center">镜像ID</td><td align="center">镜像创建的时间</td><td align="center">镜像的大小</td></tr></tbody></table><p>​        同一个仓库源可以有多个TAG，代表这个仓库源的不同版本。我们使用REPOSITORY:TAG来指定版本，如果不指定默认latest版本。</p></li></ul><hr><ul><li><p>查看docker hub上的某个镜像</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">search</span> [<span class="keyword">OPTIONS</span>] 镜像名字</span><br></pre></td></tr></table></figure><p>OPTIONS说明:</p><ul><li>–no-trunc 查看完整的镜像信息</li><li>-s 列出收藏数不小于指定值的镜像</li><li>–automated 只列出automated build类型的镜像</li></ul></li></ul><hr><ul><li><p>下载镜像</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名字[:<span class="keyword">tag</span>]</span><br></pre></td></tr></table></figure></li><li><p>删除镜像</p><ul><li><p>删除单个镜像</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> rmi -f 镜像ID/唯一镜像名</span><br></pre></td></tr></table></figure><ul><li>-f 强制删除</li></ul></li><li><p>删除多个镜像</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f 镜像ID<span class="regexp">/唯一镜像名 镜像ID/</span>唯一镜像名 镜像ID<span class="regexp">/唯一镜像名...</span></span><br></pre></td></tr></table></figure></li><li><p>删除所有镜像</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f <span class="constructor">$(<span class="params">docker</span> <span class="params">images</span> -<span class="params">qa</span>)</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><ul><li><p>新建并启动容器</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="comment">[OPTIONS]</span> 镜像ID/唯一镜像名 <span class="comment">[COMMAND]</span> <span class="comment">[ARG...]</span></span><br></pre></td></tr></table></figure><p> [OPTIONS]说明：</p><ul><li><p>–name=”容器新名字”：为容器指定一个名称</p></li><li><p>-d : 后台运行容器，并返回容器ID，也即启动守护式容器</p></li><li><p>-i : 以交互模式运行容器，通常与-t同时运行</p></li><li><p>-t : 为容器重新分配一个伪输入终端，通常与-i同时使用</p></li><li><p>-P : 随机端口映射</p></li><li><p>-p: 指定端口映射，有以下四种形式</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ip:</span> <span class="string">hostPort:</span>containerPort</span><br><span class="line"><span class="string">ip:</span>:containerPort</span><br><span class="line"><span class="string">hostPort:</span>containerPort</span><br><span class="line">containerPort</span><br></pre></td></tr></table></figure></li></ul><p><strong>扩展：</strong></p><p>​        当我们以<code>docker run -d  容器Id</code>启动一个后台守护进程后，如果docker没有前台进程，那么这个后台进程会立即自杀。</p></li></ul><hr><ul><li><p>查看当前正在运行的容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> ps<span class="meta"> [OPTIONS]</span></span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li>-a ： 列出当前所有正在运行的容器+历史上运行过的容器</li><li>-l ：显示最近创建的容器</li><li>-n : 显示最近创建的n个容器</li><li>-q : 静默模式，只显示容器编号</li><li>–no-trunc ：不截断输出</li></ul></li><li><p>退出容器</p><ul><li><p>容器停止退出</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure></li><li><p>容器不停止退出</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+<span class="keyword">P</span>+Q</span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动容器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">start</span> 容器<span class="keyword">ID</span>/容器名</span><br></pre></td></tr></table></figure></li><li><p>重启容器</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">restart</span> 容器ID/容器名</span><br></pre></td></tr></table></figure></li><li><p>停止容器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">stop</span> 容器<span class="keyword">ID</span>/容器名</span><br></pre></td></tr></table></figure></li><li><p>强制停止容器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">kill</span> 容器<span class="keyword">ID</span>/容器名</span><br></pre></td></tr></table></figure></li><li><p>删除已停止的容器</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> rm 容器ID/容器名</span><br></pre></td></tr></table></figure><ul><li><p>删除多个容器</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f <span class="constructor">$(<span class="params">docker</span> <span class="params">ps</span> -<span class="params">a</span> -<span class="params">q</span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a -q <span class="string">| xargs docker rm</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看容器日志</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -t <span class="comment">--tail 容器ID</span></span><br></pre></td></tr></table></figure><ul><li>-t : 加入时间戳</li><li>-f : 跟随最新的打印日志</li><li>–tail 数字 显示最后多少条 </li></ul></li><li><p>查看容器内进程</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">top</span> 容器ID</span><br></pre></td></tr></table></figure></li><li><p>查看容器内部细节</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">inspect</span> 容器ID</span><br></pre></td></tr></table></figure></li><li><p>进入正在运行的容器并以命令行交互</p><ul><li><p>在容器中打开新的终端，并且可以启动新的进程</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -<span class="keyword">it</span> 容器ID bashShell</span><br></pre></td></tr></table></figure><p>​    当bashShell=/bin/bash时，直接进入到容器终端</p></li><li><p>直接进入容器启动命令的终端，不会启动新的进程</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">attach</span> 容器ID</span><br></pre></td></tr></table></figure></li></ul></li><li><p>将容器内的文件拷贝到主机上</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> <span class="meta">cp</span> 容器ID:容器内路径  目的主机的路径</span><br></pre></td></tr></table></figure></li></ul><h1 id="Docker镜像详解"><a href="#Docker镜像详解" class="headerlink" title="Docker镜像详解"></a>Docker镜像详解</h1><h2 id="联合文件系统（UnionFS）"><a href="#联合文件系统（UnionFS）" class="headerlink" title="联合文件系统（UnionFS）"></a><strong>联合文件系统（UnionFS）</strong></h2><p>​        Union文件系统是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层提交，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础，镜像可以通过分层来继承，基于基础镜像，可以制作各种具体的应用镜像。</p><p>​        特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终包含所有底层的文件和目录。</p><h2 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a><strong>Docker镜像加载原理</strong></h2><p>​        docker的镜像实际上由一层一层的文件系统组成，也就是UnionFS。</p><p>​        bootfs(boot file system)主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动会加载bootfs文件系统。<code>Docker镜像的最底层是bootfs。</code>这一层与我们的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p><p>​        rootfs(root file system),在bootfs之上。包含的就是典型Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。</p><p><img src="https://s2.ax1x.com/2020/02/01/1G0FoD.png" alt="image"></p><h2 id="Docker为什么要采用分层结构"><a href="#Docker为什么要采用分层结构" class="headerlink" title="Docker为什么要采用分层结构"></a><strong>Docker为什么要采用分层结构</strong></h2><p>​    共享资源：比如有多个镜像都从相同的base镜像构建而来，那么宿主机只需要在磁盘上保存一份base镜像，同时在内存中加载一份base镜像，就可以为所有容器服务了。</p><h2 id="镜像制作命令"><a href="#镜像制作命令" class="headerlink" title="镜像制作命令"></a><strong>镜像制作命令</strong></h2><p>​        我们可以通过镜像创建容器，也可以将自己定制的容器创建成一个新的镜像。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">commit</span> -m <span class="string">"提交的描述信息"</span> -a <span class="string">"作者"</span> 容器<span class="keyword">ID</span> 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure><h1 id="Docker容器数据卷"><a href="#Docker容器数据卷" class="headerlink" title="Docker容器数据卷"></a>Docker容器数据卷</h1><p><strong>什么是容器数据卷</strong></p><p>​        这要从docker的理念开始讲起 。docker是将应用和运行的环境打包成容器运行，有时在容器运行时产生的文件是我们需要的，但是随着容器的关闭这些文件会消失。我们将文件持久化。还有另外的一种需求，我们希望容器之间可以共享数据 。为了数据能够保存，我们使用容器数据卷来完成。</p><p><strong>容器数据卷的作用</strong></p><p>​        卷就是目录或者文件，存在于一个或多个容器中，但不属于联合文件系统。</p><p>​        卷的设计目的就是数据持久化，完全独立于容器的生命周期，因此删除容器不会删除其挂载的数据卷。</p><p>​        特点:</p><ol><li><p>数据卷可在容器之间共享和重用数据</p><pre><code>2. 卷中的更改可以直接生效              3. 数据卷中的更改不会包含在镜像的更新中          4. 数据卷的生命周期一直持续到没有容器使用它为止</code></pre></li></ol><p><strong>容器数据卷的添加</strong></p><ul><li><p>直接命令添加</p><p>命令:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -<span class="keyword">it</span> -v /宿主机绝对路径目录 : /容器内目录   镜像名</span><br></pre></td></tr></table></figure><p>命令(带权限): 容器只能读取数据卷的数据，不能进行增加和修改</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -<span class="keyword">it</span> -v /宿主机绝对路径目录 : /容器内目录 :ro  镜像名</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Dockerfile  添加</p><ul><li><p>在宿主机根目录下新建myDocker文件夹进入</p></li><li><p>新建Dockerfile ，并使用VOLUME指令来给镜像添加一个或多个数据卷</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># volume test</span></span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/dataVolumeContainer1"</span>,<span class="string">"/dataVolumeContainer2"</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"finished,------success"</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br></pre></td></tr></table></figure></li><li><p>通过Dockerfile 使用build命令构建一个新的镜像</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> <span class="keyword">build </span>-f /myDocker/Dockerfile  -t lyb/centos .</span><br></pre></td></tr></table></figure><ul><li>-f : 指明Dockerfile 的路径</li><li>-t : 镜像名字</li></ul></li><li><p>run新建的镜像，会发现容器的根目录下已经有 dataVolumeContainer1 和dataVolumeContainer2 两个目录</p></li><li><p>考虑到移植性的问题，通过Dockerfile 方式添加数据卷是无法指定数据卷挂载到宿主机的哪个目录。但是docker会帮我们默认指定，通过<code>docker inspect</code>命令查看</p></li></ul></li></ul><p><strong>数据卷容器</strong></p><p>​        命名的容器挂载数据卷，其它容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器，称之为数据卷容器。</p><p>​        <strong>例子：</strong></p><p>​                用上面新建的镜像创建一个容器</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -<span class="keyword">it</span>  <span class="comment">--name dc01 lyb/centos</span></span><br></pre></td></tr></table></figure><p>​                再建立两个容器都以dc01为父容器</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -<span class="keyword">it</span> <span class="comment">--name dc02 --volumes-from dc01 lyb/centos</span></span><br><span class="line">docker <span class="built_in">run</span> -<span class="keyword">it</span> <span class="comment">--name dc03 --volumes-from dc01 lyb/centos</span></span><br></pre></td></tr></table></figure><p>​                实现的效果：dc01、dc02、dc03三个容器的数据卷会实现传递共享，三个容器之间的数据可以共享，即使某一个容器删除其余两个容器依旧可以实现共享。</p><p>​            </p><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><h2 id="Dockerfile-基础"><a href="#Dockerfile-基础" class="headerlink" title="Dockerfile 基础"></a><strong>Dockerfile 基础</strong></h2><p><strong>Dockerfile 是什么：</strong></p><p>​    Dockerfile 是用来构建Docker镜像的Docker文件，是由一系列命令和参数构成的脚本。</p><p><strong>构建三步骤：</strong></p><ul><li>编写Dockerfile 文件</li><li>docker build </li><li>docker run</li></ul><p><strong>Dockerfile 内容基础知识</strong></p><ul><li>每条保留字指令都必须为大写字母且后面至少一个参数</li><li>指令按照从上到下，顺序执行</li><li>‘#’ 表示注释</li><li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li></ul><p><strong>Docker执行Dockerfile 的大致流程</strong></p><ol><li>docker从基础镜像运行一个容器</li><li>执行一条指令并对容器作出修改</li><li>执行类似docker commit的操作提交一个新的镜像层</li><li>docker再基于刚才提交的镜像运行一个新的容器</li><li>执行Dockerfile 中下一条指令直到所有指令都执行完成</li></ol><hr><h2 id="Dockerfile-保留字指令"><a href="#Dockerfile-保留字指令" class="headerlink" title="Dockerfile 保留字指令"></a><strong>Dockerfile 保留字指令</strong></h2><ul><li>FROM    基础镜像，当前新镜像是基于哪个镜像</li><li>MAINTAINER     镜像维护者的姓名和邮箱地址</li><li>RUN  容器构建时需要运行的命令</li><li>EXPOSE   当前容器对外暴露的端口号</li><li>WORKDIR    指定在创建容器后，终端默认登陆的进来工作目录</li><li>ENV    用来在构建镜像过程中设置环境变量</li><li>ADD    将宿主机目录下的文件拷贝进镜像且ADD命令会自动除了URL和解压tar压缩包</li><li>COPY   类似ADD ，拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件/目录 复制到新一层的镜像内的&lt;目标路径&gt;位置</li><li>VOLUME   容器数据卷，用于数据保存和持久化</li><li>CMD   指定一个容器启动时要运行的命令，<code>Dockerfile 可以有多个CMD指令但只有最后一个生效，CMD会被docker run 之后的参数替换</code><ul><li>CMD指令两种格式<ul><li>CMD &lt;命令&gt;</li><li>CMD [“可执行文件”，“参数1”，”参数2“，……]</li></ul></li></ul></li><li>ENTRYPOINT   指定一个容器启动时要运行的命令，<code>和CMD不同的是ENTRYPOINT 只能有一个，但是docker run之后的参数会当作参数追加到ENTRYPOINT 命令</code>。</li><li>ONBUILD 当构建一个被继承的Dockerfile 运行命令，父镜像在被子继承后，父镜像的onbuild被触发</li></ul><h2 id="DocderFile案例"><a href="#DocderFile案例" class="headerlink" title="DocderFile案例"></a><strong>DocderFile案例</strong></h2><p><strong>Base镜像</strong></p><p>​        Docker Hub中99%的镜像都是通过base镜像中安装和配置需要的软件构建出来的。</p><hr><p><strong>定制自定义Centos镜像</strong></p><p>​        <strong>定制前 :</strong> 精简的Centos镜像的默认终端目录是根目录，且不支持ifconfig和vim</p><p>​        *<em>定制要求 : *</em> 终端默认目录在/usr/local,支持ifconfig和vim</p><p>​        <strong>定制过程：</strong>        </p><p>​                <strong>1.编写Dockerfile 文件</strong>        </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span>  lyb&lt;<span class="number">734635746</span>@qq.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span>  MYPATH  /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">  yum -y install vim</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">  yum -y install net-tools</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br></pre></td></tr></table></figure><p>​                <strong>2.制作镜像</strong>        </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f Dockerfile  -t lyb/mycentcs:<span class="number">1.3</span> .</span><br></pre></td></tr></table></figure><p>​                <strong>3.根据镜像制作容器进行验证</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -<span class="keyword">it</span> lyb/mycentcs:<span class="number">1.3</span></span><br></pre></td></tr></table></figure><hr><p><strong>构建Tomcat9镜像</strong></p><p>​        <strong>构建前准备：</strong></p><ol><li><p>建立一个目录用于构建  /root/myTomcat</p></li><li><p>在上述目录下</p><p>新建</p><p>​    a.txt </p><p>​    Dockerfile </p><p>存放</p><p>​    apache-tomcat-9.0.8.tar.gz</p><p>​    jdk-8u241-linux-x64.tar.gz</p><p><strong>构建：</strong></p></li></ol><ol><li><p>编写Dockerfile </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span>  lyb&lt;<span class="number">734635746</span>@qq.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#把宿主机当前上下文的a.txt拷贝到容器/usr/loacal/路径下</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> c.txt  /usr/<span class="built_in">local</span>/container.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#把java与tomcat添加并解压到容器中</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> jdk-8u241-linux-x64.tar.gz  /usr/<span class="built_in">local</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> apache-tomcat-9.0.8.tar.gz  /usr/<span class="built_in">local</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装vim编译器</span></span><br><span class="line">RUM yum -y install vim</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置终端登陆目录</span></span><br><span class="line"><span class="keyword">ENV</span> MYPATH /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置java与tomcat环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/local/jdk1.<span class="number">8.0</span>_241</span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line"><span class="keyword">ENV</span> CATALINA_HOME /usr/local/apache-tomcat-<span class="number">9.0</span>.<span class="number">8</span></span><br><span class="line"><span class="keyword">eNV</span> CATALINA_BASE /usr/local/apache-tomcat-<span class="number">9.0</span>.<span class="number">8</span></span><br><span class="line"><span class="keyword">ENV</span> PATH $PATH:$JAVA_HOME/bin:$CAYALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line">$容器运行时监听的端口</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行时启动tomcat</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /usr/<span class="built_in">local</span>/apache-tomcat-9.0.8/bin/startup.sh &amp;&amp; tail -F /usr/<span class="built_in">local</span>/apache-tomcat-9.0.8/bin/logs/catalina.out</span></span><br></pre></td></tr></table></figure></li><li><p>制作镜像</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> <span class="keyword">build </span>Dockerfile  lyb/mytomcat9 .</span><br></pre></td></tr></table></figure></li></ol><h1 id="Docker小结"><a href="#Docker小结" class="headerlink" title="Docker小结"></a>Docker小结</h1><p><img src="https://s2.ax1x.com/2020/02/02/1Ydin0.png" alt="image"></p><h1 id="Docker常用安装"><a href="#Docker常用安装" class="headerlink" title="Docker常用安装"></a>Docker常用安装</h1><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p>​        <strong>拉取镜像</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:<span class="number">5.7</span></span><br></pre></td></tr></table></figure><p>​        <strong>新建并启动容器</strong></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p <span class="number">3306</span>:<span class="number">3306</span> --name mysql \</span><br><span class="line">-v /root/mysql_docker/<span class="symbol">conf:</span>/etc/mysql/conf.d \</span><br><span class="line">-v /root/mysql_docker/<span class="symbol">logs:</span>/logs \</span><br><span class="line">-v /root/mysql_docker/<span class="symbol">data:</span>/var/<span class="class"><span class="keyword">lib</span>/<span class="title">mysql</span> \</span></span><br><span class="line">-e MYSQL_ROOT_PASSWORD=<span class="number">123456</span> \</span><br><span class="line">-d <span class="symbol">mysql:</span><span class="number">5.7</span></span><br></pre></td></tr></table></figure><p>​        <strong>进入容器就可以操作mysql了</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it <span class="string">mysql:</span><span class="number">5.7</span> <span class="regexp">/bin/</span>bash</span><br></pre></td></tr></table></figure><h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><p>​        <strong>拉取镜像</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull <span class="keyword">redi</span><span class="variable">s:3</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure><p>​        <strong>新建并启动容器</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p <span class="number">6379</span>:<span class="number">6379</span> \</span><br><span class="line">-v <span class="regexp">/root/</span>redis_docker<span class="regexp">/data:/</span>data \</span><br><span class="line">-v <span class="regexp">/root/</span>redis_docker<span class="regexp">/conf/</span>redis.<span class="string">conf:</span><span class="regexp">/usr/</span>local<span class="regexp">/etc/</span>redis/redis.conf \</span><br><span class="line">-d <span class="string">redis:</span><span class="number">3.2</span> \</span><br><span class="line">redis-server <span class="regexp">/usr/</span>local<span class="regexp">/etc/</span>redis/redis.conf \</span><br><span class="line">--appendonly yes</span><br></pre></td></tr></table></figure><p>​        <strong>在宿主机建立redis.conf挂载到redis中</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /root/redis_docker/<span class="keyword">conf</span>/redis.<span class="keyword">conf</span></span><br><span class="line">touch redis.<span class="keyword">conf</span></span><br><span class="line"><span class="keyword">vim</span> redis.<span class="keyword">conf</span> (自行添加redis配置文件)</span><br></pre></td></tr></table></figure><p>​        <strong>测试redis-cli连接</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">exec</span> -it 容器ID redis-cli</span><br><span class="line"></span><br><span class="line">操作测试</span><br><span class="line"></span><br><span class="line"><span class="keyword">shutdown</span></span><br></pre></td></tr></table></figure><p>​        <strong>检查/root/redis_docker/data/appendonly.aof是否持久化成功</strong></p><h1 id="推送镜像到阿里云"><a href="#推送镜像到阿里云" class="headerlink" title="推送镜像到阿里云"></a>推送镜像到阿里云</h1><ol><li><p>准备好要推送的镜像，这里这接用上面案例制作的镜像</p></li><li><p>准备阿里云开发者平台 <a href="http://dev.aliyun.com/search.html" target="_blank" rel="noopener">http://dev.aliyun.com/search.html</a></p></li><li><p>建立镜像仓库(选择本地仓库)</p></li><li><p>将镜像推送到阿里云</p></li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker login --username=***(具体查看操作说明)***** registry.<span class="keyword">cn</span>-qingdao.aliyuncs.<span class="keyword">com</span></span><br><span class="line">$ sudo docker <span class="keyword">tag</span> [ImageId] registry.<span class="keyword">cn</span>-qingdao.aliyuncs.<span class="keyword">com</span>/lybhub/mycento<span class="variable">s:</span>[镜像版本号]</span><br><span class="line">$ sudo docker push registry.<span class="keyword">cn</span>-qingdao.aliyuncs.<span class="keyword">com</span>/lybhub/mycento<span class="variable">s:</span>[镜像版本号]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker为什么会出现&quot;&gt;&lt;a href=&quot;#Docker为什么会出现&quot; class=&quot;headerlink&quot; title=&quot;Docker为什么会出现&quot;&gt;&lt;/a&gt;Docker为什么会出现&lt;/h1&gt;&lt;p&gt;​    以前在服务器上部署一个应用，除了应用本身还要安装各种相应的软件、依赖，进行各种相应的配置。这种方式不仅费时费力还不能跨平台，不利于应用的集群部署。&lt;/p&gt;
&lt;p&gt;​        Docker的出现提供了一个解决方案，打破了&lt;code&gt;程序及应用&lt;/code&gt;的传统观念。&lt;code&gt;通过镜像（images）将作业系统核心除外，运作应用所需的系统环境，由下而上进行打包，达到应用程序跨平台无缝部署运行。&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Docker" scheme="http://liuyoubin.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Nginx学习笔记</title>
    <link href="http://liuyoubin.top/2020/01/29/backEnd/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://liuyoubin.top/2020/01/29/backEnd/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-01-29T15:36:02.000Z</published>
    <updated>2020-03-19T13:17:40.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx是什么"><a href="#Nginx是什么" class="headerlink" title="Nginx是什么?"></a>Nginx是什么?</h1><p>​        Nginx是一个高性能的HTTP和反向代理的web服务器，具有轻量级、占用内存少、并发能力强的特点。</p><a id="more"></a><h1 id="Nginx的应用"><a href="#Nginx的应用" class="headerlink" title="Nginx的应用"></a>Nginx的应用</h1><ol><li><p>Nginx作为Web服务器</p><p>​        Nginx可以作为静态页面的web服务器、支持CGI协议的动态语言，例如：php。</p></li><li><p>正向代理</p><p>​        Nginx可以作正向代理来进行上网。正向代理:是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。正向代理中客户端对于目标服务器是透明的。</p></li></ol><p><img src="https://s2.ax1x.com/2020/01/30/1lS7wV.png" alt="image"></p><ol start="3"><li><p>反向代理</p><p>​        反向代理：我们只 需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返 回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器 地址，隐藏了真实服务器 IP 地址。反向代理中目标服务器对于客户端是透明的。</p></li></ol><p><img src="https://s2.ax1x.com/2020/01/30/1lpVld.png" alt="image"></p><ol start="4"><li><p>负载均衡</p><p>​        客户端发送多个请求到服务器，服务器处理请求，再将结果返回给客户端。这种传统架构随着信息数量的增长以及业务的日益复杂，服务器性能渐渐出现了瓶颈。为了缓解服务器的压力我们可以将同一应用部署到多个服务器上对外提供同一种服务，这就是集群的概念。而将大量的请求负载分发到不同服务器上，这就是负载均衡。</p></li></ol><p><img src="https://s2.ax1x.com/2020/01/30/1lp20x.png" alt="image"></p><ol start="5"><li><p>动静分离</p><p>为了加快网址的解析速度，可以把网站的动态页面和静态页面让不同服务器来解析。</p></li></ol><p><img src="https://s2.ax1x.com/2020/01/30/1l9iBq.png" alt="image"></p><h1 id="Nginx的安装与启动"><a href="#Nginx的安装与启动" class="headerlink" title="Nginx的安装与启动"></a>Nginx的安装与启动</h1><p>nginx有windows版本和linux版本，windows版本的安装比较简单，这里主要记录Linux版本的安装</p><ol><li>进入Nginx的官网<a href="http://nginx.org选择版本进行下载，我这里选择nginx-1.12.1稳定版本进行安装" target="_blank" rel="noopener">http://nginx.org选择版本进行下载，我这里选择nginx-1.12.1稳定版本进行安装</a></li></ol><p><img src="https://s2.ax1x.com/2020/01/30/1lCui8.png" alt="image"></p><ol start="2"><li>安装nginx所需要的依赖</li></ol><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc <span class="literal">zlib</span> <span class="literal">zlib</span>-devel pcre-devel openssl openssl-devel</span><br></pre></td></tr></table></figure><ol start="3"><li>安装nginx</li></ol><ul><li>解压nginx-xxxx.tar.gz</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-zxvf</span> <span class="selector-tag">nginx-1</span><span class="selector-class">.12</span><span class="selector-class">.2</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure><ul><li>进入到nginx目录执行./configure命令 </li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./configure</span></span><br></pre></td></tr></table></figure><ul><li>执行安装命令</li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span> &amp;&amp; <span class="built_in">make</span> install</span><br></pre></td></tr></table></figure><ol start="4"><li><p>检查是否安装成功</p><p>​    进入到/usr/local中查看，如果安装成功会在这个目录下看到nginx目录。</p></li><li><p>启动nginx</p><p>在/usr/local/nginx/sbin中会有一个<code>nginx</code>启动命令。我们在这个目录下执行下面的命令就可以启动nginx了</p></li></ol><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./nginx</span></span><br></pre></td></tr></table></figure><p>​        通过检查进程确定nginx是否正确启动</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ps</span> -ef | <span class="keyword">grep</span> nginx</span><br></pre></td></tr></table></figure><h1 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h1><p>记住必须进入到/usr/local/nginx/sbin后才能使用nginx命令</p><ul><li><p>查看nginx版本号</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./nginx</span> -v</span><br></pre></td></tr></table></figure></li><li><p>启动nginx</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./nginx</span></span><br></pre></td></tr></table></figure></li><li><p>关闭nginx</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./nginx</span> -s stop 或者 <span class="string">./nginx</span> -s <span class="keyword">quit</span></span><br></pre></td></tr></table></figure></li><li><p>重加载</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./nginx</span> -s <span class="keyword">reload</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Nginx的配置文件"><a href="#Nginx的配置文件" class="headerlink" title="Nginx的配置文件"></a>Nginx的配置文件</h1><h2 id="配置文件位置"><a href="#配置文件位置" class="headerlink" title="配置文件位置"></a>配置文件位置</h2><p><code>/usr/local/nginx/conf/nginx.conf</code></p><h2 id="配置文件的组成"><a href="#配置文件的组成" class="headerlink" title="配置文件的组成"></a>配置文件的组成</h2><blockquote><p>nginx配置文件由三部分组成：全局块、events块、http块</p></blockquote><h3 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h3><p>​        从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配 置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以 及配置文件的引入等。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">来指定Nginx Worker进程运行用户以及用户组，默认由nobody账号运行。也可以创建nginx用户指定用户。</span><br><span class="line">可以通过</span><br><span class="line"><span class="attribute">groupadd</span> home </span><br><span class="line">useradd -g home lyb</span><br><span class="line">来增加用户组和用户</span><br><span class="line">*/</span><br><span class="line">user  nobody;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是</span><br><span class="line">会受到硬件、软件等设备的制约</span><br><span class="line">*/</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">用来定义全局错误日志文件。日志输出级别有debug、info、notice、warn、error、crit可供选择，其中，debug输出日志最为最详细，而crit输出日志最少。</span><br><span class="line">*/</span><br><span class="line"><span class="attribute">error_log</span>  logs/error.log;</span><br><span class="line"><span class="attribute">error_log</span>  logs/error.log  <span class="literal">notice</span>;</span><br><span class="line"><span class="attribute">error_log</span>  logs/error.log  <span class="literal">info</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">用来指定进程id的存储文件位置</span><br><span class="line">*/</span><br><span class="line"><span class="attribute">pid</span>   logs/nginx.pid;</span><br></pre></td></tr></table></figure><h3 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h3><p>​        events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">用来指定Nginx的工作模式。Nginx支持的工作模式有select、poll、kqueue、epoll、rtsig和/dev/poll。</span><br><span class="line"></span><br><span class="line">其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，不同的是epoll用在Linux平台上，而kqueue用在BSD系统中,对于Linux系统，epoll工作模式是首选。</span><br><span class="line">*/</span><br><span class="line"><span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">用于定义Nginx每个进程的最大连接数，即接收前端的最大请求数，默认是1024。</span><br><span class="line"></span><br><span class="line">最大客户端连接数由worker_processes和worker_connections决定，即Max_clients=worker_processes*worker_connections，</span><br><span class="line"></span><br><span class="line">在作为反向代理时，Max_clients变为：Max_clients = worker_processes * worker_connections/4</span><br><span class="line"></span><br><span class="line">进程的最大连接数受Linux系统进程的最大打开文件数限制，在执行操作系统命令“ulimit -n 65536”后worker_connections的设置才能生效。</span><br><span class="line">*/</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h3><p>​        这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意的是：http 块也可以包括 http 全局块、server 块</p><h4 id="http全局块"><a href="#http全局块" class="headerlink" title="http全局块"></a>http全局块</h4><p>​        http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">/**</span><br><span class="line">来用设定文件的mime类型,类型在配置文件目录下的mime.type文件定义，来告诉nginx来识别文件类型。</span><br><span class="line">*/</span><br><span class="line"><span class="attribute">include</span>       mime.types;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">设定了默认的类型为二进制流，也就是当文件类型未定义时使用这种方式，例如在没有配置asp的locate环境时，Nginx是不予解析的，此时，用浏览器访问asp文件就会出现下载了。</span><br><span class="line">*/</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">报文大小限制    </span><br><span class="line">*/</span><br><span class="line"><span class="attribute">client_max_body_size</span> <span class="number">1024m</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">用于设置日志的格式，和记录哪些参数，这里设置为main，刚好用于access_log来纪录这种类型。</span><br><span class="line">*/</span><br><span class="line">    <span class="comment">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">    <span class="comment">#                  '$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">    <span class="comment">#                  '"$http_user_agent" "$http_x_forwarded_for"';</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="server块"><a href="#server块" class="headerlink" title="server块"></a>server块</h4><p>​        这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了 节省互联网服务器硬件成本。 每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。 而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。</p><ul><li><p>全局server块</p><p>​        最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置</p><ul><li><p>listen：用于指定虚拟主机的服务端口。</p></li><li><p>server_name：用来指定IP地址或者域名，多个域名之间用空格分开。</p></li><li><p>root ：表示在这整个server虚拟主机内，全部的root web根目录。注意要和locate {}下面定义的区分开来</p></li><li><p>index ：全局定义访问的默认首页地址。注意要和locate {}下面定义的区分开来。</p></li><li><p>charset：用于设置网页的默认编码格式。</p></li><li><p>access_log：用来指定此虚拟主机的访问日志存放路径，最后的main用于指定访问日志的输出格式。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line">        <span class="attribute">root</span>   /Users/app/lyb;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.php; </span><br><span class="line">        <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line">        <span class="attribute">access_log</span>  logs/host.access.log  main;</span><br><span class="line">        <span class="attribute">aerror_log</span>  logs/host.<span class="literal">error</span>.log   main;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>location块</p><p>​        一个 server 块可以配置多个 location 块。 这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称 （也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓 存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</p></li></ul><h1 id="Nginx配置实例"><a href="#Nginx配置实例" class="headerlink" title="Nginx配置实例"></a>Nginx配置实例</h1><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p><strong>实现效果：</strong>在浏览器中输入<a href="http://www.lyb.com,跳转到Linux上的tomcat主页面" target="_blank" rel="noopener">www.lyb.com,跳转到Linux上的tomcat主页面</a></p><p><strong>准备工作：</strong> 在Linux安装nginx和tomcat</p><p><strong>开始配置：</strong></p><ul><li><p>在本地的host文件中配置<a href="http://www.lyb.com映射到nginx所在服务器的ip" target="_blank" rel="noopener">www.lyb.com映射到nginx所在服务器的ip</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务器<span class="selector-tag">ip</span> <span class="selector-tag">www</span><span class="selector-class">.lyb</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure></li><li><p>在nginx中进行反向代理配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">       listen       80; //监听的端口</span><br><span class="line">       server_name  **.**.**.**; //nginx所在服务器ip</span><br><span class="line">  </span><br><span class="line">       <span class="comment">#charset koi8-r;</span></span><br><span class="line">  </span><br><span class="line">       <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line">  </span><br><span class="line">       <span class="attribute">location</span> / &#123;</span><br><span class="line">           <span class="attribute">root</span>   html;</span><br><span class="line">           proxy_pass http://127.0.0.1:8080; //设置代理转发                                         index  index.html index.htm;                                                       &#125;</span><br><span class="line">   ....</span><br></pre></td></tr></table></figure></li><li><p>重启nginx即可实现反向代理转发</p></li></ul><p><strong>扩展：</strong></p><p>​        如果想实现根据不同的请求路径跳转到不同的服务可以设置多个location，例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">       listen       80; //监听的端口</span><br><span class="line">       server_name  **.**.**.**; //nginx所在服务器ip</span><br><span class="line"></span><br><span class="line">       <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">       <span class="attribute">location</span> <span class="regexp">~ /user/</span> &#123;</span><br><span class="line">           proxy_pass http://127.0.0.1:8080; //设置代理转发                                        &#125;</span><br><span class="line">           </span><br><span class="line">         <span class="attribute">location</span> <span class="regexp">~ /vod/</span> &#123;</span><br><span class="line">           proxy_pass http://127.0.0.1:8081; //设置代理转发                                        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ /oss/</span> &#123;</span><br><span class="line">           proxy_pass http://127.0.0.1:8082; //设置代理转发                                        &#125;</span><br><span class="line">      ....</span><br></pre></td></tr></table></figure><p><strong>location指令说明：</strong></p><p>​        该指令用于匹配URL，语法如下 </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> [ = | <span class="regexp">~ |</span> <span class="regexp">~* |</span><span class="regexp"> ^~</span> ] URL&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配 成功，就停止继续向下搜索并立即处理该请求</p></li><li><p>~：用于表示 uri 包含正则表达式，并且区分大小写</p></li><li><p>~*：用于表示 uri 包含正则表达式，并且不区分大小写</p></li><li><p>^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字 符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配</p></li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p><strong>实现效果：</strong>在浏览器中输入http://服务器ip/vod/a.html,让这个请求分发到8080和8081两给tomcat上，实现轮询负载均衡</p><p><strong>准备工作：</strong>在服务器上开启两个tomcat，一个监听8080端口，一个监听8081端口。分别在两个tomat下部署vod应用，在应用下放置a.html文件用于测试。</p><p><strong>开始配置：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">   upstream myserver&#123; //配置负载均衡模块</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:8081</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">47.105.165.248</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            proxy_pass http://myserver; //设置负载转发，这里填的是负载均衡模块的名字</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">      .......</span><br></pre></td></tr></table></figure><p><strong>扩展：</strong></p><p>​        <strong>Nginx提供几种负载均衡策略</strong></p><ul><li><p>轮询（默认）</p><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream myserver&#123; //配置负载均衡模块</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:8081</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>weight</p><p>weight 代表权重默认为 1,权重越高被分配的客户端越多 指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> myserver&#123;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.5.21</span> weight=<span class="number">1</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.5.22</span> weight=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ip_hash</p><p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> server_pool&#123;</span><br><span class="line">ip_hash;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.5.21:80</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.5.22:80</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>fair（第三方）</p><p>​        更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。</p></li></ul><p>  <strong>负载均衡调度状态</strong></p><p>  ​        在upstream模块中。server指令除了可以设置服务器的ip和端口，也可以设置负载均衡调度状态。</p><ul><li>down  表示这台服务器不参与负载均衡</li><li>backup  表示这台服务器作为备用机器，当所有其他非备用机器故障或宕机时才启用</li><li>max_fails  允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误</li><li>fail_timeout： 在经历过max_fails 次失败后，暂停服务的时间</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> server_group &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:80</span> backup;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.2:80</span> down;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.3:8080</span>  max_fails=<span class="number">3</span>  fail_timeout=<span class="number">20s</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.4:8080</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p><strong>实现效果：</strong>访问/www/a.html可以访问到服务器上/data/www/a.html,访问/image/scroll.png可以访问到服务器上/data/image/scroll.png</p><p><strong>准备工作：</strong>在Linux的/目录下一个data目录，data目录下建立一个www和image文件夹用于存放静态资源</p><p><strong>开始配置：</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">       <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">       <span class="attribute">server_name</span>  **.**.**.**;</span><br><span class="line"></span><br><span class="line">       <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">       <span class="attribute">location</span> /www/ &#123;</span><br><span class="line">           <span class="attribute">root</span>   /data/;</span><br><span class="line">           <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="attribute">location</span> /image/ &#123;</span><br><span class="line">           <span class="attribute">root</span> /data/;</span><br><span class="line">           autoindex on; //列出当前文件夹中的资源</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h1 id="Nginx高可用集群"><a href="#Nginx高可用集群" class="headerlink" title="Nginx高可用集群"></a>Nginx高可用集群</h1><p><strong>准备工作：</strong></p><ul><li><p>准备两台Linux服务器</p></li><li><p>两台服务器安装好nginx，参考上面的配置</p></li><li><p>两台服务器安装好keepalived</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> keepalived -y</span><br></pre></td></tr></table></figure><p>安装好后可以在/etc/中找到keepalived</p></li></ul><p><strong>Keepalived+Nginx(主从模式)</strong></p><ul><li>修改keeyalived.conf文件(/etc/keeyalived.conf)  可以参考以下配置</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line"> notification_email &#123;</span><br><span class="line"> </span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line">     notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">     smtp_server 192.168.17.129</span><br><span class="line">     smtp_connect_timeout 30</span><br><span class="line">     router_id LVS_DEVEL  #访问本机的名字，可以通过/etc/hots进行设置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_http_port &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in"> script </span><span class="string">"/usr/local/src/nginx_check.sh"</span> #脚本文件</span><br><span class="line"></span><br><span class="line">     interval 2 #（检测脚本执行的间隔）</span><br><span class="line"></span><br><span class="line">     weight -20 # 权重的改变，当服务器挂掉时做出改变</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">     state BACKUP # 备份服务器上将 MASTER 改为 BACKUP</span><br><span class="line">    <span class="built_in"> interface </span>ens33 #网卡，可以通过ifconfig进行查看</span><br><span class="line">     virtual_router_id 51 # 主、备机的 virtual_router_id 必须相同</span><br><span class="line">     priority 100 # 主、备机取不同的优先级，主机值较大，备份机值较小</span><br><span class="line">     advert_int 1  # 心跳检测时间</span><br><span class="line">     </span><br><span class="line">     authentication &#123; #权限验证</span><br><span class="line">         auth_type PASS</span><br><span class="line">         auth_pass 1111</span><br><span class="line">  &#125;</span><br><span class="line"> virtual_ipaddress &#123;</span><br><span class="line"> 192.168.17.50 #<span class="built_in"> VRRP </span>H 虚拟地址</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加nginx_check.sh 脚本文件，路径对应上面keeyalived.conf的配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">A=`ps -C nginx –no-header |wc -l`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$A</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line"> /usr/<span class="built_in">local</span>/nginx/sbin/nginx  <span class="comment">#nginx启动脚本位置</span></span><br><span class="line"> sleep 2</span><br><span class="line"> <span class="keyword">if</span> [ `ps -C nginx --no-header |wc -l` -eq 0 ];<span class="keyword">then</span></span><br><span class="line"> killall keepalived</span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li>启动Nginx和Keepalived</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./nginx</span><br><span class="line">systemctl <span class="literal">start</span> keepalived.service</span><br></pre></td></tr></table></figure><h1 id="Nginx原理"><a href="#Nginx原理" class="headerlink" title="Nginx原理"></a>Nginx原理</h1><p><strong>master&amp;worker</strong></p><p>​        nginx服务有一个master进程和多个woker进程(通过worker_processes决定)。master进程负责管理、监控worker进程，而worker进程负责具体的请求处理。</p><p>​        请求首先发给master进程，由master通知worker进行争抢。</p><p><img src="https://s2.ax1x.com/2020/01/31/11csLq.png" alt="image"></p><p>*<em>master-workers 的机制的好处 *</em></p><ul><li>对于每一个worker来说，由于是独立的进程，不需要加锁，节省的加锁带来的开销，彼此之间互不影响。</li><li>每一个worker独立工作，当一个进程退出后，其他进程还可以继续工作，降低了风险。master 进程可以很快启动新的 worker 进程</li><li>有利于热加载的实现</li></ul><p><strong>需要设置多少个 worker</strong></p><p>​        Nginx 同 redis 类似都采用了 io 多路复用机制，每个 worker 都是一个独立的进程，但每个进 程里只有一个主线程，通过异步非阻塞的方式来处理请求， 即使是千上万个请求也不在话 下。每个 worker 的线程可以把一个 cpu 的性能发挥到极致。所以 worker 数和服务器的 cpu 数相等是最为适宜的。设少了会浪费 cpu，设多了会造成 cpu 频繁切换上下文带来的损耗。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置 worker 数量。</span></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#work 绑定 cpu(4 work 绑定 4cpu)。</span></span><br><span class="line">worker_cpu_affinity <span class="number">0001</span> <span class="number">0010</span> <span class="number">0100</span> <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#work 绑定 cpu (4 work 绑定 8cpu 中的 4 个) 。</span></span><br><span class="line">worker_cpu_affinity <span class="number">0000001</span> <span class="number">00000010</span> <span class="number">00000100</span> <span class="number">00001000</span></span><br></pre></td></tr></table></figure><p><strong>连接数 worker_connection</strong></p><p>​        这个值是表示每个 worker 进程所能建立连接的最大值，所以，一个 nginx 能建立的最大连接 数，应该是 worker_connections * worker_processes。当然，这里说的是最大连接数，对于 HTTP 请 求 本 地 资 源 来 说 ， 能 够 支 持 的 最 大 并 发 数 量 是 worker_connections * worker_processes，如果是支持 http1.1 的浏览器每次访问要占两个连接，所以普通的静态访 问最大并发数是： worker_connections * worker_processes /2，而如果是 HTTP 作 为反向代 理来说，最大并发数量应该是 worker_connections * worker_processes/4。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服 务的连接，会占用两个连接。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Nginx是什么&quot;&gt;&lt;a href=&quot;#Nginx是什么&quot; class=&quot;headerlink&quot; title=&quot;Nginx是什么?&quot;&gt;&lt;/a&gt;Nginx是什么?&lt;/h1&gt;&lt;p&gt;​        Nginx是一个高性能的HTTP和反向代理的web服务器，具有轻量级、占用内存少、并发能力强的特点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Nginx" scheme="http://liuyoubin.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Spring扩展1----生命周期</title>
    <link href="http://liuyoubin.top/2020/01/29/backEnd/framework/Spring%E6%89%A9%E5%B1%951-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://liuyoubin.top/2020/01/29/backEnd/framework/Spring%E6%89%A9%E5%B1%951-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2020-01-29T07:47:29.000Z</published>
    <updated>2020-03-18T13:33:08.203Z</updated>
    
    <content type="html"><![CDATA[<p>​        在传统的java应用中，对象的生命周期是比较简单的，程序员通过new关键字就可以实例化一个对象进行使用了，当对象不再需要使用的时候，由JVM垃圾回收器进行回收就可以了。</p><p>​        相比之下，Spring容器管理之下的bean生命周期就复杂很多了。</p><a id="more"></a><p>​        先来看一副Bean生命周期图：</p><p><img src="https://s2.ax1x.com/2020/01/29/1QuVu8.png" alt="image"></p><p>​        上面就是SpringBean生命周期的基本流程，下面对每一个流程进行简单描述：</p><ol><li><p>在所有beanDenifition加载完成后，bean实例化之前执行这个方法。如果在beanFactory加载完所有bean后想修改某个bean或者对beanFactory做一些配置可以用这个方法。</p></li><li><p>通过beanDenifition实例化一个bean</p></li><li><p>按照Spring上下文对实例化的bean进行配置，处理自动注入</p></li><li><p>如果bean实现了BeanNameAware接口，则调用setBeanName()方法，设置bean的id</p></li><li><p>如果bean实现了BeanFactoryAware接口，则调用setBeanFactory()方法，设置Spring工厂自身</p></li><li><p>如果bean实现了ApplicationContextAware接口，则调用setApplicationAware()方法，设置Spring上下文</p></li><li><p>如果这个bean关联了BeanPostProcessor接口，则调用postProcessBeforeInitialization(Object bean, String beanName)方法</p></li><li><p>如果bean实现了InitializingBean接口,，则调用afterPropertiesSet()方法</p></li><li><p>如果配置文件或者@Bean中配置了init-method，则调用指定的初始化方法</p></li><li><p>如果这个bean关联了BeanPostProcessor接口，则调用postProcessAfterInitialization(Object bean, String beanName)方法</p></li><li><p>如果bean实现了DisposableBean接口,，则调用destroy()方法</p></li><li><p>如果配置文件或者@Bean中配置了destroy-method，则调用指定的销毁方法</p><p>​                                                                                                                                    </p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​        在传统的java应用中，对象的生命周期是比较简单的，程序员通过new关键字就可以实例化一个对象进行使用了，当对象不再需要使用的时候，由JVM垃圾回收器进行回收就可以了。&lt;/p&gt;
&lt;p&gt;​        相比之下，Spring容器管理之下的bean生命周期就复杂很多了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="框架" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="http://liuyoubin.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring中initializingBean、init-method、@PostConstruct执行顺序(源码分析)</title>
    <link href="http://liuyoubin.top/2020/01/28/backEnd/framework/Spring%E4%B8%ADinitializingBean%E3%80%81init-method%E3%80%81-PostConstruct%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>http://liuyoubin.top/2020/01/28/backEnd/framework/Spring%E4%B8%ADinitializingBean%E3%80%81init-method%E3%80%81-PostConstruct%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</id>
    <published>2020-01-28T09:29:30.000Z</published>
    <updated>2020-01-28T14:29:56.668Z</updated>
    
    <content type="html"><![CDATA[<div class="note info">            <p>探究initializingBean、init-method、@PostConstruct的执行顺序 </p>          </div><a id="more"></a><p>​        在Spring容器中，Bean是有着完整的生命周期。Spring除了自定义了Bean实例化、初始化、销毁过程，还允许我们在Bean的初始化之后，销毁之前执行特定的操作来改变bean。常见的方式有三种</p><ul><li><p>实现<code>InitializingBean/DisposableBean</code> 的<code>afterPropertiesSet()/destroy()方法</code>来定制</p></li><li><p>通过在指定方法上添加<code>@PostConstruct</code>来实现</p></li><li><p>通过<code>init-method/destroy-method属性</code>来指定方法来定制</p><p>那么这三种方式定制的方法执行顺序是怎么样的呢？我们通过代码来验证。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>,<span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setName方法执行"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"静态代码块执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TestBean()&#123;</span><br><span class="line">        System.out.println(<span class="string">"TestBean构造方法执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  InitializingBean接口的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"afterPropertiesSet方法执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  DisposableBean接口的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"destroy方法执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过<span class="doctag">@PostConstruct</span>注解定制方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postConstruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@PostConstruct注解方法执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过initMethod指定的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"initMethod方法执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过destroyMethod指定的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"destroyMethod方法执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line">    </span><br><span class="line"> <span class="meta">@Bean</span>(initMethod = <span class="string">"initMethod"</span>,destroyMethod = <span class="string">"destroyMethod"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">createTestBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TestBean bean = <span class="keyword">new</span> TestBean();</span><br><span class="line">        bean.setName(<span class="string">"lyb"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        执行结果如下：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">静态代码块执行</span><br><span class="line">TestBean构造方法执行</span><br><span class="line">setName方法执行</span><br><span class="line">@PostConstruct注解方法执行</span><br><span class="line"><span class="keyword">after</span>PropertiesSet方法执行</span><br><span class="line">initMethod方法执行</span><br><span class="line"> </span><br><span class="line"> ........</span><br><span class="line"> </span><br><span class="line">destroy方法执行</span><br><span class="line">destroyMethod方法执行</span><br></pre></td></tr></table></figure><p>​        通过上面的结果就可以知道这三种方式定制的方法都是在<code>bean实例化之后</code>执行的,构造方法和属性设置已经完成了。顺序也就知道了：</p><p>Constructor &gt; <code>@PostConstruct &gt; InitialzingBean &gt; init-method</code> &gt; DisposableBean &gt; destroyMethod</p><p>​        那为什么是这个执行顺序呢?首先构造方法和属性注入先被执行是可以理解的。因为这三种方法都是在bean实例化执行用来修改定制bean的，所以构造方法和属性注入会被先执行完毕。</p><p>​        </p><p>​        @PostConstruct注解的方法为什么会先于InitalzingBean和init-method先执行呢，我们通过源码看看。</p><p>​        我们知道在Spring中产生一个bean要经过配置bean—&gt;生成bean元数据—&gt;生成bean这个过程。而bean的生成是通过BeanFactory中getBean()方法产生的。我们先通过BeanFactory找到其继承类AbstractAutowireCapableBeanFactory，并查看其中的getBean()方法。</p><p>​        通过getBean跟进到createBean()再跟进到doCreateBean()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">        BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">       </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建bean的实例对象</span></span><br><span class="line">        <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instanceWrapper = <span class="keyword">this</span>.createBeanInstance(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .......</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化一个bean</span></span><br><span class="line">        Object exposedObject = bean;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//处理bean的注入</span></span><br><span class="line">            <span class="keyword">this</span>.populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">            <span class="comment">//处理bean的初始化操作</span></span><br><span class="line">            exposedObject = <span class="keyword">this</span>.initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var18) &#123;</span><br><span class="line">            .....</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       .........</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        从这个方法可以看出doCreateBean()的三个核心逻辑：</p><ul><li><p>createBeanInstance方法实例化一个bean对象</p></li><li><p>处理bean之间的依赖注入，例如@Autowired注解</p></li><li><p>对bean进行初始化操作，例如@PostConstruct注解方法</p><p>​    继续进入initializeBean()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(String beanName, Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">       ......</span><br><span class="line"></span><br><span class="line">        Object wrappedBean = bean;</span><br><span class="line">        <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">            <span class="comment">//初始化前置处理</span></span><br><span class="line">            wrappedBean = <span class="keyword">this</span>.applyBeanPostProcessorsBeforeInitialization(bean, beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用初始化方法</span></span><br><span class="line">            <span class="keyword">this</span>.invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">            </span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">            <span class="comment">//初始化后置处理</span></span><br><span class="line">            wrappedBean = <span class="keyword">this</span>.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrappedBean;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        @PostConstruct注解方法将在applyBeanPostProcessorsBeforeInitialization()方法中处理：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> applyBeanPostProcessorsBeforeInitialization(<span class="keyword">Object</span> existingBean, <span class="keyword">String</span> beanName) <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">Object</span> result = existingBean;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Object</span> current;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历所有的后置处理器</span></span><br><span class="line">        <span class="keyword">for</span>(Iterator var4 = <span class="keyword">this</span>.getBeanPostProcessors().iterator(); var4.hasNext(); result = current) &#123;</span><br><span class="line">            BeanPostProcessor processor = (BeanPostProcessor)var4.next();</span><br><span class="line">            <span class="comment">// 调用初始化前置方法</span></span><br><span class="line">            current = processor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        @PostConstruct注解的bean将会被其中一个BeanPostProcessor（bean的后置处理器）处理。</p><p>找到其实现类InitDestroyAnnotationBeanPostProcessor，从这个名字可以看出这是对bean初始化和销毁做处理的一个后置处理器。</p><p>​        跟进其postProcessBeforeInitialization()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        InitDestroyAnnotationBeanPostProcessor.LifecycleMetadata metadata = <span class="keyword">this</span>.findLifecycleMetadata(bean.getClass());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            metadata.invokeInitMethods(bean, beanName);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Invocation of init method failed"</span>, var5.getTargetException());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Failed to invoke init method"</span>, var6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        findLifecycleMetadata()会解析元数据，所以@PostConstruct注解的方法将会被找到,分析下面两段段代码发现，在这里会去判断某方法有没有被initAnnotationType/destroyAnnotationType注解，如果有，则添加到init/destroy队列中，后续一一执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> InitDestroyAnnotationBeanPostProcessor.<span class="function">LifecycleMetadata <span class="title">findLifecycleMetadata</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.lifecycleMetadataCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.buildLifecycleMetadata(clazz);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           InitDestroyAnnotationBeanPostProcessor.LifecycleMetadata metadata = (InitDestroyAnnotationBeanPostProcessor.LifecycleMetadata)<span class="keyword">this</span>.lifecycleMetadataCache.get(clazz);</span><br><span class="line">           <span class="keyword">if</span> (metadata == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">synchronized</span>(<span class="keyword">this</span>.lifecycleMetadataCache) &#123;</span><br><span class="line">                   </span><br><span class="line">                   metadata = (InitDestroyAnnotationBeanPostProcessor.LifecycleMetadata)<span class="keyword">this</span>.lifecycleMetadataCache.get(clazz);</span><br><span class="line">                   <span class="keyword">if</span> (metadata == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">//构建元数据</span></span><br><span class="line">                       metadata = <span class="keyword">this</span>.buildLifecycleMetadata(clazz);</span><br><span class="line">                       <span class="keyword">this</span>.lifecycleMetadataCache.put(clazz, metadata);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">return</span> metadata;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> metadata;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​        跟进buildLifecycleMetadata(),</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> InitDestroyAnnotationBeanPostProcessor.<span class="function">LifecycleMetadata <span class="title">buildLifecycleMetadata</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> debug = <span class="keyword">this</span>.logger.isDebugEnabled();</span><br><span class="line">       List&lt;InitDestroyAnnotationBeanPostProcessor.LifecycleElement&gt; initMethods = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       List&lt;InitDestroyAnnotationBeanPostProcessor.LifecycleElement&gt; destroyMethods = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       Class targetClass = clazz;</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           List&lt;InitDestroyAnnotationBeanPostProcessor.LifecycleElement&gt; currInitMethods = <span class="keyword">new</span> ArrayList();</span><br><span class="line">           List&lt;InitDestroyAnnotationBeanPostProcessor.LifecycleElement&gt; currDestroyMethods = <span class="keyword">new</span> ArrayList();</span><br><span class="line">           </span><br><span class="line">           ReflectionUtils.doWithLocalMethods(targetClass, (method) -&gt; &#123;</span><br><span class="line">               <span class="comment">//判断是否被initAnnotationType注解</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.initAnnotationType != <span class="keyword">null</span> &amp;&amp; method.isAnnotationPresent(<span class="keyword">this</span>.initAnnotationType)) &#123;</span><br><span class="line">                   InitDestroyAnnotationBeanPostProcessor.LifecycleElement element = <span class="keyword">new</span> InitDestroyAnnotationBeanPostProcessor.LifecycleElement(method);</span><br><span class="line">                   currInitMethods.add(element);</span><br><span class="line">                   <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.logger.debug(<span class="string">"Found init method on class ["</span> + clazz.getName() + <span class="string">"]: "</span> + method);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"><span class="comment">//判断是否被destroyAnnotationType注解</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.destroyAnnotationType != <span class="keyword">null</span> &amp;&amp; method.isAnnotationPresent(<span class="keyword">this</span>.destroyAnnotationType)) &#123;</span><br><span class="line">                   currDestroyMethods.add(<span class="keyword">new</span> InitDestroyAnnotationBeanPostProcessor.LifecycleElement(method));</span><br><span class="line">                   <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.logger.debug(<span class="string">"Found destroy method on class ["</span> + clazz.getName() + <span class="string">"]: "</span> + method);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">  </span><br><span class="line">           &#125;);</span><br><span class="line">           initMethods.addAll(<span class="number">0</span>, currInitMethods);</span><br><span class="line">           destroyMethods.addAll(currDestroyMethods);</span><br><span class="line">           targetClass = targetClass.getSuperclass();</span><br><span class="line">       &#125; <span class="keyword">while</span>(targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> InitDestroyAnnotationBeanPostProcessor.LifecycleMetadata(clazz, initMethods, destroyMethods);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​        那么initAnnotationType和destroyAnnotationType是什么呢？我们看InitDestroyAnnotationBeanPostProcessor的父类CommonAnnotationBeanPostProcessor的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CommonAnnotationBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.setOrder(<span class="number">2147483644</span>);</span><br><span class="line">      <span class="keyword">this</span>.setInitAnnotationType(PostConstruct<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">this</span>.setDestroyAnnotationType(PreDestroy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">this</span>.ignoreResourceType(<span class="string">"javax.xml.ws.WebServiceContext"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​    看到这就差不多了，<code>@PostConstruct注解的方法会在BeanPostProcess中被处理，所以要会先于InitializingBean和init-method执行</code>。</p></li></ul><p>​        那InitialzingBean为什么会先于init-method执行呢？还是看上面提过的AbstractAutowireCapableBeanFactory类中的invokeInitMethods方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, Object bean, @Nullable RootBeanDefinition mbd)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isInitializingBean = bean <span class="keyword">instanceof</span> InitializingBean;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断bean是否实现了isInitializingBean接口，如果实现了isInitializingBean接口就调用afterPropertiesSet方法</span></span><br><span class="line">        <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">"afterPropertiesSet"</span>))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.debug(<span class="string">"Invoking afterPropertiesSet() on bean with name '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    AccessController.doPrivileged(() -&gt; &#123;</span><br><span class="line">                        <span class="comment">//调用afterPropertiesSet方法</span></span><br><span class="line">                        ((InitializingBean)bean).afterPropertiesSet();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;, <span class="keyword">this</span>.getAccessControlContext());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (PrivilegedActionException var6) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> var6.getException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//调用afterPropertiesSet方法</span></span><br><span class="line">                ((InitializingBean)bean).afterPropertiesSet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            String initMethodName = mbd.getInitMethodName();</span><br><span class="line">            <span class="comment">//判断是否指定了initMethod方法，如果指定了则调用</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp; (!isInitializingBean || !<span class="string">"afterPropertiesSet"</span>.equals(initMethodName)) &amp;&amp; !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">                <span class="comment">//反射调用指定的方法</span></span><br><span class="line">                <span class="keyword">this</span>.invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>从上面可以看出<code>InitialzingBean会优先于init-method执行</code></p><p>总结:</p><ol><li>三种方式的执行时机都是在bean的初始化(initializeBean)中执行，<code>@PostConstruct &gt; InitialzingBean &gt; init-method</code></li><li>@PostConstruct的方法是通过一个BeanPostProcess进行处理</li><li>InitialzingBean和init-method则先后在invokeInitMethods()进行执行</li><li>InitialzingBean接口的方法是直接调用而init-method指定的方法通过反射调用，所以前者效率会高一些</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;
            &lt;p&gt;探究initializingBean、init-method、@PostConstruct的执行顺序 &lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="框架" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="http://liuyoubin.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>网络层次模型对应功能及协议</title>
    <link href="http://liuyoubin.top/2020/01/28/netWork/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B%E5%AF%B9%E5%BA%94%E5%8A%9F%E8%83%BD%E5%8F%8A%E5%8D%8F%E8%AE%AE/"/>
    <id>http://liuyoubin.top/2020/01/28/netWork/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B%E5%AF%B9%E5%BA%94%E5%8A%9F%E8%83%BD%E5%8F%8A%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-01-28T08:15:16.000Z</published>
    <updated>2020-03-31T16:24:00.234Z</updated>
    
    <content type="html"><![CDATA[<div class="note info">            <p>网络层次模型相关知识 </p>          </div><a id="more"></a><h1 id="网络层次"><a href="#网络层次" class="headerlink" title="网络层次"></a>网络层次</h1><p><img src="https://s1.ax1x.com/2020/03/31/GlMXzn.png" alt="image"></p><p><strong>应用层</strong></p><p>​        为应用程序提供服务，为操作系统或应用程序提供访问网络的能力。</p><p><strong>表示层</strong></p><p>​        提供数据格式转化、数据加密。例如常见的URL加密、口令加密、图片编解码、数据解压缩。</p><p><strong>会话层</strong></p><p>​        为通道提供访问验证和会话管理。例如：服务器验证用户登陆，断点续传。</p><p><strong>传输层</strong></p><p>​        建立、管理和维护应用程序之间的连接、逻辑通信。</p><p><strong>网络层</strong></p><p>​        提供主机到主机间的寻址连接、分组转发数据。</p><p><strong>数据链路层</strong></p><p>​        在通信实体间建立数据链路连接。</p><p><strong>物理层</strong></p><p>​        为数据端设备提供原始比特流的传输通路。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;
            &lt;p&gt;网络层次模型相关知识 &lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机网络" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Http" scheme="http://liuyoubin.top/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>注解和反射</title>
    <link href="http://liuyoubin.top/2020/01/27/backEnd/java/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"/>
    <id>http://liuyoubin.top/2020/01/27/backEnd/java/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</id>
    <published>2020-01-26T16:52:01.000Z</published>
    <updated>2020-03-20T14:38:05.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><blockquote><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。</p><p>Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。</p></blockquote><a id="more"></a><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><ul><li>@Override - 检查该方法是否是重载方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</li><li>@SuppressWarnings - 指示编译器去忽略注解中声明的警告。</li></ul><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><blockquote><p>元注解就是负责注解其它注解，java定义了4个标准的meta-annocation，他们用来对其他的annocation提供类型作说明</p></blockquote><ul><li>@Target : 用于描述注解的作用范围（即被描述的注解可以用在什么地方）、</li><li>@Retention : 表示在什么级别保存该注解信息，用于描述注解的生命周期 SOURCE&lt;CLASS&lt;RUNTIME</li><li>@Document ：说明该注解将被包含在javadoc中</li><li>@Inherited : 说明子类可以继承父类的该注解</li></ul><h2 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h2><p><strong>注解定义格式</strong>  ： @interface + 注解名</p><p><strong>注解参数格式</strong> ：类型 + 参数名() [defalut 默认值] </p><p><strong>例子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)<span class="comment">//定义注解作用范围</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="comment">//定义注解生命周期</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnocation&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;<span class="comment">//注解可以定义默认值</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>;<span class="comment">//如果没有默认值，在使用注解的时候就必须显式赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><blockquote><p>反射机制允许程序在执行期间借助Reflection API取得任何类的内部信息，并能操作任意对象的内部属性及方法。</p><p>在加载完类之后，会将类的元数据信息（<strong>类的方法代码，变量名，方法名，访问权限，返回值等等</strong>）存在方法区，并在堆中生成一个Class对象，通过这个Class对象就可以获取类的信息。</p></blockquote><ol><li><p>获取Class类对象的几种方式</p><ul><li><p>若已知具体的类，通过类的class属性获取，此方法最安全可靠，程序性能高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Person<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>已知某个类的实例，调用该实例的getClass方法获取class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c2 = person.getClass();</span><br></pre></td></tr></table></figure></li><li><p>已知一个类的全类名，可以通过Class类的静态方法forName获取，可能抛出ClassNotFoundException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c3 = Class.forName(<span class="string">"com.demo.Person"</span>)</span><br></pre></td></tr></table></figure></li><li><p>内置基本数据类型可以直接用类名.Type</p></li><li><p>还可以通过类加载器获取</p></li></ul></li><li><p>类初始化的时机</p><ul><li>当虚拟机启动，先初始化main方法所在的类</li><li>new一个类的对象</li><li>调用类的静态方法，静态变量</li><li>通过反射进行调用</li><li>当初始化一个类，该类的父类没有初始化，会先初始化父类</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;注解&quot;&gt;&lt;a href=&quot;#注解&quot; class=&quot;headerlink&quot; title=&quot;注解&quot;&gt;&lt;/a&gt;注解&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。&lt;/p&gt;
&lt;p&gt;Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="Java" scheme="http://liuyoubin.top/tags/Java/"/>
    
      <category term="注解" scheme="http://liuyoubin.top/tags/%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="反射" scheme="http://liuyoubin.top/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议笔记</title>
    <link href="http://liuyoubin.top/2020/01/26/netWork/HTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/"/>
    <id>http://liuyoubin.top/2020/01/26/netWork/HTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/</id>
    <published>2020-01-26T08:15:16.000Z</published>
    <updated>2020-04-01T13:36:08.218Z</updated>
    
    <content type="html"><![CDATA[<div class="note info">            <p>HTTP相关知识 </p>          </div><a id="more"></a><h1 id="认识URL"><a href="#认识URL" class="headerlink" title="认识URL"></a>认识URL</h1><p><img src="https://s2.ax1x.com/2020/01/26/1nikMq.png" alt="image"></p><h1 id="Http协议简介"><a href="#Http协议简介" class="headerlink" title="Http协议简介"></a>Http协议简介</h1><p>​    http（Hyper Text Transfer Protocol）&lt;超文本传输协议&gt;</p><p>​    http协议就是一种客户端与服务端交互的通信格式</p><h1 id="Http报文"><a href="#Http报文" class="headerlink" title="Http报文"></a>Http报文</h1><h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><h3 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">请求行 【请求方式】【请求地址<span class="comment">(url)</span>】【http协议版本】<span class="comment">(回车符 空格符)</span></span><br><span class="line"></span><br><span class="line">请求头 【消息报头（一般用来说明客户端要使用的一些附加信息）】<span class="comment">(回车符 空格符)</span></span><br><span class="line"></span><br><span class="line">  【空行】<span class="comment">(请求行和请求实体之间必须空行)</span></span><br><span class="line"></span><br><span class="line">请求实体</span><br></pre></td></tr></table></figure><h3 id="请求头属性"><a href="#请求头属性" class="headerlink" title="请求头属性"></a>请求头属性</h3><p><img src="https://s2.ax1x.com/2020/01/26/1nk0qP.png" alt="image"></p><h3 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h3><ul><li>GET ：用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</li><li>POST ：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。</li><li>PUT ：传输文件，报文主体中包含文件内容，保存到对应URI位置。</li><li>DELETE ： 删除文件，与PUT方法相反，删除对应URI位置的文件。</li><li>OPTION : 查询相应URI支持的HTTP方法。</li><li>HEAD : 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</li></ul><h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><h3 id="响应格式"><a href="#响应格式" class="headerlink" title="响应格式"></a>响应格式</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">响应行 【http协议版本】【状态码】【状态消息】<span class="comment">(回车符 空格符)</span></span><br><span class="line"></span><br><span class="line">响应头 【响应报头】【客户端要使用的一些附加信息】<span class="comment">(回车符 空格符)</span></span><br><span class="line"></span><br><span class="line">  【空行】<span class="comment">(响应行和响应数据之间必须空行)</span></span><br><span class="line"></span><br><span class="line">响应实体：正文<span class="comment">(服务器给客户端的信息)</span></span><br></pre></td></tr></table></figure><h3 id="响应头属性"><a href="#响应头属性" class="headerlink" title="响应头属性"></a>响应头属性</h3><p><img src="https://s2.ax1x.com/2020/01/26/1nk2xs.png" alt="image"></p><h3 id="响应码"><a href="#响应码" class="headerlink" title="响应码"></a>响应码</h3><p><strong>1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码</strong></p><ul><li><p>100  （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</p></li><li><p>101  （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。</p></li></ul><hr><p><strong>2xx （成功） 表示成功处理了请求的状态代码</strong></p><ul><li><p>200  （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</p></li><li><p>201  （已创建）  请求成功并且服务器创建了新的资源。</p></li><li><p>202  （已接受）  服务器已接受请求，但尚未处理。</p></li><li><p>203  （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。</p></li><li><p>204  （无内容）  服务器成功处理了请求，但没有返回任何内容。</p></li><li><p>205  （重置内容） 服务器成功处理了请求，但没有返回任何内容。</p></li><li><p>206  （部分内容）客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</p></li></ul><hr><p><strong>3xx （重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向</strong></p><ul><li><p>300  （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent)  选择一项操作，或提供操作列表供请求者选择。</p></li><li><p>301  （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</p></li><li><p>302  （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p></li><li><p>303  （查看其他位置） 与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上</p></li><li><p>304  （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</p></li><li><p>305  （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</p></li><li><p>307  （临时重定向）与302类似，只是强制要求使用POST方法</p></li></ul><hr><p><strong>4xx（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理</strong></p><ul><li><p>400  （错误请求） 服务器不理解请求的语法。</p></li><li><p>401  （未授权） 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。</p></li><li><p>403  （禁止） 服务器拒绝请求。</p></li><li><p>404  （未找到） 服务器找不到请求的网页。</p></li><li><p>405  （方法禁用） 禁用请求中指定的方法。</p></li><li><p>406  （不接受） 无法使用请求的内容特性响应请求的网页。</p></li><li><p>407  （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</p></li><li><p>408  （请求超时）  服务器等候请求时发生超时。</p></li><li><p>409  （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</p></li><li><p>410  （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。</p></li><li><p>411  （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。</p></li><li><p>412  （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。</p></li><li><p>413  （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</p></li><li><p>414  （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。</p></li><li><p>415  （不支持的媒体类型） 请求的格式不受请求页面的支持。</p></li><li><p>416  （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。</p></li><li><p>417  （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</p></li></ul><hr><p><strong>5xx（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错</strong></p><ul><li><p>500  （服务器内部错误）  服务器遇到错误，无法完成请求。</p></li><li><p>501  （尚未实施） 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</p></li><li><p>502  （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</p></li><li><p>503  （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</p></li><li><p>504  （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p></li><li><p>505  （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p></li></ul><h1 id="Http协议特点"><a href="#Http协议特点" class="headerlink" title="Http协议特点"></a>Http协议特点</h1><ul><li><p>无连接</p><p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户端的请求，并收到客户端的答应后，即断开连接，采用这种方法可以节省时间</p></li><li><p>无状态</p><p><strong>无状态协议对于事务处理没有记忆能力</strong>。<strong>缺少状态意味着如果后续处理需要前面的信息</strong>，样可能导致每次连接的传送的数据量增大。另一方面，每次服务器不需要面内容时答应快。</p></li><li><p>灵活</p><p>http协议可以传输任意类型的数据，正在传输的数据类型由Context-Type标记</p></li><li><p>基于TCP</p></li></ul><h1 id="一次完整的HTTP请求所经历的7个步骤"><a href="#一次完整的HTTP请求所经历的7个步骤" class="headerlink" title="一次完整的HTTP请求所经历的7个步骤"></a>一次完整的HTTP请求所经历的7个步骤</h1><p>HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：</p><ul><li>建立TCP连接</li></ul><p>在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。<strong>HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。</strong></p><ul><li>Web浏览器向Web服务器发送请求行</li></ul><p>一旦建立了TCP连接，<strong>Web浏览器就会向Web服务器发送请求命令</strong>。例如：GET /sample/hello.jsp HTTP/1.1。</p><ul><li><p>Web浏览器发送请求头</p></li><li><ul><li>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，<strong>之后浏览器发送了一空白行来通知服务器</strong>，它已经结束了该头信息的发送。</li></ul></li><li><p>Web服务器应答</p></li><li><ul><li>客户机向服务器发出请求后，服务器会客户机回送应答， <strong>HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</strong></li></ul></li><li><p>Web服务器发送应答头</p></li><li><ul><li>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</li></ul></li><li><p>Web服务器向浏览器发送数据</p></li><li><ul><li>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，<strong>它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据</strong>。</li></ul></li><li><p>Web服务器关闭TCP连接</p><p><code>Connection:keep-alive</code></p></li><li><ul><li>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：</li></ul></li></ul><p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p><p>建立TCP连接-&gt;发送请求行-&gt;发送请求头-&gt;（到达服务器）发送状态行-&gt;发送响应头-&gt;发送响应数据-&gt;断TCP连接</p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>​        Https协议是在Http协议的基础上和SSL/TLS证书结合起来的一种协议，保证了传输过程的数据安全性，减少了恶意劫持的行为。</p><ul><li>对称加密<ul><li>对称加密就是加密解密的密钥是同一把，这就要求通讯双方一开始就能安全地确认密钥，加密速度快、加密效率高。</li></ul></li><li>非对称加密<ul><li>非对称加密就是加密解密用不同的密钥，通过公钥进行加密，私钥进行解密。非对称加密减少双方保存密钥的负担，缺点是加密速度慢。</li></ul></li></ul><p>​        <strong>Https使用的加密方式是：混合加密方式。</strong></p><h2 id="Https的过程"><a href="#Https的过程" class="headerlink" title="Https的过程"></a>Https的过程</h2><p><img src="https://s1.ax1x.com/2020/04/01/G8avDO.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;
            &lt;p&gt;HTTP相关知识 &lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机网络" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Http" scheme="http://liuyoubin.top/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java中的值传递与引用传递</title>
    <link href="http://liuyoubin.top/2020/01/25/backEnd/java/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>http://liuyoubin.top/2020/01/25/backEnd/java/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</id>
    <published>2020-01-25T13:17:36.000Z</published>
    <updated>2020-02-25T17:36:46.227Z</updated>
    
    <content type="html"><![CDATA[<div class="note info">            <p>在Java中到底是值传递还是引用传递还是两者都有? </p>          </div><a id="more"></a><h4 id="Java到底是值传递与引用传递"><a href="#Java到底是值传递与引用传递" class="headerlink" title="Java到底是值传递与引用传递?"></a>Java到底是值传递与引用传递?</h4><p>​        对于这个问题，网上一直有很大的争议。有很多人认为只有值传递；也有很大一部分人认为Java既有值传递也有引用传递。认为Java既有值传递也有引用传递的人大都认为基本数据类型的传递是值传递，而引用类型的传递就是引用传递。</p><p><strong>对于这个问题我先给出结论:</strong></p><p>​     <strong>Java只有值传递没有引用传递</strong></p><hr><h4 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h4><p>先来看一下概念:</p><ul><li><p>值传递: 方法调用时，实参的数值被复制出另一个副本，然后传递副本</p></li><li><p>引用传递: 方法调用时,实参的地址直接传递到被调用的方法中</p></li></ul><table><thead><tr><th></th><th align="center">值传递</th><th align="center">引用传递</th></tr></thead><tbody><tr><td>本质区别</td><td align="center">方法调用时，实参复制副本进行传递</td><td align="center">方法调用时，实参地址直接进行传递</td></tr><tr><td>是否改变原来参数</td><td align="center">否</td><td align="center">是</td></tr></tbody></table><p>​      从上面可以看出值传递与引用传递的本质区别是: <code>方法调用时是传递了实参的副本还是实参的地址</code>,与实参的类型没有关系</p><hr><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><h5 id="验证基本数据类型"><a href="#验证基本数据类型" class="headerlink" title="验证基本数据类型"></a>验证基本数据类型</h5><ul><li>代码</li></ul><p><img src="https://s2.ax1x.com/2020/01/25/1eqMss.png" alt="image"></p><ul><li>运行结果</li></ul><p><img src="https://s2.ax1x.com/2020/02/26/3tx2Os.png" alt="image"></p><ul><li>说明</li></ul><p><code>上面结果表明基本数据类型的传递是值传递，方法改变的是实参的副本，原来参数不会发生改变</code></p><h5 id="验证引用类型"><a href="#验证引用类型" class="headerlink" title="验证引用类型"></a>验证引用类型</h5><ul><li>代码</li></ul><p><img src="https://s2.ax1x.com/2020/01/26/1ejsnH.png" alt="image"></p><ul><li>结果</li></ul><p><img src="https://s2.ax1x.com/2020/01/26/1ejR4P.png" alt="image"></p><p>​      <strong>看到这里是不是有疑问,不是说值传递不会改变原来参数的值吗？这不就改变了吗，难道上面的结论是错的?</strong></p><p>​      其实结论并没有错，上面已经讲了值传递传递的是实参的副本，而我们在<code>传递引用类型的时候传递的并不是对象本身而是引用</code>。所以看是不是<code>值传递</code>就看这个引用到底有没有被复制。</p><p>​     看一下下面这张图就清楚了，上面的代码执行的时候发生了什么?</p><p><img src="https://s2.ax1x.com/2020/02/26/3txclQ.png" alt="image"></p><p>​        对于引用类型来说，参数传递的过程中传递的不是对象本身而是引用。引用发生了复制，传递的是副本，引用指向了同一对象。这也是为什么对象信息会发生改变但又说是值传递的原因了。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;
            &lt;p&gt;在Java中到底是值传递还是引用传递还是两者都有? &lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="Java" scheme="http://liuyoubin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>排序算法整理</title>
    <link href="http://liuyoubin.top/2020/01/25/algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>http://liuyoubin.top/2020/01/25/algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/</id>
    <published>2020-01-25T12:36:57.000Z</published>
    <updated>2020-03-04T15:12:55.742Z</updated>
    
    <content type="html"><![CDATA[<div class="note info">            <p>常见排序算法整理 </p>          </div><a id="more"></a><h1 id="排序算法开篇"><a href="#排序算法开篇" class="headerlink" title="排序算法开篇"></a>排序算法开篇</h1><p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：<strong>插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序</strong>等</p><p><img src="https://s2.ax1x.com/2020/02/29/3sb3in.png" alt="image"></p><h2 id="关于时间复杂度"><a href="#关于时间复杂度" class="headerlink" title="关于时间复杂度"></a>关于时间复杂度</h2><ul><li>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。</li><li>线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序。</li><li>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。希尔排序。</li><li>线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。</li></ul><h2 id="关于稳定性"><a href="#关于稳定性" class="headerlink" title="关于稳定性"></a>关于稳定性</h2><ul><li>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</li><li>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</li></ul><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li><p>n：数据规模</p></li><li><p>k：“桶”的个数</p></li><li><p>In-place：占用常数内存，不占用额外内存</p></li><li><p>Out-place：占用额外内存</p></li><li><p>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</p></li></ul><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h2 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h2><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;array.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = array[j];</span><br><span class="line">                    array[j]=array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="介绍：-1"><a href="#介绍：-1" class="headerlink" title="介绍："></a>介绍：</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><h2 id="算法步骤：-1"><a href="#算法步骤：-1" class="headerlink" title="算法步骤："></a>算法步骤：</h2><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ol><h2 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//记录目前最小元素下标</span></span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;array.length;j++)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(array[minIndex]&gt;array[j])&#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(minIndex!=i)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = array[i];</span><br><span class="line">                array[i] = array[minIndex];</span><br><span class="line">                array[minIndex] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="介绍：-2"><a href="#介绍：-2" class="headerlink" title="介绍："></a>介绍：</h2><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入</p><h2 id="算法步骤：-2"><a href="#算法步骤：-2" class="headerlink" title="算法步骤："></a>算法步骤：</h2><ol><li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li></ol><h2 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从下标1开始扫描,下标0的元素默认为有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="comment">//记录待插入的元素</span></span><br><span class="line">            <span class="keyword">int</span> tmp = array[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;<span class="number">0</span> &amp;&amp; tmp&lt;array[j-<span class="number">1</span>])&#123;</span><br><span class="line">                array[j] = array[j-<span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//存在比其小的数，插入</span></span><br><span class="line">            <span class="keyword">if</span>(j!=i)&#123;</span><br><span class="line">                array[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="介绍：-3"><a href="#介绍：-3" class="headerlink" title="介绍："></a>介绍：</h2><p>​    希尔排序是插入排序的一种改进，也称<strong>递减增量排序</strong>。希尔排序的基本思想是先将整个待排序的序列分割成若干个序列分别进行插入排序，待整个序列基本有序后，再对整个列表进行插入排序</p><h2 id="算法步骤：-3"><a href="#算法步骤：-3" class="headerlink" title="算法步骤："></a>算法步骤：</h2><ol><li>选择一个增量序列，t1、t2、……tk，其中ti&gt;tj ，tk=1</li><li>按增量序列个数k，进行k趟排序</li><li>每次排序分别对每个子表进行插入排序，待到增量因子为1时进行一次整个序列的插入排序</li></ol><h2 id="代码实现：-3"><a href="#代码实现：-3" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定增量</span></span><br><span class="line">        <span class="keyword">int</span> gap = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(gap&lt;array.length)&#123;</span><br><span class="line">            gap = gap*<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(gap&gt;<span class="number">0</span>)&#123;<span class="comment">//当增量大于0时进行一次排序</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//每次排序对每个子序列进行插入排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i&lt;array.length ;i++)&#123;</span><br><span class="line">                <span class="comment">//待插入的元素</span></span><br><span class="line">                <span class="keyword">int</span> temp = array[i];</span><br><span class="line">                <span class="keyword">int</span> j = i-gap;</span><br><span class="line">                <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; array[j]&gt;temp)&#123;</span><br><span class="line">                    array[j+gap] = array[j];</span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                array[j+gap] = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//增量减小</span></span><br><span class="line">            gap = (<span class="keyword">int</span>)Math.floor(gap/<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="介绍：-4"><a href="#介绍：-4" class="headerlink" title="介绍："></a>介绍：</h2><p>​        归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><h2 id="算法步骤：-4"><a href="#算法步骤：-4" class="headerlink" title="算法步骤："></a>算法步骤：</h2><ol><li>将待排序的数据进行平均分割，递归地执行这个操作，直到每一个子序列只有一个元素</li><li>将子序列进行排序合并，合并完成后返回，再继续递归地进行这个操作</li></ol><h2 id="代码实现：-4"><a href="#代码实现：-4" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(array.length&lt;=<span class="number">1</span>)&#123;<span class="comment">//递归终止</span></span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = array.length/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] left = Arrays.copyOfRange(array,<span class="number">0</span>,mid);</span><br><span class="line">        <span class="keyword">int</span>[] right = Arrays.copyOfRange(array,mid,array.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge(sort(left),sort(right));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length+right.length];</span><br><span class="line">        <span class="comment">//指向左右数组的待排序位置</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//指向合并数组的插入位置</span></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i&lt;left.length&amp;&amp;j&lt;right.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left[i]&lt;=right[j])&#123;</span><br><span class="line">                result[k++]=left[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result[k++]=right[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i&lt;left.length)&#123;</span><br><span class="line">            result[k++]=left[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j&lt;right.length)&#123;</span><br><span class="line">            result[k++]=right[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="介绍：-5"><a href="#介绍：-5" class="headerlink" title="介绍："></a>介绍：</h2><p>​        快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。快速排序利用分治思想，将待排序数组分成左右两个部分，然后对其分别递归调用快速排序算法。</p><h2 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h2><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><h2 id="代码实现：-5"><a href="#代码实现：-5" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quickSort(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="comment">//排序并获取基准元素的下标</span></span><br><span class="line">        <span class="keyword">int</span> partitionIndex = partition(array,left,right);</span><br><span class="line">        quickSort(array, left, partitionIndex-<span class="number">1</span>);</span><br><span class="line">        quickSort(array, partitionIndex+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//两个哨兵</span></span><br><span class="line">    <span class="keyword">int</span> i=left , j=right;</span><br><span class="line">    <span class="comment">//基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = array[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">        <span class="comment">//从左向右找一个比标准元素小的元素,一定要j哨兵先走</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;j &amp;&amp; array[j]&gt;=pivot)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从右向左找一个比标准元素大的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;j &amp;&amp; array[i]&lt;=pivot)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">            swap(array, i, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将基准元素与哨兵相遇点元素交换</span></span><br><span class="line">    swap(array, left, i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;
            &lt;p&gt;常见排序算法整理 &lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://liuyoubin.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://liuyoubin.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat学习笔记</title>
    <link href="http://liuyoubin.top/2020/01/25/backEnd/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://liuyoubin.top/2020/01/25/backEnd/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-01-25T12:29:08.000Z</published>
    <updated>2020-02-26T07:34:29.715Z</updated>
    
    <content type="html"><![CDATA[<div class="note info">            <p>Tomcat相关知识笔记 </p>          </div><a id="more"></a><h2 id="Tomcat目录"><a href="#Tomcat目录" class="headerlink" title="Tomcat目录"></a>Tomcat目录</h2><ul><li><p>bin</p><p>bin目录主要是用来存放tomcat的命令，主要有两大类，一类是以.sh结尾的（linux命令），另一类是以.bat结尾的（windows命令）。</p></li><li><p>conf</p><p>conf目录主要是用来存放tomcat的一些配置文件。</p><p>server.xml可以设置端口号、设置域名或IP、默认加载的项目、请求编码<br>web.xml可以设置tomcat支持的文件类型<br>context.xml可以用来配置数据源之类的<br>tomcat-users.xml用来配置管理tomcat的用户与权限<br>在Catalina目录下可以设置默认加载的项目</p></li><li><p>lib</p><p>lib目录主要用来存放tomcat运行需要加载的jar包。</p></li><li><p>logs</p><p>logs目录用来存放tomcat在运行过程中产生的日志文件。</p><p>在windows环境中，控制台的输出日志在catalina.xxxx-xx-xx.log文件中</p><p>在linux环境中，控制台的输出日志在catalina.out文件中</p></li><li><p>temp</p><p>temp目录用户存放tomcat在运行过程中产生的临时文件。</p></li><li><p>webapps</p><p>webapps目录用来存放应用程序，当tomcat启动时会去加载webapps目录下的应用程序。可以以文件夹、war包、jar包的形式发布应用。<br>当然，你也可以把应用程序放置在磁盘的任意位置，在配置文件中映射好就行。</p></li><li><p>work</p><p>work目录用来存放tomcat在运行时的编译后文件，例如JSP编译后的文件。</p></li></ul><h2 id="Tomcat结构"><a href="#Tomcat结构" class="headerlink" title="Tomcat结构"></a>Tomcat结构</h2><h3 id="Tomcat顶层架构"><a href="#Tomcat顶层架构" class="headerlink" title="Tomcat顶层架构"></a>Tomcat顶层架构</h3><p><img src="https://s2.ax1x.com/2020/01/07/l6vjQP.png" alt="l6vjQP.png"></p><p>Tomcat最顶层的容器是<strong>Server</strong>代表整个服务器,一个<strong>Server</strong>至少可以包含一个<strong>Service</strong>，用于提供具体服务</p><p><strong>Service</strong>主要包含两个部分：<strong>Connection</strong>和<strong>Container</strong></p><blockquote><p><code>Connector</code>: 连接器用于处理连接相关的事情，并提供<code>Socket</code>与<code>Request</code>和<code>Response</code>相关的转换；<code>Container</code>: 容器用于封装和管理<code>Servlet</code>，以及具体处理<code>Request</code>请求；</p></blockquote><h3 id="Connection和Container的关系"><a href="#Connection和Container的关系" class="headerlink" title="Connection和Container的关系"></a>Connection和Container的关系</h3><p>一个请求发送到<code>Tomcat</code>后，交给<code>Service</code>，<code>Service</code>会将请求交给<code>Connector</code>,<code>Connector</code>用于接收请求并将请求封装成<code>Request</code>对象交给<code>Container</code>处理，处理完后<code>Container</code>将<code>Response</code>交给<code>Connection</code>,<code>Connection</code>将结构通过Socket返回给客户端。</p><h3 id="Container架构"><a href="#Container架构" class="headerlink" title="Container架构"></a>Container架构</h3><p><img src="https://s2.ax1x.com/2020/01/07/lcCnPg.png" alt="lcCnPg.png"></p><blockquote><p>Engine：引擎，用来管理多站点，一个Service最多只有能有一个Engine;<br>Host：代表一个站点，也可以叫做虚拟主机，通过配置Host就可以添加站点；<br>Context：代表一个应用程序，对应着平时开发的一套程序，或者一个WEB-INF目录以及下面的web.xml文件；<br>Wrapper：每一个wrapper封装着一个Servlet;</p></blockquote><h2 id="Tomcat四种部署方式"><a href="#Tomcat四种部署方式" class="headerlink" title="Tomcat四种部署方式"></a>Tomcat四种部署方式</h2><ul><li>将应用文件夹部署到webapps下</li><li>将war包部署到webapps下</li><li>通过server.xml中的Context节点配置</li><li>通过描述符部署（\conf\Catalina)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;
            &lt;p&gt;Tomcat相关知识笔记 &lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="http://liuyoubin.top/categories/%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Tomcat" scheme="http://liuyoubin.top/tags/Tomcat/"/>
    
  </entry>
  
</feed>
